     1                                  cpu	8086
     2                                  
     3                                  %include "macros.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; macro.inc - Defines macros
     3                              <1> ;       setloc
     4                              <1> ;-------------------------------------------------------------------------
     5                              <1> ;
     6                              <1> ; Compiles with NASM 2.07, might work with other versions
     7                              <1> ;
     8                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
     9                              <1> ; Provided for hobbyist use on the Xi 8088 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;=========================================================================
    25                              <1> 
    26                              <1> ;=========================================================================
    27                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    28                              <1> ;-------------------------------------------------------------------------
    29                              <1> %imacro setloc  1.nolist
    30                              <1> %assign pad_bytes (%1-($-$$)-START)
    31                              <1> %if pad_bytes < 0
    32                              <1> %assign over_bytes -pad_bytes
    33                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
    34                              <1> %endif
    35                              <1> %if pad_bytes > 0
    36                              <1> %warning Inserting pad_bytes bytes
    37                              <1>  times  pad_bytes db 0FFh
    38                              <1> %endif
    39                              <1> %endm
    40                              <1> 
    41                              <1> %macro pic_eoi_cmd 0
    42                              <1>         push ax
    43                              <1>         ;mov al, byte es:[mem_led_reg]
    44                              <1>         ;inc al
    45                              <1>         ;mov byte es:[mem_led_reg],al
    46                              <1>         ;out 0x80, al 
    47                              <1>         mov al, 0b00100000
    48                              <1>         out PIC_REG_0, al
    49                              <1>         pop ax
    50                              <1> %endmacro
     4                                  %include "vars.inc"
     1                              <1> flagMemOk		    equ		0401h ;This location has 0 if memory block ok other wise has 1
     2                              <1> 
     3                              <1> mem_led_reg         equ     0x0501  ;Led status register
     4                              <1> mem_timeout01       equ     0x0502  ;Timer timeout value Ex.: 5 seconds
     5                              <1> mem_timer01         equ     0x0503  ;dw Timer atual value plus timeout Ex 1000 + 5 seconds 
     6                              <1> 
     7                              <1> inline_buffer       equ     0x050F  ;buffer 128 bytes
     8                              <1> buff_read           equ     0x050F  ;buffer 128 bytes
     9                              <1> buff_write          equ     0x058F  ;buffer 128 bytes
    10                              <1> abc                 equ     0x060F  ;dd 9ABCDEF0h
    11                              <1> def                 equ     0x0614  ;dd 12345678h
    12                              <1> ghi                 equ     0x0618  ;dw ?
    13                              <1> sys_tick_count      equ     0x006C  ;dw system tick
    14                              <1> bcs                 equ     0x061E  ;db byte check sum
    15                              <1> bcs_error           equ     0x061F    ; byte check sum = 1 error
    16 00000000 0200                <1> user_ds     dw 2
    17 00000002 0200                <1> user_es     dw 2
    18 00000004 0200                <1> user_ss     dw 2
    19 00000006 0200                <1> user_sp     dw 2
    20                              <1> 
    21                              <1> bs                  equ     8
     5                                  
     6                                  %define	START		0x0000		
     7                                  %define DATE		'22/11/24'
     8                                  %define MODEL_BYTE	0FEh		; IBM PC/XT
     9                                  %define VERSION		'1.0.00'	; BIOS version
    10                                  
    11                                  org	START		
    12                                  
    13                                  
    14 00000008 0D0A58542038303838-     welcome		db	cr,lf,"XT 8088 BIOS, Version ",VERSION
    14 00000011 2042494F532C205665-
    14 0000001A 7273696F6E20312E30-
    14 00000023 2E3030             
    15 00000026 0D0A5061756C6F2053-     			db	cr,lf,"Paulo Silva(pgordao) - Copyright (C) 2024"
    15 0000002F 696C76612870676F72-
    15 00000038 64616F29202D20436F-
    15 00000041 707972696768742028-
    15 0000004A 43292032303234     
    16 00000051 0D0A43505520383038-     			db	cr,lf,"CPU 8088-2   board: 8088BOAD2447-RA  "
    16 0000005A 382D32202020626F61-
    16 00000063 72643A203830383842-
    16 0000006C 4F4144323434372D52-
    16 00000075 412020             
    17 00000078 0D0A38303838204D6F-     			db	cr,lf,"8088 MonitorV0 V ",VERSION ," 2447A 512 Sram Rom at29C512"
    17 00000081 6E69746F7256302056-
    17 0000008A 20312E302E30302032-
    17 00000093 343437412035313220-
    17 0000009C 5372616D20526F6D20-
    17 000000A5 6174323943353132   
    18 000000AD 0D0A4120746F74616C-     			db  cr,lf,"A total of 64k minimum are ok..", eos
    18 000000B6 206F662036346B206D-
    18 000000BF 696E696D756D206172-
    18 000000C8 65206F6B2E2E00     
    19 000000CF 0D0A42696F73206C6F-     biosloaded	db  cr,lf,"Bios loaded...", eos
    19 000000D8 616465642E2E2E00   
    20 000000E0 0D0A3D3D3D3D3D3D3D-     help_msg	db cr,lf,"=========================="
    20 000000E9 3D3D3D3D3D3D3D3D3D-
    20 000000F2 3D3D3D3D3D3D3D3D3D-
    20 000000FB 3D                 
    21 000000FC 0D0A636D6420202064-     			db cr,lf,"cmd   description"
    21 00000105 65736372697074696F-
    21 0000010E 6E                 
    22 0000010F 0D0A20622020202072-     			db cr,lf," b    read boot loader"
    22 00000118 65616420626F6F7420-
    22 00000121 6C6F61646572       
    23 00000127 0D0A20642020202064-     			db cr,lf," d    dump memory using ES"
    23 00000130 756D70206D656D6F72-
    23 00000139 79207573696E672045-
    23 00000142 53                 
    24 00000143 0D0A20652020202065-     			db cr,lf," e    edit memory "
    24 0000014C 646974206D656D6F72-
    24 00000155 7920               
    25 00000157 0D0A20662020202066-     			db cr,lf," f    fill memory "
    25 00000160 696C6C206D656D6F72-
    25 00000169 7920               
    26 0000016B 0D0A206C202020206C-     			db cr,lf," l    load intel hex file"
    26 00000174 6F616420696E74656C-
    26 0000017D 206865782066696C65 
    27 00000186 0D0A20702020202077-     			db cr,lf," p    write 16-bit data to onchip peripherals"
    27 0000018F 726974652031362D62-
    27 00000198 697420646174612074-
    27 000001A1 6F206F6E6368697020-
    27 000001AA 706572697068657261-
    27 000001B3 6C73               
    28 000001B5 0D0A206F202020206F-     			db cr,lf," o    output byte to output port"
    28 000001BE 757470757420627974-
    28 000001C7 6520746F206F757470-
    28 000001D0 757420706F7274     
    29 000001D7 0D0A20692020202069-     			db cr,lf," i    input byte from input port"
    29 000001E0 6E7075742062797465-
    29 000001E9 2066726F6D20696E70-
    29 000001F2 757420706F7274     
    30 000001F9 0D0A20732020202072-     			db cr,lf," s    read sector 1"
    30 00000202 65616420736563746F-
    30 0000020B 722031             
    31 0000020E 0D0A20572020202077-     			db cr,lf," W    write sector "
    31 00000217 726974652073656374-
    31 00000220 6F7220             
    32 00000223 0D0A20772020202077-     			db cr,lf," w    write sector 1"
    32 0000022C 726974652073656374-
    32 00000235 6F722031           
    33 00000239 0D0A20742020202073-     			db cr,lf," t    show systick"
    33 00000242 686F77207379737469-
    33 0000024B 636B               
    34 0000024D 0D0A20682020202066-     			db cr,lf," h    for this help", cr, lf, eos
    34 00000256 6F7220746869732068-
    34 0000025F 656C700D0A00       
    35                                  
    36 00000265 FF<rep CD9Bh>           setloc	0D000h
    36          ******************       warning: Inserting 52635 bytes [-w+user]
    37                                  reset:
    38 0000D000 FA                                  cli
    39 0000D001 B84000                      		mov ax,0x40
    40 0000D004 8ED8                        		mov ds,ax
    41 0000D006 C70672000000            			mov word [0x72],0x0
    42 0000D00C 31C0                        		xor ax,ax
    43 0000D00E 7248                        		jc l0xb3
    44 0000D010 7046                        		jo l0xb3
    45 0000D012 7844                        		js l0xb3
    46 0000D014 7542                        		jnz l0xb3
    47 0000D016 7B40                        		jpo l0xb3
    48 0000D018 83C001                      		add ax,0x1
    49 0000D01B 743B                        		jz l0xb3
    50 0000D01D 7A39                        		jpe l0xb3
    51 0000D01F 2D0280                      		sub ax,0x8002
    52 0000D022 7834                        		js l0xb3
    53 0000D024 40                          		inc ax
    54 0000D025 7131                        		jno l0xb3
    55 0000D027 D1E0                        		shl ax,1
    56 0000D029 732D                        		jnc l0xb3
    57 0000D02B 752B                        		jnz l0xb3
    58 0000D02D D1E0                        		shl ax,1
    59 0000D02F 7227                        		jc l0xb3   
    60 0000D031 BB5555                      		mov bx,0x5555
    61 0000D034 89DD                    l0x8f:    	mov bp,bx
    62 0000D036 89E9                        		mov cx,bp
    63 0000D038 89CC                        		mov sp,cx
    64 0000D03A 89E2                        		mov dx,sp
    65 0000D03C 8ED2                        		mov ss,dx
    66 0000D03E 8CD6                        		mov si,ss
    67 0000D040 8EC6                        		mov es,si
    68 0000D042 8CC7                        		mov di,es
    69 0000D044 8EDF                        		mov ds,di
    70 0000D046 8CD8                        		mov ax,ds
    71 0000D048 3D5555                      		cmp ax,0x5555
    72 0000D04B 7506                        		jnz l0xae
    73 0000D04D F7D0                        		not ax
    74 0000D04F 89C3                        		mov bx,ax
    75 0000D051 EBE1                        		jmp short l0x8f
    76 0000D053 35AAAA                  l0xae: 		xor ax,0xaaaa
    77 0000D056 7403                        		jz l0xb4
    78 0000D058 E9C90D                  l0xb3: 		jmp led3blinks
    79 0000D05B FC                      l0xb4: 		cld                     
    80                                              ;Verify if the board has at least 32kbytes of RAM
    81 0000D05C E9AB0F                              jmp testFirst64kb
    82                                  
    83                                  initBios:
    84 0000D05F B80000                          mov ax, 0x0000
    85 0000D062 8EC0                            mov es, ax
    86 0000D064 8ED0                            mov ss, ax                  ; Segmento Stack
    87 0000D066 B800F0                          mov ax, 0xF000
    88 0000D069 8ED8                            mov ds, ax
    89 0000D06B 8EC8                    		mov cs, ax
    90                                          ;Put 0x8000 in stack pointer top of the first 32kbytes of mem
    91 0000D06D 31E4                            xor sp, sp          ;The minimum of 64k of ram are OK.
    92 0000D06F 31C0                            xor ax, ax              ; Put flags in known state
    93 0000D071 50                              PUSH AX
    94 0000D072 9D                              POPF
    95 0000D073 B000                    		mov	al, 0x0
    96 0000D075 26A20105                		mov byte es:[mem_led_reg],al
    97                                     
    98                                  ;******************************************************
    99                                  ; END INITIALIZATION
   100                                  ;======================================================
   101                                  ;PUT MAIN CODE HERE
   102 0000D079 E88201                  		call configure_uart
   103                                  
   104 0000D07C E8C30C                  		call scr_clear
   105 0000D07F BE[0800]                		mov  si, welcome
   106 0000D082 E8F801                  		call pstr
   107                                  
   108 0000D085 E80E10                  		call memoryTest
   109                                  
   110 0000D088 E87112                  		call init_system
   111 0000D08B B000                            mov al,0x0
   112 0000D08D 26A20105                        mov byte es:[mem_led_reg],al
   113                                  		;Checking cpu type
   114 0000D091 E85129                  		call cpu_check
   115                                  		;Loading bios 
   116 0000D094 E8041C                  		call BiosLoad
   117 0000D097 BB[CF00]                		mov	 BX, biosloaded
   118 0000D09A B410                    		mov	 Ah, 0x10
   119 0000D09C CD10                    		INT	 0x10
   120                                  Mainloop:
   121 0000D09E E8F113                  		call	printPrompt
   122 0000D0A1 E81802                  		call	cin_blct
   123 0000D0A4 E8F701                  		call	cout
   124 0000D0A7 3C62                    		cmp		al, 'b'
   125 0000D0A9 7460                    		je 		bootRecord
   126 0000D0AB 3C64                    		cmp		al, 'd'
   127 0000D0AD 7503E90301              		je 		show_dump
   128 0000D0B2 3C65                    		cmp		al, 'e'
   129 0000D0B4 7503E90501              		je		editmemory
   130 0000D0B9 3C66                    		cmp		al, 'f'
   131 0000D0BB 7503E9BC00              		je		fillMemory
   132 0000D0C0 3C6C                    		cmp		al, 'l'
   133 0000D0C2 7503E9BE00              		je		ldIntelHex
   134 0000D0C7 3C68                    		cmp		al, 'h'
   135 0000D0C9 7503E90C01              		je 		show_help_msg
   136 0000D0CE 3C6A                    		cmp		al, 'j'
   137 0000D0D0 7434                    		je 		jump
   138 0000D0D2 3C73                    		cmp		al, 's'
   139 0000D0D4 743D                    		je 		readSector1
   140 0000D0D6 3C57                    		cmp		al, 'W'
   141 0000D0D8 7470                    		je 		writeSector
   142 0000D0DA 3C77                    		cmp		al, 'w'
   143 0000D0DC 7503E98200              		je 		writeSector1
   144 0000D0E1 3C74                    		cmp		al, 't'
   145 0000D0E3 7503E9DF00              		je 		show_systic
   146 0000D0E8 3C72                    		cmp		al, 'r'
   147 0000D0EA 7503E9BA00              		je 		show_reg
   148 0000D0EF 3C71                    		cmp		al, 'q'
   149 0000D0F1 7503E99800              		je 		writePeripherals
   150 0000D0F6 3C6F                    		cmp		al, 'o'
   151 0000D0F8 7503E99A00              		je 		outByte
   152 0000D0FD 3C69                    		cmp		al, 'i'
   153 0000D0FF 7503E99C00              		je 		inByte
   154                                  
   155                                  
   156                                  		;CALL	newLine
   157 0000D104 EB98                    		jmp 	Mainloop	
   158                                  jump:
   159 0000D106 E91829                  	jmp	jump01	
   160 0000D109 EB93                    	jmp 	Mainloop	
   161                                  bootRecord:
   162 0000D10B E8ED28                  		call 	BOOT_DRIVE		
   163 0000D10E E83601                  		call	newLine
   164 0000D111 EB8B                    		jmp 	Mainloop	
   165                                  readSector1:		
   166 0000D113 B8C007                  	MOV AX, 0X07C0 	;0X07C0:0X0000
   167 0000D116 8EC0                    	MOV ES, AX		;ES:BX = ADDRESS BUFFER
   168 0000D118 B80102                  	MOV AX, 0X0201	;READ ONE SECTOR
   169 0000D11B BB0000                  	MOV BX, 0X0000	;ES:BX = ADDRESS BUFFER
   170 0000D11E B90100                  	MOV CX, 0X0001	;1 SECTOR
   171 0000D121 BA8100                  	MOV DX, 0X0081	;DRIVE TO BOOT UP 0=A, 80=C
   172                                  
   173 0000D124 E86B13                  		call	printPrompt
   174 0000D127 E89201                  		call	cin_blct
   175 0000D12A E87101                  		call	cout
   176 0000D12D E8B911                  		call 	to_hex
   177 0000D130 88C1                    		mov		cl, al
   178 0000D132 B8C007                  	MOV AX, 0X07C0 	;0X07C0:0X0000
   179 0000D135 8EC0                    	MOV ES, AX		;ES:BX = ADDRESS BUFFER
   180 0000D137 B80102                  	MOV AX, 0X0201	;READ ONE SECTOR
   181 0000D13A BB0000                  	MOV BX, 0X0000	;ES:BX = ADDRESS BUFFER
   182 0000D13D B500                    	MOV CH, 0X00	;
   183 0000D13F BA8100                  	MOV DX, 0X0081	;DRIVE TO BOOT UP 0=A, 80=C
   184 0000D142 CD13                    	INT 0X13		;INT 13
   185 0000D144 E80001                  		call	newLine
   186 0000D147 E954FF                  		jmp 	Mainloop	
   187                                  ;AH = 03h
   188                                  ;AL = number of sectors to read (must be nonzero)
   189                                  ;CH = low eight bits of cylinder number
   190                                  ;CL = sector number 1-63 (bits 0-5)
   191                                  ;high two bits of cylinder (bits 6-7, hard disk only)
   192                                  ;DH = head number
   193                                  ;DL = drive number (bit 7 set for hard disk)
   194                                  ;ES:BX -> data buffer		
   195                                  writeSector:		
   196 0000D14A B8C007                  		MOV AX, 0X07C0 	;0X07C0:0X0000
   197 0000D14D 8EC0                    		MOV ES, AX		;ES:BX = ADDRESS BUFFER
   198 0000D14F B80103                  		MOV AX, 0X0301	;WRITE ONE SECTOR
   199 0000D152 BB0000                  		MOV BX, 0x0 	;ES:BX = ADDRESS BUFFER
   200 0000D155 B90100                  		MOV CX, 0X0001	;1 SECTOR
   201 0000D158 BA8100                  		MOV DX, 0X0081	;DRIVE TO BOOT UP 0=A, 80=C
   202 0000D15B CD13                    		INT 0X13		;INT 13
   203 0000D15D E8E700                  		call	newLine
   204 0000D160 E93BFF                  		jmp 	Mainloop	
   205                                  writeSector1:		
   206 0000D163 B800F0                  		MOV AX, 0XF000 	;0X07C0:0X0000
   207 0000D166 8EC0                    		MOV ES, AX		;ES:BX = ADDRESS BUFFER
   208 0000D168 B80103                  		MOV AX, 0X0301	;READ ONE SECTOR
   209 0000D16B BB[ABEA]                		MOV BX, sector1	;ES:BX = ADDRESS BUFFER
   210 0000D16E B90100                  		MOV CX, 0X0001	;1 SECTOR
   211 0000D171 BA8100                  		MOV DX, 0X0081	;DRIVE TO BOOT UP 0=A, 80=C
   212 0000D174 CD13                    		INT 0X13		;INT 13
   213 0000D176 E8CE00                  		call	newLine
   214 0000D179 E922FF                  		jmp 	Mainloop	
   215                                  fillMemory:		
   216 0000D17C E89D15                  		call 	fill_memory
   217 0000D17F E8C500                  		call	newLine
   218 0000D182 E919FF                  		jmp 	Mainloop	
   219                                  ldIntelHex:		
   220 0000D185 E88F13                  		call 	load_intel_hex
   221 0000D188 E8BC00                  		call	newLine
   222 0000D18B E910FF                  		jmp 	Mainloop	
   223                                  writePeripherals:
   224 0000D18E E8DB14                  		call 	write_peripherals
   225 0000D191 E8B300                  		call	newLine
   226 0000D194 E907FF                  		jmp 	Mainloop	
   227                                  outByte:
   228 0000D197 E8F114                  		call 	outbyte
   229 0000D19A E8AA00                  		call	newLine
   230 0000D19D E9FEFE                  		jmp 	Mainloop	
   231                                  inByte:		
   232 0000D1A0 E81015                  		call	inbyte
   233 0000D1A3 E8A100                  		call	newLine
   234 0000D1A6 E9F5FE                  		jmp 	Mainloop	
   235                                  show_reg:
   236 0000D1A9 B83412                  		mov	AX, 0x1234
   237 0000D1AC E85810                  		call	print_hex
   238 0000D1AF E89500                  		call	newLine
   239 0000D1B2 E9E9FE                  		jmp 	Mainloop		
   240                                  show_dump:
   241 0000D1B5 E85D12                  		call	dump
   242 0000D1B8 E88C00                  		call	newLine
   243 0000D1BB E9E0FE                  		jmp 	Mainloop	
   244                                  editmemory:			
   245 0000D1BE E80413                  		call	edit_memory
   246 0000D1C1 E88300                  		call	newLine
   247 0000D1C4 E9D7FE                  		jmp 	Mainloop	
   248                                  show_systic:
   249 0000D1C7 E88411                  		call    get_sys_ticks
   250 0000D1CA 50                      		push	AX
   251 0000D1CB 89D0                    		mov		AX, DX
   252 0000D1CD E83710                  		call	print_hex
   253 0000D1D0 58                      		pop		AX
   254 0000D1D1 E83310                  		call	print_hex
   255 0000D1D4 E87000                  		call	newLine
   256 0000D1D7 E9C4FE                  		jmp 	Mainloop		
   257                                  show_help_msg:
   258 0000D1DA BE[E000]                		mov		si, help_msg
   259 0000D1DD E89D00                  		call 	pstr
   260 0000D1E0 E9BBFE                  		jmp 	Mainloop
   261                                  
   262                                  
   263                                  %include "DRV16C550.asm"
     1                              <1>         CPU 8086
     2                              <1>    
     3                              <1> 
     4                              <1> ; Port
     5 0000D1E3 F803                <1> COM1:	DW		0x3F8
     6                              <1> ; Here are the port numbers for various UART registers:
     7                              <1> uart_tx_rx 		EQU  0x3f8 ; 0 DLAB = 0 for Regs. TX and RX
     8                              <1> uart_DLL 		EQU  0x3f8 ; 0 DLAB = 1 Divisor lacth low
     9                              <1> uart_IER 		EQU  0x3f9 ; 1 DLAB = 0 Interrupt Enable Register
    10                              <1> uart_DLH 		EQU  0x3f9 ; 1 DLAB = 1 Divisor lacth high
    11                              <1> uart_ISR 		EQU  0x3fa ; 2 IIR Interrupt Ident. Register READ ONLY
    12                              <1> uart_FCR 		EQU  0x3fa ; 2 Fifo Control Resgister WRITE ONLY
    13                              <1> uart_LCR 		EQU  0x3fb ; 3 Line Control Register
    14                              <1> uart_MCR 		EQU  0x3fc ; 4 Modem Control Register
    15                              <1> uart_LSR 		EQU  0x3fd ; 5 Line Status Register
    16                              <1> uart_MSR 		EQU  0x3fe ; 6 Modem Status Register
    17                              <1> uart_scratch 	EQU  0x3ff ; 7 SCR Scratch Register
    18                              <1> 
    19                              <1> UART_FREQUENCY		equ 4915000
    20                              <1> ;Fomula UART_FREQUENCY/(  9600 * 16)
    21                              <1> ;Baudrates
    22                              <1> UART_BAUD_9600		EQU 32
    23                              <1> UART_BAUD_19200		EQU 16
    24                              <1> UART_BAUD_38400		EQU  8
    25                              <1> UART_BAUD_56800		EQU  5
    26                              <1> UART_BAUD_115200	EQU  3
    27                              <1> UART_BAUD_230400	EQU  1
    28                              <1> 
    29                              <1> UART_TX_WAIT		EQU	0x7fff		; Count before a TX times out
    30                              <1> 
    31 0000D1E5 53657269616C206472- <1> msg0_01:   db "Serial driver for 16C550",0
    31 0000D1EE 6976657220666F7220- <1>
    31 0000D1F7 31364335353000      <1>
    32                              <1> ;configure_uart
    33                              <1> ;Parameters:None
    34                              <1> ;			
    35                              <1> ;			
    36                              <1> configure_uart:
    37 0000D1FE B9FF1F              <1> 			mov cx, 0x1fff
    38 0000D201 E85000              <1> 			call	basicDelay
    39 0000D204 B000                <1> 			MOV		AL,0x0	 		;
    40 0000D206 BAF903              <1> 			MOV		DX, uart_IER
    41 0000D209 EE                  <1> 			OUT  	DX,	AL	; Disable interrupts
    42                              <1> 
    43 0000D20A B91F00              <1> 			mov cx, 0x1f
    44 0000D20D E84400              <1> 			call	basicDelay
    45                              <1> 
    46 0000D210 B080                <1> 			MOV		AL, 0x80			;
    47 0000D212 BAFB03              <1> 			MOV		DX, uart_LCR
    48 0000D215 EE                  <1> 			OUT     DX,	AL 	; Turn DLAB on
    49 0000D216 B91F00              <1> 			mov cx, 0x1f
    50 0000D219 E83800              <1> 			call	basicDelay
    51                              <1> 
    52 0000D21C B008                <1> 			MOV		AL, UART_BAUD_38400 ;0x08
    53 0000D21E BAF803              <1> 			MOV		DX, uart_DLL
    54 0000D221 EE                  <1> 			OUT     DX,   AL	; Set divisor low
    55 0000D222 B91F00              <1> 			mov cx, 0x1f
    56 0000D225 E82C00              <1> 			call	basicDelay
    57                              <1> 
    58 0000D228 B000                <1> 			MOV		AL, 0x00		;
    59 0000D22A BAF903              <1> 			MOV		DX, uart_DLH
    60 0000D22D EE                  <1> 			OUT     DX,	AL	; Set divisor high
    61 0000D22E B91F00              <1> 			mov cx, 0x1f
    62 0000D231 E82000              <1> 			call	basicDelay
    63                              <1> 
    64 0000D234 B003                <1> 			MOV     AL, 0x03	; AH	
    65 0000D236 BAFB03              <1> 			MOV		DX, uart_LCR
    66 0000D239 EE                  <1> 			OUT     DX,	AL	; Write out flow control bits 8,1,N
    67 0000D23A B91F00              <1> 			mov cx, 0x1f
    68 0000D23D E81400              <1> 			call	basicDelay
    69                              <1> 
    70 0000D240 B081                <1> 			MOV 	AL,0x81			;
    71 0000D242 BAFA03              <1> 			MOV		DX, uart_ISR
    72 0000D245 EE                  <1> 			OUT     DX,	AL	; Turn on FIFO, with trigger level of 8.
    73                              <1> 								                ; This turn on the 16bytes buffer!
    74 0000D246 C3                  <1> 			RET
    75                              <1> 
    76                              <1> newLine:
    77 0000D247 50                  <1> 	push	AX
    78 0000D248 B00D                <1> 	mov  al, 0Dh
    79 0000D24A E85100              <1> 	call cout
    80 0000D24D B00A                <1> 	mov  al, 0Ah
    81 0000D24F E84C00              <1> 	call cout
    82 0000D252 58                  <1> 	pop		AX
    83 0000D253 C3                  <1> 	ret
    84                              <1> 	
    85                              <1> basicDelay:
    86 0000D254 49                  <1>         dec cx
    87 0000D255 75FD                <1>         jnz basicDelay
    88 0000D257 C3                  <1>         ret
    89                              <1> 
    90                              <1> readLine:
    91 0000D258 57                  <1> 		push	DI
    92 0000D259 52                  <1> 		push	DX
    93 0000D25A 51                  <1> 		push	CX
    94 0000D25B BF0F05              <1>         mov  	DI,  buff_read   
    95 0000D25E B100                <1> 		mov		cl, 0x0
    96                              <1> .loopP:  ;RX blocante
    97 0000D260 E85900              <1>         call 	cin_blct    
    98                              <1> 		;call	printb_hex   
    99 0000D263 3C08                <1> 		cmp 	al, 0x08
   100 0000D265 7411                <1> 		je 		.loopP1
   101 0000D267 AA                  <1> 		stosb
   102 0000D268 FEC1                <1> 		inc		cl
   103 0000D26A E83100              <1>         call 	cout
   104 0000D26D 3C0D                <1>         CMP  	AL, cr
   105 0000D26F 75EF                <1>         JNZ  	.loopP
   106 0000D271 B000                <1> 		mov  	al,0x0
   107 0000D273 AA                  <1> 		stosb
   108 0000D274 59                  <1> 		pop 	CX
   109 0000D275 5A                  <1> 		pop		DX
   110 0000D276 5F                  <1> 		pop 	DI
   111 0000D277 C3                  <1>         ret
   112                              <1> .loopP1:		     
   113                              <1> 		;call	printb_hex   
   114 0000D278 FEC9                <1> 		dec		cl
   115 0000D27A 4F                  <1> 		dec		DI
   116 0000D27B EBE3                <1> 		jmp 	.loopP
   117                              <1> 
   118                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   119                              <1> ;Mais funções
   120                              <1> ; send string to terminal
   121                              <1> ; entry: si
   122                              <1> 
   123                              <1> eos	equ 0
   124                              <1> cr	equ 13
   125                              <1> lf	equ 10
   126                              <1> 
   127                              <1> pstr:   
   128 0000D27D 2E8A04              <1> 		mov al,cs:[si]
   129 0000D280 3C00                <1> 		cmp al,eos
   130 0000D282 7501                <1> 		jnz .pstr1
   131 0000D284 C3                  <1> 		ret
   132                              <1> .pstr1:
   133 0000D285 E81600              <1> 		call cout
   134 0000D288 46                  <1> 		inc si
   135 0000D289 EBF2                <1> 		jmp pstr
   136                              <1> 
   137                              <1> pstr_sram:
   138 0000D28B B80000              <1> 		mov ax, 0x0
   139 0000D28E 8EC0                <1>         mov ES, AX 
   140                              <1> .cont:		
   141 0000D290 268A04              <1> 		mov al,es:[si]
   142 0000D293 3C00                <1> 		cmp al,eos
   143 0000D295 7501                <1> 		jnz .pstr2
   144 0000D297 C3                  <1> 		ret
   145                              <1> .pstr2:
   146 0000D298 E80300              <1> 		call cout
   147 0000D29B 46                  <1> 		inc si
   148 0000D29C EBF2                <1> 		jmp .cont
   149                              <1> 
   150                              <1> ;=================================================================================
   151                              <1> ;cout
   152                              <1> ; send 8-bit character in al to terminal
   153                              <1> ; entry: al
   154                              <1> cout:
   155 0000D29E 50                  <1> 		push 		ax
   156 0000D29F BAFD03              <1> 		mov 		dx,	uart_LSR
   157                              <1> cout1:	
   158 0000D2A2 EC                  <1> 		in  al,		dx
   159 0000D2A3 2460                <1> 		and al, 	0x60	; Check for TX empty
   160 0000D2A5 74FB                <1> 		jz 	cout1			; wait until TXE = 1
   161 0000D2A7 58                  <1> 		pop ax
   162 0000D2A8 BAF803              <1> 		mov dx,		uart_tx_rx
   163 0000D2AB EE                  <1> 		out dx,		al
   164 0000D2AC C3                  <1> 		ret
   165                              <1> ;=================================================================================
   166                              <1> ;cin:
   167                              <1> ;Parameters: 
   168                              <1> ;			AL = return the available character
   169                              <1> ;			If al returns with a valid char flag carry is set, otherwise
   170                              <1> ;			flag carry is clear
   171                              <1> cin:	
   172 0000D2AD BAFD03              <1> 			MOV DX, uart_LSR
   173 0000D2B0 EC                  <1> 			IN	AL, DX	 		; Get the line status register
   174 0000D2B1 2401                <1> 			AND AL, 0x01		; Check for characters in buffer
   175 0000D2B3 F8                  <1> 			CLC 				; Clear carry
   176 0000D2B4 7405                <1> 			JZ	.end			; Just ret (with carry clear) if no characters
   177 0000D2B6 BAF803              <1> 			MOV DX, uart_tx_rx
   178 0000D2B9 EC                  <1> 			IN	AL, DX			; Read the character from the UART receive buffer
   179 0000D2BA F9                  <1> 			STC 				; Set the carry flag
   180                              <1> .end:			
   181 0000D2BB C3                  <1> 			RET
   182                              <1> 
   183                              <1> cin_blct:	
   184 0000D2BC BAFD03              <1> 			MOV DX, uart_LSR
   185 0000D2BF EC                  <1> 			IN	AL, DX	 		; Get the line status register
   186 0000D2C0 2401                <1> 			AND AL, 0x01		; Check for characters in buffer
   187 0000D2C2 74F8                <1> 			JZ	cin_blct		; Just loopif no characters
   188 0000D2C4 BAF803              <1> 			MOV DX, uart_tx_rx
   189 0000D2C7 EC                  <1> 			IN	AL, DX			; Read the character from the UART receive buffer
   190 0000D2C8 C3                  <1> 			RET
   191                              <1> 
   192                              <1> space:  
   193 0000D2C9 B020                <1> 			mov al," "
   194 0000D2CB E8D0FF              <1> 	    	call cout
   195 0000D2CE C3                  <1> 	    	ret
   196                              <1> 
   197                              <1> get_hex: 
   198 0000D2CF E8DBFF              <1> 		call cin
   199 0000D2D2 E81410              <1> 		call to_hex
   200 0000D2D5 D0C0                <1> 		rol al,1
   201 0000D2D7 D0C0                <1> 		rol al,1
   202 0000D2D9 D0C0                <1> 		rol al,1
   203 0000D2DB D0C0                <1> 		rol al,1
   204 0000D2DD 88C4                <1> 		mov ah,al
   205 0000D2DF E8CBFF              <1> 		call cin
   206 0000D2E2 E80410              <1> 		call to_hex
   207 0000D2E5 00E0                <1> 		add al, ah
   208 0000D2E7 C3                  <1> 		ret			
   264                                  %include "DRVCH376S.asm"
     1                              <1> 
     2                              <1> 
     3                              <1> 
     4                              <1> ;;INITIALIZE_CH376S_0XE0_00:
     5                              <1> ;;	MOV AL, 0X05 		;COMMAND RESET
     6                              <1> ;;	OUT 0XE4, AL		;OUT COMMAND PORT
     7                              <1> ;;	
     8                              <1> ;;	CALL WAIT_32
     9                              <1> ;;  	
    10                              <1> ;;	MOV AL, 0X15 		;SET_USB_MODE
    11                              <1> ;;	OUT 0XE4, AL		;OUT COMMAND PORT
    12                              <1> ;;	MOV AL, 0X06		;MODE 0X06
    13                              <1> ;;	OUT 0XE0, AL		;OUT DATA PORT
    14                              <1> ;;	CALL WAIT_16		;DELAY TO GIVE IT TIME
    15                              <1> ;;	MOV AL, 0X31		;DISK_MOUNT
    16                              <1> ;;	OUT 0XE4, AL		;OUT COMMAND PORT
    17                              <1> ;;	CALL WAIT_16		;DELAY TO GIVE IT TIME
    18                              <1> ;;
    19                              <1> ;;	;CALL LOAD_BOOT_RECORD		;LOADS MBR CHECKS FOR BOOTABLE
    20                              <1> ;;                                ;THEN LOADS VOLUME BOOT RECORD CHECKS FOR BOOTABLE
    21                              <1> ;;				                ;DISK GEOMETRY IS USED IN OTHER 0X13 OPERATIONS
    22                              <1> ;;		
    23                              <1> ;;	CALL WAIT_16		;DELAY TO GIVE IT TIME
    24                              <1> ;;	MOV AX, 0X0E41
    25                              <1> ;;	RET			        ;RETURN
    26                              <1> 
    27                              <1> 
    28                              <1> ; Conservatively assume the 504M limit
    29                              <1> ; It may be possible to use MAX_HPC of 256 and get an 8Gb limit, but it's likely this will
    30                              <1> ; require device repartition/reformat if it was set up with a 504M geometry.
    31                              <1> 
    32                              <1> MAX_SPT equ 63
    33                              <1> MAX_HPC equ 16
    34                              <1> MAX_CYL equ 1024
    35                              <1> 
    36                              <1> ; Set to 1 if you want the CH376S errors dumped to the screen.
    37                              <1> %define DISPLAY_CH376S_ERRORS 0
    38                              <1> 
    39                              <1> ; Define the port numbers for easier swap if it ever supports the CH376S loaded elsewhere (i. e. two units)
    40                              <1> COMMAND_PORT equ 0xE4
    41                              <1> DATA_PORT equ 0xE0
    42                              <1> 
    43                              <1> ; And ROM sector if we want to load it higher.  Right now, it fits into a 4k box so it can theoretically go as high
    44                              <1> ; as 0xFD000 and still clear the main BIOS at 0xFE00
    45                              <1> 
    46                              <1> ROM_SECTOR equ 0xF000
    47                              <1> 
    48                              <1> ; Define CH376S commands by name for improved legibility
    49                              <1> CH376S_GET_IC_VER equ		0x01
    50                              <1> CH376S_RESET_ALL equ 		0x05
    51                              <1> CH376S_CHECK_EXIST equ 		0x06
    52                              <1> CH376S_SET_USB_MODE equ 	0x15
    53                              <1> CH376S_GET_STATUS equ 		0x22
    54                              <1> CH376S_RD_USB_DATA0 equ		0x27
    55                              <1> CH376S_WR_USB_DATA	equ		0x2C
    56                              <1> CH376S_WR_REQ_DATA	equ		0x2D
    57                              <1> CH376S_DISK_CONNECT equ		0x30
    58                              <1> CH376S_DISK_MOUNT equ		0x31
    59                              <1> CH376S_DISK_CAPACITY equ	0x3E
    60                              <1> CH376S_DISK_READ equ		0x54
    61                              <1> CH376S_DISK_RD_GO equ		0x55
    62                              <1> CH376S_DISK_WRITE equ		0x56
    63                              <1> CH376S_DISK_WR_GO equ		0x57
    64                              <1> 
    65                              <1> 
    66                              <1> CH376S_USB_INT_SUCCESS equ  	0x14
    67                              <1> CH376S_USB_INT_DISCONNECT equ	0x16
    68                              <1> CH376S_USB_INT_BUF_OVER equ		0x17
    69                              <1> CH376S_USB_INT_DISK_READ equ	0x1D
    70                              <1> CH376S_USB_INT_DISK_WRITE equ	0x1E
    71                              <1> CH376S_USB_INT_DISK_ERR equ 	0x1F
    72                              <1> 
    73                              <1> CH376S_CMD_RET_SUCCESS equ  	0x51
    74                              <1> 
    75                              <1> 
    76                              <1> ;Header so it's recognized as an option card
    77                              <1> 
    78 0000D2E8 55                  <1> DB 0x55
    79 0000D2E9 AA                  <1> DB 0xAA
    80                              <1> 
    81                              <1> ; Uses 8 512-byte pages.  Expand if this grows over 4kb.
    82 0000D2EA 08                  <1> DB 0x08
    83                              <1> 
    84                              <1> ; Code starts here.  Save everything before we start.
    85                              <1> 
    86                              <1> INITIALIZE_CH376S_0XE0:
    87                              <1> 
    88 0000D2EB 9C                  <1> PUSHF
    89 0000D2EC 50                  <1> PUSH AX
    90 0000D2ED 53                  <1> PUSH BX
    91 0000D2EE 51                  <1> PUSH CX
    92 0000D2EF 52                  <1> PUSH DX
    93                              <1> 
    94 0000D2F0 B95200              <1> 	MOV CX, END_CHECKPOINT_1 - CHECKPOINT_1
    95 0000D2F3 BB[58D5]            <1>     MOV BX, CHECKPOINT_1
    96 0000D2F6 E80003              <1>     CALL WRITE_MESSAGE;
    97                              <1> 
    98 0000D2F9 BAC800              <1> 	MOV DX, 200			; Try to reset the thing 200 times
    99                              <1> TRY_RESET:
   100 0000D2FC B005                <1> 	MOV AL, CH376S_RESET_ALL 		;COMMAND RESET
   101 0000D2FE E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   102                              <1> 									; It seems like using a longer delay like WAIT_16 is
   103                              <1> 									; actually less reliable for some reason than
   104                              <1> 									; this small delay
   105 0000D300 E83A26              <1> 	CALL WAIT_2
   106 0000D303 E4E0                <1> 	IN AL, DATA_PORT				; Docs say this should be 00 after reset.
   107 0000D305 B006                <1> 	MOV AL, CH376S_CHECK_EXIST
   108 0000D307 E6E4                <1> 	OUT COMMAND_PORT, AL
   109 0000D309 B057                <1> 	MOV AL, 0X57					; Existence check:  Send 0x57, expect 0xA8 back
   110 0000D30B E6E0                <1> 	OUT DATA_PORT, AL
   111 0000D30D E4E0                <1> 	IN AL, DATA_PORT
   112 0000D30F 3CA8                <1> 	CMP AL, 0xA8
   113 0000D311 7410                <1> 	JE CH376S_EXISTS
   114 0000D313 4A                  <1> 	DEC DX
   115 0000D314 83FA00              <1> 	CMP DX, 0
   116 0000D317 7503E96801          <1> 	JE CH376S_EXIST_FAILED
   117 0000D31C B82E0E              <1> 	MOV AX, 0x0E2E		; Add a period for the display
   118 0000D31F CD10                <1> 	INT 0x10
   119 0000D321 EBD9                <1> 	JMP TRY_RESET
   120                              <1> 
   121                              <1> CH376S_EXISTS:
   122 0000D323 B91600              <1> 	mov cx, END_MODE_SET_TEXT - MODE_SET_TEXT
   123 0000D326 BB[AAD5]            <1>     mov BX, MODE_SET_TEXT
   124 0000D329 E8CD02              <1>     call WRITE_MESSAGE;
   125                              <1> 
   126 0000D32C BA1400              <1> 	MOV DX, 0020
   127                              <1> CH376S_MODE_SET:
   128                              <1> 	;Set the mode to 0x07 first (valid USB host/reset USB)
   129                              <1> 	;then to 0x06 (valid USB host, auto generate SOF packet)
   130                              <1> 
   131 0000D32F B015                <1>     MOV AL, CH376S_SET_USB_MODE 	; SET_USB_MODE
   132 0000D331 E6E4                <1> 	OUT COMMAND_PORT, AL			; OUT COMMAND PORT
   133 0000D333 B007                <1>     MOV AL, 0X07					; MODE 0X07
   134 0000D335 E6E0                <1> 	OUT DATA_PORT, AL				; OUT DATA PORT
   135 0000D337 E81026              <1> 	CALL WAIT_8						; DELAY TO GIVE IT TIME
   136                              <1> 	
   137 0000D33A B015                <1>     MOV AL, CH376S_SET_USB_MODE		; SET_USB_MODE
   138 0000D33C E6E4                <1> 	OUT COMMAND_PORT, AL			; OUT COMMAND PORT
   139 0000D33E B006                <1>     MOV AL, 0X06					; MODE 0X06
   140 0000D340 E6E0                <1> 	OUT DATA_PORT, AL				; OUT DATA PORT
   141 0000D342 E80526              <1> 	CALL WAIT_8						; DELAY TO GIVE IT TIME
   142                              <1> 
   143 0000D345 E4E0                <1> 	IN AL, DATA_PORT
   144 0000D347 3C51                <1> 	CMP AL, CH376S_CMD_RET_SUCCESS	; Once we have success, move on
   145 0000D349 7410                <1> 	JE CH376S_RIGHT_MODE
   146 0000D34B 4A                  <1> 	DEC DX
   147 0000D34C 83FA00              <1> 	CMP DX, 0
   148 0000D34F 7503E93B01          <1> 	JE CH376S_WRONG_MODE
   149 0000D354 B82E0E              <1> 	MOV AX, 0x0E2E					; Add a period for the display
   150 0000D357 CD10                <1> 	INT 0x10
   151 0000D359 EBD4                <1> 	JMP CH376S_MODE_SET
   152                              <1> 
   153                              <1> CH376S_RIGHT_MODE:
   154                              <1> 	; DEBUG - print IC version
   155 0000D35B B91000              <1>     MOV CX, END_REVINFO - REVINFO
   156 0000D35E BB[C0D5]            <1>     MOV BX, REVINFO
   157 0000D361 E89502              <1>     CALL WRITE_MESSAGE;
   158                              <1> 
   159 0000D364 B001                <1>     MOV AL, CH376S_GET_IC_VER	;GET IC Version
   160 0000D366 E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   161 0000D368 E4E0                <1> 	IN AL, DATA_PORT			;READ IN STATUS DATA PORT
   162 0000D36A E89325              <1>     CALL WRITE_AL_INT10_E;
   163                              <1> 
   164                              <1> 	
   165 0000D36D B90000              <1> 	MOV CX, 0
   166                              <1> TRY_CONNECT:
   167                              <1> 	; Some comments suggested doing DISK_CONNECT then DISK_MOUNT
   168 0000D370 83F90A              <1> 	CMP CX, 10
   169 0000D373 7D15                <1> 	JGE TRY_MOUNT ; GIVE UP
   170 0000D375 B030                <1>     MOV AL, CH376S_DISK_CONNECT	;DISK_CONNECT
   171 0000D377 E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   172                              <1> 
   173 0000D379 E81907              <1> 	CALL AWAIT_INTERRUPT
   174                              <1> 
   175 0000D37C B022                <1> 	MOV AL, CH376S_GET_STATUS		;GET_STATUS AFTER INTERRUPT
   176 0000D37E E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT				
   177 0000D380 E4E0                <1> 	IN AL, DATA_PORT				;READ IN STATUS DATA PORT
   178 0000D382 41                  <1> 	INC CX
   179 0000D383 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS  ;CHECK FOR USB_INT_SUCCESS
   180 0000D385 75E9                <1> 	JNE TRY_CONNECT
   181                              <1> 
   182 0000D387 B90000              <1> 	MOV CX, 0
   183                              <1> TRY_MOUNT:
   184 0000D38A 83F90A              <1> 	CMP CX, 10
   185 0000D38D 7D15                <1> 	JGE MOUNT_FINISHED				;GIVE UP IF WE TRIED 10 TIMES
   186 0000D38F B031                <1>     MOV AL, CH376S_DISK_MOUNT		;DISK_MOUNT
   187 0000D391 E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   188                              <1> 
   189                              <1> AWAIT_MOUNT:
   190 0000D393 E4E4                <1> 	IN AL, COMMAND_PORT				; Loop waiting for the interrupt
   191 0000D395 2480                <1> 	AND AL, 0x80
   192 0000D397 75FA                <1> 	JNZ AWAIT_MOUNT
   193 0000D399 B022                <1> 	MOV AL, CH376S_GET_STATUS		;GET_STATUS AFTER INTERRUPT
   194 0000D39B E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT				
   195 0000D39D E4E0                <1> 	IN AL, DATA_PORT				;READ IN STATUS DATA PORT
   196 0000D39F 41                  <1> 	INC CX
   197 0000D3A0 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS	;CHECK FOR USB_INT_SUCCESS
   198 0000D3A2 75E6                <1> 	JNE TRY_MOUNT
   199                              <1> 
   200                              <1> MOUNT_FINISHED:
   201                              <1> 	; After the mount operation, the data port is stuffed with the device name.  
   202                              <1> 	; Let's show it so we have proof we're talking to the right drive
   203 0000D3A4 B027                <1>     MOV AL, CH376S_RD_USB_DATA0		; Read device data
   204 0000D3A6 E6E4                <1>     OUT COMMAND_PORT, AL
   205 0000D3A8 E4E0                <1>     IN AL, DATA_PORT				; READ IN STATUS DATA PORT
   206 0000D3AA 88C3                <1>     MOV BL, AL						; The first byte is length of the name
   207                              <1> 
   208 0000D3AC 3C00                <1> 	CMP AL, 0
   209 0000D3AE 7503E9C600          <1> 	JE NO_DISC_FOUND
   210 0000D3B3 3CE8                <1> 	CMP AL, 0xE8 					; When it doesn't wake up right,
   211 0000D3B5 7503E9BF00          <1> 	JE NO_DISC_FOUND				; it often returns E8 constantly
   212                              <1> 
   213                              <1> 	
   214                              <1> 	; Print the "Device ID" string
   215 0000D3BA 53                  <1> 	PUSH BX
   216 0000D3BB B90E00              <1>     MOV CX, END_DEVINFO - DEVINFO
   217 0000D3BE BB[D0D5]            <1> 	MOV BX, DEVINFO
   218 0000D3C1 E83502              <1>     call WRITE_MESSAGE;			
   219 0000D3C4 5B                  <1> 	POP BX
   220                              <1> 	
   221 0000D3C5 80EB08              <1> 	SUB BL, 8			; The first 8 characters of the response struct
   222 0000D3C8 B90800              <1> 	MOV CX, 8			; are not human readable.  Skip to vendor/product/Revision
   223                              <1> SKIP_HEADER:			
   224 0000D3CB E4E0                <1> 	IN AL, DATA_PORT
   225 0000D3CD E2FC                <1> 	LOOP SKIP_HEADER
   226                              <1> 
   227 0000D3CF B40E                <1>     MOV AH, 0x0E		; INT 0x10 operation for writing character
   228                              <1> NEXT_ID_CHAR:
   229 0000D3D1 80FB00              <1>     CMP BL, 0
   230 0000D3D4 7408                <1>     JE AFTER_IDENT
   231 0000D3D6 E4E0                <1>     IN AL, DATA_PORT	;Read and print BL-count characters
   232 0000D3D8 CD10                <1>     INT 0x10
   233 0000D3DA FECB                <1>     DEC BL
   234 0000D3DC EBF3                <1>     JMP NEXT_ID_CHAR
   235                              <1>     AFTER_IDENT:
   236                              <1> 
   237 0000D3DE B8200E              <1> 	MOV AX, 0x0E20		; Write space
   238 0000D3E1 CD10                <1> 	INT 0x10
   239 0000D3E3 B03A                <1> 	MOV AL, 0x3A		; Write colon
   240 0000D3E5 CD10                <1> 	INT 0x10
   241 0000D3E7 B020                <1> 	MOV AL, 0x20		; Write space
   242 0000D3E9 CD10                <1> 	INT 0x10
   243                              <1> 
   244 0000D3EB E8DE06              <1>  	CALL GET_CAPACITY
   245                              <1> 
   246                              <1> 
   247 0000D3EE E89005              <1> 	CALL WRITE_SECTORS_IN_MB		; Display size on screen
   248                              <1> 
   249                              <1> 	; Check if we're above the maximum size for the BIOS
   250 0000D3F1 83FA0F              <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   251 0000D3F4 7C13                <1> 	JL BELOW_SIZE
   252 0000D3F6 83FA0F              <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   253 0000D3F9 7F05                <1> 	JG ABOVE_SIZE
   254 0000D3FB 3D00C0              <1> 	CMP AX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   255 0000D3FE 7E09                <1> 	JLE BELOW_SIZE
   256                              <1> 
   257                              <1> ABOVE_SIZE:
   258 0000D400 B94A00              <1> 	MOV CX, END_OVERSIZE_MESSAGE - OVERSIZE_MESSAGE
   259 0000D403 BB[01DA]            <1>     MOV BX, OVERSIZE_MESSAGE
   260 0000D406 E8F001              <1>     CALL WRITE_MESSAGE;
   261                              <1> 
   262                              <1> BELOW_SIZE:
   263                              <1> 	; If we have a device that's smaller than the dimensions in the disk table
   264                              <1> 	; we should warn the user to update the table.
   265                              <1> 	; or some detection software may assume the wrong dimensions.
   266 0000D409 B9F003              <1> 	MOV CX, (MAX_SPT * MAX_HPC)
   267 0000D40C F7F1                <1> 	DIV CX
   268 0000D40E 2E3B06[16DD]        <1> 	CMP AX, [CS:DISK_1_TABLE]
   269 0000D413 7D13                <1> 	JGE BELOW_TABLE_SIZE
   270                              <1> 
   271 0000D415 B94A00              <1> 	MOV CX, END_BELOW_TABLE_SIZE_MESSAGE - BELOW_TABLE_SIZE_MESSAGE
   272 0000D418 BB[4BDA]            <1>     MOV BX, BELOW_TABLE_SIZE_MESSAGE
   273 0000D41B E8DB01              <1> 	CALL WRITE_MESSAGE
   274                              <1> 
   275 0000D41E 50                  <1> 	PUSH AX
   276 0000D41F 88E0                <1> 	MOV AL, AH
   277 0000D421 E8DC24              <1> 	CALL WRITE_AL_INT10_E
   278 0000D424 58                  <1> 	POP AX
   279 0000D425 E8D824              <1> 	CALL WRITE_AL_INT10_E
   280                              <1> 
   281                              <1> BELOW_TABLE_SIZE:
   282                              <1> 
   283                              <1> 	; Beginning the final initialization steps.  Start with a message...
   284                              <1> 
   285 0000D428 B91B00              <1>     MOV CX, END_RETURNING_TEXT - RETURNING_TEXT
   286 0000D42B BB[DED5]            <1>     MOV BX, RETURNING_TEXT
   287 0000D42E E8C801              <1>     CALL WRITE_MESSAGE;
   288                              <1>     
   289                              <1> 
   290                              <1> 	; Set the interrupt vector at 0x004C to point to the INT13 code below.
   291 0000D431 1E                  <1>     PUSH DS
   292 0000D432 50                  <1>     PUSH AX	
   293 0000D433 31C0                <1> 	XOR AX, AX
   294 0000D435 8ED8                <1>     MOV DS, AX
   295                              <1> 	; Vector migration logic based on examples at https://www.bttr-software.de/forum/board_entry.php?id=11433
   296                              <1> 	; Save old vector to INT 0x40 - this is reported as where old BIOSes really moved INT 0x13 to.
   297 0000D437 3EA14C00            <1> 	MOV AX, DS:0x004C
   298 0000D43B 3EA30001            <1> 	MOV DS:0x0100, AX
   299 0000D43F 3EA14E00            <1> 	MOV AX, DS:0x004E
   300 0000D443 3EA30201            <1> 	MOV DS:0x0102, AX
   301                              <1> 	
   302                              <1> 	; write our new vector into place
   303 0000D447 3EC7064C00[0AD6]    <1>     MOV WORD DS:0x004C, INT13
   304 0000D44E 3EC7064E0000F0      <1>     MOV WORD DS:0x004E, ROM_SECTOR
   305                              <1> 
   306                              <1> 	; write the drive data table to INT 0x41 and 0x46
   307 0000D455 3EC7060401[16DD]    <1> 	MOV WORD DS:0x0104, DISK_1_TABLE
   308 0000D45C 3EC706060100F0      <1> 	MOV WORD DS:0x0106, ROM_SECTOR
   309 0000D463 3EC7061801[26DD]    <1> 	MOV WORD DS:0x0118, DISK_2_TABLE
   310 0000D46A 3EC706200100F0      <1> 	MOV WORD DS:0x0120, ROM_SECTOR
   311 0000D471 58                  <1> 	POP AX
   312 0000D472 1F                  <1>     POP DS
   313                              <1> 
   314                              <1> END_STARTUP:
   315 0000D473 5A                  <1>     POP DX
   316 0000D474 59                  <1>     POP CX
   317 0000D475 5B                  <1>     POP BX
   318 0000D476 58                  <1>     POP AX
   319 0000D477 9D                  <1>     POPF
   320                              <1> 	;RETF			;RETURN
   321 0000D478 C3                  <1>     RET
   322                              <1> 
   323                              <1> NO_DISC_FOUND:
   324 0000D479 B93400              <1> 	MOV CX, END_NO_DISC_MSG - NO_DISC_MSG
   325 0000D47C BB[A0D4]            <1>     MOV BX, NO_DISC_MSG
   326 0000D47F E87701              <1>     CALL WRITE_MESSAGE
   327 0000D482 EBEF                <1> 	JMP END_STARTUP
   328                              <1> 
   329                              <1> CH376S_EXIST_FAILED:
   330 0000D484 B94A00              <1> 	MOV CX, END_NO_CH376S_MSG - NO_CH376S_MSG
   331 0000D487 BB[D4D4]            <1>     MOV BX, NO_CH376S_MSG
   332 0000D48A E86C01              <1>     CALL WRITE_MESSAGE
   333 0000D48D EBE4                <1> 	JMP END_STARTUP
   334                              <1> 
   335                              <1> CH376S_WRONG_MODE:
   336 0000D48F E85E06              <1> 	CALL END_OF_LINE
   337 0000D492 E86B24              <1> 	CALL WRITE_AL_INT10_E ; Display actual responde code
   338 0000D495 B93A00              <1> 	MOV CX, END_WRONG_MODE_MSG - WRONG_MODE_MSG
   339 0000D498 BB[1ED5]            <1>     MOV BX, WRONG_MODE_MSG
   340 0000D49B E85B01              <1>     CALL WRITE_MESSAGE
   341 0000D49E EBD3                <1> 	JMP END_STARTUP
   342                              <1> 
   343                              <1> NO_DISC_MSG:
   344 0000D4A0 0D0A4E6F2064726976- <1> 	DB 0x0D, 0x0A, 'No drive reported by module.  Skipping install.', 0x0D, 0x0A ,0
   344 0000D4A9 65207265706F727465- <1>
   344 0000D4B2 64206279206D6F6475- <1>
   344 0000D4BB 6C652E2020536B6970- <1>
   344 0000D4C4 70696E6720696E7374- <1>
   344 0000D4CD 616C6C2E0D0A00      <1>
   345                              <1> END_NO_DISC_MSG:
   346                              <1> 
   347                              <1> NO_CH376S_MSG:
   348 0000D4D4 0D0A43483337365320- <1> 	DB 0x0D, 0x0A, 'CH376S Module does not respond to existence check.  Skipping install.', 0x0D, 0x0A,0
   348 0000D4DD 4D6F64756C6520646F- <1>
   348 0000D4E6 6573206E6F74207265- <1>
   348 0000D4EF 73706F6E6420746F20- <1>
   348 0000D4F8 6578697374656E6365- <1>
   348 0000D501 20636865636B2E2020- <1>
   348 0000D50A 536B697070696E6720- <1>
   348 0000D513 696E7374616C6C2E0D- <1>
   348 0000D51C 0A00                <1>
   349                              <1> END_NO_CH376S_MSG:
   350                              <1> 
   351                              <1> WRONG_MODE_MSG:
   352 0000D51E 202D20434833373653- <1> 	DB ' - CH376S failed switching USB mode.  Skipping Install.', 0x0D, 0x0A,0
   352 0000D527 206661696C65642073- <1>
   352 0000D530 7769746368696E6720- <1>
   352 0000D539 555342206D6F64652E- <1>
   352 0000D542 2020536B697070696E- <1>
   352 0000D54B 6720496E7374616C6C- <1>
   352 0000D554 2E0D0A00            <1>
   353                              <1> END_WRONG_MODE_MSG:
   354                              <1> 
   355                              <1> CHECKPOINT_1:
   356 0000D558 5374616E64616C6F6E- <1>     DB 'Standalone CH376S Firmware v0.50 (8086 version) - 2021-11-20', 0x0D, 0x0A, 'Resetting Module...',0
   356 0000D561 652043483337365320- <1>
   356 0000D56A 4669726D7761726520- <1>
   356 0000D573 76302E353020283830- <1>
   356 0000D57C 38362076657273696F- <1>
   356 0000D585 6E29202D2032303231- <1>
   356 0000D58E 2D31312D32300D0A52- <1>
   356 0000D597 6573657474696E6720- <1>
   356 0000D5A0 4D6F64756C652E2E2E- <1>
   356 0000D5A9 00                  <1>
   357                              <1> END_CHECKPOINT_1:
   358                              <1> 
   359                              <1> MODE_SET_TEXT:
   360 0000D5AA 0D0A53657474696E67- <1>     DB 0x0D, 0x0A, 'Setting USB mode...',0
   360 0000D5B3 20555342206D6F6465- <1>
   360 0000D5BC 2E2E2E00            <1>
   361                              <1> END_MODE_SET_TEXT:
   362                              <1> 
   363                              <1> REVINFO:
   364 0000D5C0 0D0A49432052657669- <1> 	DB 0x0D, 0x0A, 'IC Revision: ',0
   364 0000D5C9 73696F6E3A2000      <1>
   365                              <1> END_REVINFO:
   366                              <1> 
   367                              <1> DEVINFO:
   368 0000D5D0 0D0A44657669636520- <1> 	DB 0x0D, 0x0A, 'Device ID: ',0
   368 0000D5D9 49443A2000          <1>
   369                              <1> END_DEVINFO:
   370                              <1> 
   371                              <1> RETURNING_TEXT:
   372 0000D5DE 0D0A52657475726E69- <1>     DB 0x0D, 0x0A, 'Returning to Main Exec', 0x0D, 0x0A,0
   372 0000D5E7 6E6720746F204D6169- <1>
   372 0000D5F0 6E20457865630D0A00  <1>
   373                              <1> END_RETURNING_TEXT:
   374                              <1> 
   375                              <1> 
   376                              <1> WRITE_MESSAGE:
   377 0000D5F9 50                  <1>     PUSH    AX
   378 0000D5FA B40E                <1>     MOV     AH, 0x0E
   379                              <1> .WRITE_LOOP:
   380 0000D5FC 8A07                <1>     MOV     AL, [BX]
   381 0000D5FE 3C00                <1>     cmp     al, 0x0 
   382 0000D600 7406                <1>     jz      .fim
   383                              <1>     ;INT 0x10
   384 0000D602 E899FC              <1>     call    cout
   385 0000D605 43                  <1>     INC     BX
   386 0000D606 E2F4                <1>     LOOP    .WRITE_LOOP
   387                              <1> .fim:    
   388 0000D608 58                  <1>     POP AX
   389 0000D609 C3                  <1>     RET
   390                              <1> 
   391                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   392                              <1> ;INT 0X13 SOFTWARE DISK INTERRUPTS
   393                              <1> ;DONT FORGET HARDWARE INTERRUPTS ARE DISABLED WHEN SOFTWARE INTERRUPTS ARE CALLED
   394                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   395                              <1> INT13:
   396 0000D60A 9C                  <1> 	PUSHF
   397 0000D60B 80FA81              <1> 	CMP     DL, 0x81		;CHECK FOR DISK NUMBER BEING REQUESTED 
   398 0000D60E 7405                <1> 	JE      .START_INT13		;JMP IF 0X80 C:
   399 0000D610 7403E94D03          <1> 	JNE     .NOT_A_DRIVE	;JMP IF NOT C: NOT A DRIVE IN THE SYSTEM
   400                              <1>   .START_INT13:	
   401 0000D615 9D                  <1> 	POPF				    ; we don't need the pushed flags, so discard them.
   402                              <1> 
   403                              <1> 
   404 0000D616 80FC00              <1> 	CMP AH, 0X00
   405 0000D619 7503E9A500          <1> 	JE .RESET_DISK_SYSTEM 			;RESET DISK
   406 0000D61E 80FC01              <1> 	CMP AH, 0X01
   407 0000D621 7503E9A300          <1> 	JE .GET_STATUS_LAST_OPERATION	;GET STATUS OF LAST OPERATION 
   408 0000D626 80FC02              <1> 	CMP AH, 0X02	
   409 0000D629 7503E9C900          <1> 	JE .DISK_READ					;READ DISK Sectors CHS
   410 0000D62E 80FC03              <1> 	CMP AH, 0X03
   411 0000D631 7503E95C01          <1> 	JE .WRITE_DISK					;WRITE DISK Sectors CHS
   412 0000D636 80FC05              <1> 	CMP AH, 0X05
   413 0000D639 7503E9EC01          <1> 	JE .FORMAT_TRACK				;Format disk track
   414 0000D63E 80FC08              <1> 	CMP AH, 0X08
   415 0000D641 7503E97102          <1> 	JE .PARAMETERS					;Get current drive parameters (XT & newer, see note Ø)
   416 0000D646 80FC0D              <1> 	CMP AH, 0X0D
   417 0000D649 7478                <1> 	JE .RESET_DISK_SYSTEM 			;RESET DISK
   418 0000D64B 80FC15              <1> 	CMP AH, 0X15
   419 0000D64E 7503E9BE02          <1> 	JE .GET_DISK_TYPE				;GET DISK TYPE
   420                              <1> 	;Not implemented
   421 0000D653 80FC04              <1> 	CMP AH, 0X04
   422 0000D656 7465                <1> 	JE .PLACEHOLDER_RETURN			;Verify disk sectors
   423 0000D658 80FC06              <1> 	CMP AH, 0X06
   424 0000D65B 7460                <1> 	JE .PLACEHOLDER_RETURN			;Format track and set bad sector flag (XT & portable)
   425 0000D65D 80FC07              <1> 	CMP AH, 0X07
   426 0000D660 745B                <1> 	JE .PLACEHOLDER_RETURN			;Format the drive starting at track (XT & portable)
   427 0000D662 80FC09              <1> 	CMP AH, 0X09					
   428 0000D665 7456                <1> 	JE .PLACEHOLDER_RETURN			;Initialize format to disk table
   429 0000D667 80FC0A              <1>     CMP AH, 0X0A
   430 0000D66A 7451                <1> 	JE .PLACEHOLDER_RETURN			;Read long sector (XT & newer, see note Ø)
   431 0000D66C 80FC0B              <1>     CMP AH, 0X0B
   432 0000D66F 744C                <1> 	JE .PLACEHOLDER_RETURN			;Write long sector (XT & newer, see note Ø)	
   433 0000D671 80FC0C              <1> 	CMP AH, 0X0C
   434 0000D674 7447                <1> 	JE .PLACEHOLDER_RETURN			;Seek to cylinder
   435 0000D676 80FC0D              <1> 	CMP AH, 0x0D
   436 0000D679 7442                <1> 	JE .PLACEHOLDER_RETURN			;Alternate disk reset (XT & newer, see note Ø)
   437 0000D67B 80FC0E              <1>     CMP AH, 0x0E
   438 0000D67E 743D                <1> 	JE .PLACEHOLDER_RETURN			;Read sector buffer (XT & portable only)
   439 0000D680 80FC0F              <1>     CMP AH, 0x0F
   440 0000D683 7438                <1> 	JE .PLACEHOLDER_RETURN			;Write sector buffer (XT & portable only)	
   441 0000D685 80FC10              <1> 	CMP AH, 0X10
   442 0000D688 7433                <1> 	JE .PLACEHOLDER_RETURN			;Test if ready
   443 0000D68A 80FC11              <1> 	CMP AH, 0X11
   444 0000D68D 742E                <1> 	JE .PLACEHOLDER_RETURN			;Calibrate Drive
   445 0000D68F 80FC12              <1> 	CMP AH, 0X12
   446 0000D692 7429                <1> 	JE .PLACEHOLDER_RETURN			;Controller Diagnostic
   447 0000D694 80FC13              <1> 	CMP AH, 0X13
   448 0000D697 7424                <1> 	JE .PLACEHOLDER_RETURN			;Drive Diagnostic
   449 0000D699 80FC14              <1> 	CMP AH, 0X14
   450 0000D69C 741F                <1> 	JE .PLACEHOLDER_RETURN			;Internal Diagnostic
   451 0000D69E 80FC16              <1> 	CMP AH, 0X16
   452 0000D6A1 741A                <1> 	JE .PLACEHOLDER_RETURN			;Disc change detection
   453 0000D6A3 80FC17              <1>     CMP AH, 0X17
   454 0000D6A6 7415                <1> 	JE .PLACEHOLDER_RETURN			;Set dasd type for format (XT BIOS from 1/10/86 & newer)
   455 0000D6A8 80FC18              <1>     CMP AH, 0X18
   456 0000D6AB 7410                <1> 	JE .PLACEHOLDER_RETURN			;Set media type for format (BIOS date specific)
   457 0000D6AD 80FC19              <1>     CMP AH, 0X19
   458 0000D6B0 740B                <1> 	JE .PLACEHOLDER_RETURN			;Park fixed disk heads (AT & newer)
   459 0000D6B2 80FC1A              <1>     CMP AH, 0X1A
   460 0000D6B5 7406                <1> 	JE .PLACEHOLDER_RETURN			;Format ESDI drive unit (PS/2 50+)
   461                              <1> 
   462                              <1> 									;FUNCTION NOT FOUND
   463 0000D6B7 B401                <1> 	MOV AH, 0X01					;INVALID FUNCTION IN AH
   464 0000D6B9 F9                  <1> 	STC								;SET CARRY FLAG 	
   465 0000D6BA E98E02              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   466                              <1> 
   467                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   468                              <1> ;PLACEHOLDER FOR FUNCTIONS THAT DON'T APPLY/WORK
   469                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
   470                              <1> .PLACEHOLDER_RETURN:	
   471 0000D6BD B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   472 0000D6BF F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   473 0000D6C0 E98802              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   474                              <1> 
   475                              <1> 
   476                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   477                              <1> ;RESET DISK 
   478                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
   479                              <1> .RESET_DISK_SYSTEM:	
   480 0000D6C3 B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   481 0000D6C5 F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   482 0000D6C6 E98202              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   483                              <1> 
   484                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   485                              <1> ;STATUS OF LAST OPERATION  
   486                              <1> ;THIS PROABLY WILL NEED WORK
   487                              <1> ;THE CH376 ERROR STATUS NUMBERS DO NOT MATCH PC COMPATABLE NUMBERS
   488                              <1> ;STATUS 0X14 IS SUCCESS AND INTERPRETED TO RETURN 0X00
   489                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
   490                              <1> .GET_STATUS_LAST_OPERATION:	
   491                              <1> 	
   492 0000D6C9 B022                <1> 	MOV AL, CH376S_GET_STATUS			;GET_STATUS OF INT
   493 0000D6CB E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT				
   494 0000D6CD E4E0                <1> 	IN AL, DATA_PORT					;READ IN STATUS DATA PORT
   495                              <1> 	
   496 0000D6CF 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS		;CHECK FOR USB_INT_SUCCESS
   497 0000D6D1 7506                <1> 	JNE .STATUS_DISK_ERROR				;IF USB_INT_SUCCESS
   498                              <1> 	
   499 0000D6D3 B400                <1> 	MOV AH, 0X00						;STATUS 0X00 SUCCESSFULL
   500 0000D6D5 F8                  <1> 	CLC									;CLEAR CARRY FLAG SUCCESFUL	
   501 0000D6D6 E97202              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   502                              <1> 	
   503                              <1> .STATUS_DISK_ERROR:
   504                              <1> 	; Instead of returning the CH376S status code in AL,
   505                              <1> 	; map some of them to BIOS-friendly codes
   506 0000D6D9 3C16                <1> 	CMP AL, CH376S_USB_INT_DISCONNECT		; DISC DISCONNECTED
   507 0000D6DB 7504                <1> 	JNE .NOT_0X16
   508 0000D6DD B4AA                <1> 	MOV AH, 0xAA							; BIOS CODE AA
   509 0000D6DF EB12                <1> 	JMP .STATUS_SELECTED
   510                              <1> 
   511                              <1> .NOT_0X16:
   512 0000D6E1 3C17                <1> 	CMP AL, CH376S_USB_INT_BUF_OVER			; DATA ERROR OR BUFFER OVERFLOW
   513 0000D6E3 7504                <1> 	JNE .NOT_0X17
   514 0000D6E5 B410                <1> 	MOV AH, 0x10							; BIOS CODE 10
   515 0000D6E7 EB0A                <1> 	JMP .STATUS_SELECTED
   516                              <1> 
   517                              <1> .NOT_0X17:
   518 0000D6E9 3C1F                <1> 	CMP AL, CH376S_USB_INT_DISK_ERR			; STORAGE DEVICE FAILURE
   519 0000D6EB 7504                <1> 	JNE .NOT_0X1F
   520 0000D6ED B420                <1> 	MOV AH, 0x20							; BIOS CODE 20
   521 0000D6EF EB02                <1> 	JMP .STATUS_SELECTED
   522                              <1> 
   523                              <1> .NOT_0X1F:
   524 0000D6F1 B4BB                <1> 	MOV AH, 0xBB							; BIOS CODE BB as catch all
   525                              <1> 
   526                              <1> .STATUS_SELECTED:
   527 0000D6F3 F9                  <1> 	STC										;SET CARRY FLAG 	
   528 0000D6F4 E95402              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   529                              <1> 	
   530                              <1> 
   531                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   532                              <1> ;READ DISK SECTOR	
   533                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   534                              <1> ;LBA = (C × HPC + H) × SPT + (S − 1)
   535                              <1> ;MAX NUMBERS C = 0X3FF, H = 0XFF, S = 0X3F
   536                              <1> ;AH = 02h
   537                              <1> ;AL = number of sectors to read (must be nonzero)
   538                              <1> ;CH = low eight bits of cylinder number
   539                              <1> ;CL = sector number 1-63 (bits 0-5)
   540                              <1> ;high two bits of cylinder (bits 6-7, hard disk only)
   541                              <1> ;DH = head number
   542                              <1> ;DL = drive number (bit 7 set for hard disk)
   543                              <1> ;ES:BX -> data buffer
   544                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   545                              <1> .DISK_READ:
   546 0000D6F7 53                  <1> 	PUSH BX					;
   547 0000D6F8 51                  <1> 	PUSH CX					;STORE REGISTERS
   548 0000D6F9 52                  <1> 	PUSH DX					;
   549 0000D6FA 06                  <1> 	PUSH ES					;
   550 0000D6FB 57                  <1> 	PUSH DI					;Used for bulk read
   551                              <1> 	
   552 0000D6FC 50                  <1> 	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
   553 0000D6FD 50                  <1> 	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
   554                              <1> 	
   555 0000D6FE E89D03              <1> 	CALL CONVERT_CHS_TO_LBA
   556                              <1> 
   557 0000D701 52                  <1> 	PUSH DX					;STORE LBA UPPER
   558 0000D702 50                  <1> 	PUSH AX					;STORE LBA LOWER
   559                              <1> 		
   560                              <1> 	
   561 0000D703 B054                <1> 	MOV AL, CH376S_DISK_READ	;DISK_READ
   562 0000D705 E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   563 0000D707 58                  <1> 	POP AX						;GET LOWER LBA
   564 0000D708 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   565 0000D70A 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   566 0000D70C E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   567 0000D70E 58                  <1> 	POP AX						;GET UPPER LBA
   568 0000D70F E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   569 0000D711 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   570 0000D713 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   571 0000D715 58                  <1> 	POP AX						;GET NUMBER OF SECTORS
   572 0000D716 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   573                              <1> 
   574                              <1> 
   575                              <1> .READ_SECTOR:
   576 0000D718 E87A03              <1> 	CALL AWAIT_INTERRUPT
   577                              <1> 
   578 0000D71B B022                <1> 	MOV AL, CH376S_GET_STATUS		;GET_STATUS
   579 0000D71D E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   580 0000D71F E4E0                <1> 	IN AL, DATA_PORT				;READ IN STATUS DATA PORT
   581 0000D721 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS	;CHECK FOR USB_INT_SUCCESS COMPLETED READING
   582 0000D723 7458                <1> 	JE .READ_DISK_SUCCESS			;IF USB_INT_SUCCESS
   583 0000D725 3C1D                <1> 	CMP AL, CH376S_USB_INT_DISK_READ;COMPARE TO USB_INT_DISK_READ
   584                              <1> %if DISPLAY_CH376S_ERRORS = 1
   585                              <1> 	JNE .NOT_1D						;IF NOT USB_INT_DISK_READ
   586                              <1> %else
   587 0000D727 7560                <1> 	JNE .READ_DISK_ERROR
   588                              <1> %endif	
   589                              <1> 
   590 0000D729 B027                <1> 	MOV AL, CH376S_RD_USB_DATA0		;RD_USB_DATA0
   591 0000D72B E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   592 0000D72D E4E0                <1> 	IN AL, DATA_PORT				;READ NUMBER OF BYTES FROM DATA PORT 
   593 0000D72F B400                <1> 	MOV AH, 0X00					;CLEAR AH
   594 0000D731 89C1                <1> 	MOV CX, AX						;SET CX TO NUMBER OF BYTES
   595                              <1> .READ_IN_LOOP:		    ;LOOP LABLE
   596 0000D733 E4E0                <1> 	IN AL, DATA_PORT	;READ BYTE
   597 0000D735 268807              <1> 	MOV [ES:BX], AL		;STORE BYTE
   598 0000D738 43                  <1> 	INC BX				;INC BX
   599 0000D739 E2F8                <1> 	LOOP .READ_IN_LOOP	;LOOP UNTIL DONE
   600                              <1> 
   601 0000D73B B055                <1> 	MOV AL, CH376S_DISK_RD_GO		;DISK_RD_GO READ NEXT 64 BYTES
   602 0000D73D E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   603 0000D73F EBD7                <1> 	JMP .READ_SECTOR				;LOOP UNTIL DONE
   604                              <1> 		
   605                              <1> .NOT_1D:							; DEBUG FEATURE: DISPLAY ERROR MESSAGE
   606 0000D741 E8BC21              <1> 	CALL WRITE_AL_INT10_E			; PRINTS ERROR NUMBER TO SCREEN
   607 0000D744 50                  <1> 	PUSH AX
   608 0000D745 1E                  <1> 	PUSH DS
   609 0000D746 8CC8                <1> 	MOV AX, CS						; GET CS 
   610 0000D748 8ED8                <1> 	MOV DS, AX						; SET DS TO CS
   611 0000D74A B40E                <1> 	MOV AH, 0X0E					; FOR TELOTYPE
   612 0000D74C B92000              <1> 	MOV CX, .END_READ_ERROR_MESSAGE - .READ_ERROR_MESSAGE
   613 0000D74F BB[5DD7]            <1> 	MOV BX, .READ_ERROR_MESSAGE	
   614                              <1> 	.LOOP_NOT_1D:
   615 0000D752 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
   616 0000D754 CD10                <1> 	INT 0X10						;PRINT TO SCREEN
   617 0000D756 43                  <1> 	INC BX							;INC BX
   618 0000D757 E2F9                <1> 	LOOP .LOOP_NOT_1D				;LOOP UNTIL DONE
   619 0000D759 1F                  <1> 	POP DS
   620 0000D75A 58                  <1> 	POP AX
   621 0000D75B EB2C                <1> 	JMP .READ_DISK_ERROR
   622                              <1> 
   623                              <1> 	.READ_ERROR_MESSAGE:
   624 0000D75D 0D0A55534220524541- <1> 	DB 0X0D, 0X0A, 'USB READ ERROR READING DISC', 0X0D, 0X0A, 0
   624 0000D766 44204552524F522052- <1>
   624 0000D76F 454144494E47204449- <1>
   624 0000D778 53430D0A00          <1>
   625                              <1> 	.END_READ_ERROR_MESSAGE:
   626                              <1> 
   627                              <1> .READ_DISK_SUCCESS:
   628                              <1> 
   629 0000D77D 58                  <1> 	POP AX
   630 0000D77E 5F                  <1> 	POP DI
   631 0000D77F 07                  <1> 	POP ES
   632 0000D780 5A                  <1> 	POP DX
   633 0000D781 59                  <1> 	POP CX
   634 0000D782 5B                  <1> 	POP BX
   635 0000D783 B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   636 0000D785 F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   637 0000D786 E9C201              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   638                              <1> 	
   639                              <1> .READ_DISK_ERROR:
   640 0000D789 5F                  <1> 	POP DI				; Discard the unwanted copy of AX on stack
   641 0000D78A 5F                  <1> 	POP DI
   642 0000D78B 07                  <1> 	POP ES
   643 0000D78C 5A                  <1> 	POP DX
   644 0000D78D 59                  <1> 	POP CX
   645 0000D78E 5B                  <1> 	POP BX
   646 0000D78F E947FF              <1> 	JMP .STATUS_DISK_ERROR
   647                              <1> 
   648                              <1> 
   649                              <1> 
   650                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   651                              <1> ;WRITE DISK SECTOR(S)
   652                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   653                              <1> ;LBA = (C × HPC + H) × SPT + (S − 1)
   654                              <1> ;MAX NUMBERS C = 0X3FF, H = 0XFF, S = 0X3F
   655                              <1> ;AH = 03h
   656                              <1> ;AL = number of sectors to read (must be nonzero)
   657                              <1> ;CH = low eight bits of cylinder number
   658                              <1> ;CL = sector number 1-63 (bits 0-5)
   659                              <1> ;high two bits of cylinder (bits 6-7, hard disk only)
   660                              <1> ;DH = head number
   661                              <1> ;DL = drive number (bit 7 set for hard disk)
   662                              <1> ;ES:BX -> data buffer
   663                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   664                              <1> .WRITE_DISK:
   665 0000D792 53                  <1> 	PUSH BX					;
   666 0000D793 51                  <1> 	PUSH CX					;STORE REGISTERS
   667 0000D794 52                  <1> 	PUSH DX					;
   668 0000D795 06                  <1> 	PUSH ES					;
   669 0000D796 1E                  <1> 	PUSH DS					; we'll need this for bulk writing
   670 0000D797 56                  <1> 	PUSH SI					; We need this for string operation
   671                              <1> 	
   672 0000D798 50                  <1> 	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
   673 0000D799 50                  <1> 	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
   674                              <1> 	
   675 0000D79A E80103              <1> 	CALL CONVERT_CHS_TO_LBA
   676                              <1> 
   677 0000D79D 52                  <1> 	PUSH DX					;STORE LBA UPPER
   678 0000D79E 50                  <1> 	PUSH AX					;STORE LBA LOWER
   679                              <1> 
   680 0000D79F B056                <1> 	MOV AL, CH376S_DISK_WRITE	;DISK_WRITE
   681 0000D7A1 E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   682                              <1> 
   683                              <1> 
   684 0000D7A3 58                  <1> 	POP AX						;GET LOWER LBA
   685 0000D7A4 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   686                              <1> 
   687                              <1> 
   688 0000D7A6 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   689 0000D7A8 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   690                              <1> 
   691                              <1> 
   692 0000D7AA 58                  <1> 	POP AX						;GET UPPER LBA
   693 0000D7AB E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   694                              <1> 
   695 0000D7AD 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   696 0000D7AF E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   697                              <1> 
   698 0000D7B1 58                  <1> 	POP AX						;GET NUMBER OF SECTORS
   699 0000D7B2 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   700 0000D7B4 8CC0                <1> 	MOV AX, ES					; While the BIOS spec has the package at ES:BX
   701 0000D7B6 8ED8                <1> 	MOV DS, AX					; REP OUTSB transfers from DS:BX
   702                              <1> 	
   703                              <1> .WRITE_SECTOR:
   704 0000D7B8 E8DA02              <1> 	CALL AWAIT_INTERRUPT
   705 0000D7BB B022                <1> 	MOV AL, CH376S_GET_STATUS			;GET_STATUS
   706 0000D7BD E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   707 0000D7BF E4E0                <1> 	IN  AL, DATA_PORT					;READ IN STATUS DATA PORT
   708 0000D7C1 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS		;CHECK FOR USB_INT_SUCCESS COMPLETED WRITING
   709 0000D7C3 744E                <1> 	JE  .WRITE_DISK_SUCCESS				;IF USB_INT_SUCCESS
   710 0000D7C5 3C1E                <1> 	CMP AL, CH376S_USB_INT_DISK_WRITE	;COMPARE TO USB_INT_DISK_WRITE
   711                              <1> %if DISPLAY_CH376S_ERRORS = 1
   712                              <1> 	JNE .NOT_1E			;IF NOT USB_INT_DISK_WRITE
   713                              <1> %else
   714 0000D7C7 7557                <1> 	JNE .WRITE_DISK_ERROR
   715                              <1> %endif	
   716 0000D7C9 B02C                <1> 	MOV AL, CH376S_WR_USB_DATA			;COMMAND WR_HOST_DATA
   717 0000D7CB E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   718 0000D7CD B040                <1> 	MOV AL, 0X40
   719 0000D7CF E6E0                <1> 	OUT DATA_PORT, AL					;WRITE NUMBER OF BYTES TO PORT
   720 0000D7D1 B400                <1> 	MOV AH, 0X00						;CLEAR AH
   721 0000D7D3 89C1                <1> 	MOV CX, AX							;SET CX TO NUMBER OF BYTES
   722                              <1>  .WRITE_IN_LOOP:		;LOOP LABLE
   723 0000D7D5 268A07              <1>   	MOV AL, [ES:BX]		;STORE BYTE
   724 0000D7D8 E6E0                <1> 	OUT 0XE0, AL			;READ BYTE
   725                              <1> 	
   726 0000D7DA 43                  <1> 	INC BX				;INC BX
   727 0000D7DB E2F8                <1> 	LOOP .WRITE_IN_LOOP	;LOOP UNTIL DONE
   728 0000D7DD B057                <1> 	MOV AL, CH376S_DISK_WR_GO			;DISK_WR_GO WRITE NEXT 64 BYTES
   729 0000D7DF E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   730 0000D7E1 EBD5                <1> 	JMP .WRITE_SECTOR					;LOOP UNTIL DONE
   731                              <1> 
   732                              <1> 		
   733                              <1> .NOT_1E:							; Version for debugging which displays error text
   734 0000D7E3 E81A21              <1> 	CALL WRITE_AL_INT10_E			;PRINTS ERROR NUMBER TO SCREEN
   735 0000D7E6 50                  <1> 	PUSH AX
   736 0000D7E7 1E                  <1> 	PUSH DS
   737 0000D7E8 8CC8                <1> 	MOV AX, CS						;GET CS 
   738 0000D7EA 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
   739 0000D7EC B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
   740 0000D7EE B91400              <1> 	MOV CX, .END_WRITE_ERROR_MESSAGE - .WRITE_ERROR_MESSAGE
   741 0000D7F1 BB[FFD7]            <1> 	MOV BX, .WRITE_ERROR_MESSAGE	
   742                              <1> 	.LOOP_NOT_1E:
   743 0000D7F4 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
   744 0000D7F6 CD10                <1> 	INT 0X10						;PRINT TO SCREEN
   745 0000D7F8 43                  <1> 	INC BX							;INC BX
   746 0000D7F9 E2F9                <1> 	LOOP .LOOP_NOT_1E				;LOOP UNTIL DONE
   747 0000D7FB 1F                  <1> 	POP DS
   748 0000D7FC 58                  <1> 	POP AX
   749 0000D7FD EB21                <1> 	JMP .WRITE_DISK_ERROR
   750                              <1> 
   751                              <1> 	.WRITE_ERROR_MESSAGE:
   752 0000D7FF 0D0A55534220575249- <1> 	DB 0X0D, 0X0A, 'USB WRITE ERROR', 0X0D, 0X0A,0
   752 0000D808 5445204552524F520D- <1>
   752 0000D811 0A00                <1>
   753                              <1> 	.END_WRITE_ERROR_MESSAGE:
   754                              <1> 
   755                              <1> .WRITE_DISK_SUCCESS:
   756 0000D813 58                  <1> 	POP AX
   757 0000D814 5E                  <1> 	POP SI
   758 0000D815 1F                  <1> 	POP DS
   759 0000D816 07                  <1> 	POP ES
   760 0000D817 5A                  <1> 	POP DX
   761 0000D818 59                  <1> 	POP CX
   762 0000D819 5B                  <1> 	POP BX
   763 0000D81A B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   764 0000D81C F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   765 0000D81D E92B01              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   766                              <1> 	
   767                              <1> .WRITE_DISK_ERROR:
   768 0000D820 07                  <1> 	POP ES				; Discard the unwanted copy of AX on stack
   769 0000D821 5E                  <1> 	POP SI
   770 0000D822 1F                  <1> 	POP DS
   771 0000D823 07                  <1> 	POP ES
   772 0000D824 5A                  <1> 	POP DX
   773 0000D825 59                  <1> 	POP CX
   774 0000D826 5B                  <1> 	POP BX
   775 0000D827 E9AFFE              <1> 	JMP .STATUS_DISK_ERROR
   776                              <1> 	
   777                              <1> 
   778                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   779                              <1> ;FORMAT A TRACK
   780                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   781                              <1> ;LBA = (C × HPC + H) × SPT + (S − 1)
   782                              <1> ;MAX NUMBERS C = 0X3FF, H = 0XFF, S = 0X3F
   783                              <1> ;AH = 05h
   784                              <1> ;AL = Interleave value (ignored)
   785                              <1> ;CH = low eight bits of cylinder number
   786                              <1> ;CL = Low six bits ignored
   787                              <1> ;high two bits of cylinder (bits 6-7, hard disk only)
   788                              <1> ;DH = head number
   789                              <1> ;DL = drive number (bit 7 set for hard disk)
   790                              <1> ;ES:BX -> data buffer
   791                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   792                              <1> .FORMAT_TRACK:
   793 0000D82A 53                  <1> 	PUSH BX					;
   794 0000D82B 51                  <1> 	PUSH CX					;STORE REGISTERS
   795 0000D82C 52                  <1> 	PUSH DX					;
   796                              <1> 
   797 0000D82D 80E1C0              <1> 	AND CL, 0b11000000		;Remove the "sector" part of CX (ignored) and
   798 0000D830 80C901              <1> 	OR CL, 1				;treat it as "Sector 1", and
   799 0000D833 E86802              <1> 	CALL CONVERT_CHS_TO_LBA	;the CHS->LBA formula will get us the first block of the track
   800                              <1> 
   801 0000D836 52                  <1> 	PUSH DX					;STORE LBA UPPER
   802 0000D837 50                  <1> 	PUSH AX					;STORE LBA LOWER
   803                              <1> 
   804 0000D838 B056                <1> 	MOV AL, CH376S_DISK_WRITE	;DISK_WRITE
   805 0000D83A E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   806                              <1> 
   807 0000D83C 58                  <1> 	POP AX						;GET LOWER LBA
   808 0000D83D E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   809 0000D83F 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   810 0000D841 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   811 0000D843 58                  <1> 	POP AX						;GET UPPER LBA
   812 0000D844 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   813 0000D846 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   814 0000D848 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   815 0000D84A B03F                <1> 	MOV AL, MAX_SPT				;ALWAYS DO MAX SECTORS IN A TRACK
   816 0000D84C E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   817                              <1> 	
   818                              <1> .FORMAT_SECTOR:
   819 0000D84E E84402              <1> 	CALL AWAIT_INTERRUPT
   820 0000D851 B022                <1> 	MOV AL, CH376S_GET_STATUS			;GET_STATUS
   821 0000D853 E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   822 0000D855 E4E0                <1> 	IN AL, DATA_PORT					;READ IN STATUS DATA PORT
   823 0000D857 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS		;CHECK FOR USB_INT_SUCCESS COMPLETED WRITING
   824 0000D859 744D                <1> 	JE .FORMAT_DISK_SUCCESS				;IF USB_INT_SUCCESS
   825 0000D85B 3C1E                <1> 	CMP AL, CH376S_USB_INT_DISK_WRITE	;COMPARE TO USB_INT_DISK_WRITE
   826                              <1> %if DISPLAY_CH376S_ERRORS = 1
   827                              <1> 	JNE .NOT_1E_FORMAT  				;IF NOT USB_INT_DISK_WRITE
   828                              <1> %else
   829 0000D85D 7552                <1> 	JNE .FORMAT_DISK_ERROR
   830                              <1> %endif
   831 0000D85F B02C                <1> 	MOV AL, CH376S_WR_USB_DATA			;COMMAND WR_HOST_DATA
   832 0000D861 E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   833 0000D863 B040                <1> 	MOV AL, 0X40
   834 0000D865 E6E0                <1> 	OUT DATA_PORT, AL					;WRITE NUMBER OF BYTES TO PORT
   835 0000D867 B400                <1> 	MOV AH, 0X00						;CLEAR AH
   836 0000D869 89C1                <1> 	MOV CX, AX							;SET CX TO NUMBER OF BYTES
   837 0000D86B B000                <1> 	MOV AL, 00h
   838                              <1> .FORMAT_BYTE:
   839 0000D86D E6E0                <1> 	OUT DATA_PORT, AL
   840 0000D86F E2FC                <1> 	LOOP .FORMAT_BYTE
   841 0000D871 B057                <1> 	MOV AL, CH376S_DISK_WR_GO			;DISK_WR_GO READ NEXT 64 BYTES
   842 0000D873 E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   843 0000D875 EBD7                <1> 	JMP .FORMAT_SECTOR					;LOOP UNTIL DONE
   844                              <1> 
   845                              <1> 		
   846                              <1> .NOT_1E_FORMAT:						; Debug version that displays error
   847 0000D877 E88620              <1> 	CALL WRITE_AL_INT10_E			;PRINTS ERROR NUMBER TO SCREEN
   848 0000D87A 50                  <1> 	PUSH AX
   849 0000D87B 1E                  <1> 	PUSH DS
   850 0000D87C 8CC8                <1> 	MOV AX, CS						;GET CS 
   851 0000D87E 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
   852 0000D880 B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
   853 0000D882 B91500              <1> 	MOV CX, .END_FORMAT_ERROR_MESSAGE - .FORMAT_ERROR_MESSAGE
   854 0000D885 BB[93D8]            <1> 	MOV BX, .FORMAT_ERROR_MESSAGE	
   855                              <1> 	.LOOP_NOT_1E_FORMAT:
   856 0000D888 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
   857 0000D88A CD10                <1> 	INT 0X10						;PRINT TO SCREEN
   858 0000D88C 43                  <1> 	INC BX							;INC BX
   859 0000D88D E2F9                <1> 	LOOP .LOOP_NOT_1E_FORMAT				;LOOP UNTIL DONE
   860 0000D88F 1F                  <1> 	POP DS
   861 0000D890 58                  <1> 	POP AX
   862 0000D891 EB1E                <1> 	JMP .FORMAT_DISK_ERROR
   863                              <1> 
   864                              <1> 	.FORMAT_ERROR_MESSAGE:
   865 0000D893 0D0A55534220464F52- <1> 	DB 0X0D, 0X0A, 'USB FORMAT ERROR', 0X0D, 0X0A,0
   865 0000D89C 4D4154204552524F52- <1>
   865 0000D8A5 0D0A00              <1>
   866                              <1> 	.END_FORMAT_ERROR_MESSAGE:
   867                              <1> 
   868                              <1> .FORMAT_DISK_SUCCESS:
   869 0000D8A8 5A                  <1> 	POP DX
   870 0000D8A9 59                  <1> 	POP CX
   871 0000D8AA 5B                  <1> 	POP BX
   872 0000D8AB B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   873 0000D8AD F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   874 0000D8AE E99A00              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   875                              <1> 	
   876                              <1> .FORMAT_DISK_ERROR:
   877 0000D8B1 5A                  <1> 	POP DX
   878 0000D8B2 59                  <1> 	POP CX
   879 0000D8B3 5B                  <1> 	POP BX
   880 0000D8B4 E922FE              <1> 	JMP .STATUS_DISK_ERROR
   881                              <1> 
   882                              <1> 
   883                              <1> 
   884                              <1> 
   885                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   886                              <1> ;GET PARAMETERS	0X08
   887                              <1> ;RETURNS
   888                              <1> ;AH=STATUS 0X00 IS GOOD
   889                              <1> ;BL=DOES NOT APPLY 
   890                              <1> ;CH=CYLINDERS
   891                              <1> ;CL=0-5 SECTORS PER TRACK 6-7 UPPER 2 BITS CYLINDER
   892                              <1> ;DH=NUMBER OF HEADS / SIDES -1
   893                              <1> ;DL=NUMBER OF DRIVES
   894                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   895                              <1> .PARAMETERS:
   896 0000D8B7 50                  <1> 	PUSH AX					;STORE AX
   897 0000D8B8 53                  <1> 	PUSH BX					;STORE BX
   898                              <1> 	
   899 0000D8B9 E81002              <1> 	CALL GET_CAPACITY
   900                              <1> 	; DX:AX now has sector count
   901                              <1> 
   902 0000D8BC 83F800              <1> 	CMP AX, 0
   903 0000D8BF 7507                <1> 	JNE .HAS_PARAMS
   904 0000D8C1 83FA00              <1> 	CMP DX, 0
   905 0000D8C4 7502                <1> 	JNE .HAS_PARAMS
   906 0000D8C6 EB42                <1> 	JMP .PARAMETERS_NOT_P
   907                              <1> 
   908                              <1> .HAS_PARAMS:
   909                              <1> 	; If we exceed (MAX_SPT * MAX_HPC * MAX_CYL)
   910                              <1> 	; just identify as the max amount
   911 0000D8C8 83FA0F              <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   912 0000D8CB 7C10                <1> 	JL .SAFE_PARAMS
   913 0000D8CD 83FA0F              <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   914 0000D8D0 7F05                <1> 	JG .USE_MAX_PARAMS
   915 0000D8D2 3D00C0              <1> 	CMP AX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   916 0000D8D5 7E06                <1> 	JLE .SAFE_PARAMS
   917                              <1> 
   918                              <1> .USE_MAX_PARAMS:
   919 0000D8D7 BA0F00              <1> 	MOV DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   920 0000D8DA B800C0              <1> 	MOV AX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   921                              <1> 
   922                              <1> .SAFE_PARAMS:
   923 0000D8DD B9F003              <1> 	MOV CX, (MAX_SPT * MAX_HPC)
   924                              <1> 				     		
   925                              <1> 							; The cylinders and heads seem to be "maximum"
   926                              <1> 							; so on 1024 cylinders, 1023 is max
   927                              <1> 							; 16 heads, 15 is max
   928                              <1> 							; but 63 sectors per track the right answer is actually 63
   929 0000D8E0 F7F1                <1> 	DIV CX					;DIV DX:AX / CX
   930 0000D8E2 BA0000              <1> 	MOV DX, 0X0000			;CLEAR DX JUST IN CASE THERE SHOULD NOT BE A REMANDER 
   931 0000D8E5 83E801              <1> 	SUB AX, 1				; Max cylinder is number of cylinders minus one
   932 0000D8E8 88C5                <1> 	MOV CH, AL				;CH=0-7 CYLINDERS
   933 0000D8EA D0E4                <1>     SHL AH, 1
   934 0000D8EC D0E4                <1>     SHL AH, 1
   935 0000D8EE D0E4                <1>     SHL AH, 1
   936 0000D8F0 D0E4                <1>     SHL AH, 1
   937 0000D8F2 D0E4                <1>     SHL AH, 1
   938 0000D8F4 D0E4                <1>     SHL AH, 1
   939 0000D8F6 B13F                <1> 	MOV CL, MAX_SPT			;SECTORS PER TRACK
   940 0000D8F8 80E13F              <1> 	AND CL, 0X3F			;CLEAR BITS 7-6
   941 0000D8FB 00E1                <1> 	ADD CL, AH				;ADD IN 8-9 BITS CYLINDER
   942 0000D8FD B60F                <1> 	MOV DH, MAX_HPC - 1		;NUMBER OF HEADS / SIDES
   943 0000D8FF B201                <1> 	MOV DL, 0X01			;NUMBER OF DRIVES
   944 0000D901 EB00                <1> 	JMP .END_PARAMETERS
   945                              <1> 
   946                              <1> .END_PARAMETERS:
   947                              <1> 
   948 0000D903 5B                  <1> 	POP BX				;RESTORE BX
   949 0000D904 58                  <1> 	POP AX				;RESTORE AX
   950                              <1> 	
   951 0000D905 B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   952 0000D907 F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   953 0000D908 EB41                <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   954                              <1> 	
   955                              <1> .PARAMETERS_NOT_P:
   956                              <1> 	
   957 0000D90A 5B                  <1> 	POP BX				;RESTORE BX
   958 0000D90B 58                  <1> 	POP AX				;RESTORE AX
   959                              <1> 	
   960 0000D90C B401                <1> 	MOV AH, 0X01		;STATUS 0X01 UNSUCCESSFULL
   961 0000D90E F9                  <1> 	STC 				;SET CARRY FLAG	
   962 0000D90F EB3A                <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   963                              <1> 
   964                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   965                              <1> ;GET DISK TYPE	0X15
   966                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   967                              <1> .GET_DISK_TYPE:
   968 0000D911 53                  <1> 	PUSH BX						;STORE BX
   969 0000D912 50                  <1> 	PUSH AX
   970                              <1> 	
   971 0000D913 E8B601              <1> 	CALL GET_CAPACITY
   972                              <1> 	; DX:AX now has sector count - move to where the output wants it.
   973 0000D916 89D1                <1> 	MOV CX, DX
   974 0000D918 89C2                <1> 	MOV DX, AX
   975                              <1> 	; CX:DX now has the sector count
   976                              <1> 
   977 0000D91A 83F900              <1> 	CMP CX, 0
   978 0000D91D 7507                <1> 	JNE .HAS_DISK_TYPE_PARAMS
   979 0000D91F 83FA00              <1> 	CMP DX, 0
   980 0000D922 7502                <1> 	JNE .HAS_DISK_TYPE_PARAMS
   981 0000D924 EB1B                <1> 	JMP .GET_DISK_TYPE_NOT_P
   982                              <1> 
   983                              <1> .HAS_DISK_TYPE_PARAMS:
   984                              <1> 	; If we exceed 0xFAC53F sectors (MAX_SPT * MAX_HPC * MAX_CYL)
   985                              <1> 	; just identify as FAC53F
   986 0000D926 83F90F              <1> 	CMP CX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   987 0000D929 7C11                <1> 	JL .SAFE_DISK_TYPE_PARAMS
   988 0000D92B 83F90F              <1> 	CMP CX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   989 0000D92E 7F06                <1> 	JG .USE_MAX_DISK_TYPE_PARAMS
   990 0000D930 81FA00C0            <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   991 0000D934 7E06                <1> 	JLE .SAFE_DISK_TYPE_PARAMS
   992                              <1> 
   993                              <1> .USE_MAX_DISK_TYPE_PARAMS:
   994 0000D936 B90F00              <1> 	MOV CX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   995 0000D939 BA00C0              <1> 	MOV DX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   996                              <1> 
   997                              <1> .SAFE_DISK_TYPE_PARAMS:
   998 0000D93C B80003              <1> 	MOV AX, 0X0300			;AH=0X03 FIXED DISK AL=RETURN 0X00
   999 0000D93F EB05                <1> 	JMP .END_GET_DISK_TYPE	;END
  1000                              <1> 	
  1001                              <1> .GET_DISK_TYPE_NOT_P:
  1002 0000D941 B80000              <1> 	MOV AX, 0X0000			;AH=0X00 WHEN NOT PRESENT 
  1003 0000D944 EB00                <1> 	JMP .END_GET_DISK_TYPE
  1004                              <1> 	
  1005                              <1> .END_GET_DISK_TYPE:
  1006                              <1> 
  1007 0000D946 58                  <1> 	POP AX
  1008 0000D947 5B                  <1> 	POP BX					;RESTORE BX
  1009 0000D948 F8                  <1> 	CLC						;CLEAR CARRY FLAG SUCCESFUL	
  1010 0000D949 EB00                <1> 	JMP .INT13_END_WITH_CARRY_FLAG
  1011                              <1> 
  1012                              <1> 
  1013                              <1> 	
  1014                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1015                              <1> ;END INT 0X13 WITH UPDATED CARRY FLAG		
  1016                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1017                              <1>   .INT13_END_WITH_CARRY_FLAG:	;THIS IS HOW I RETURN THE CARRY FLAG
  1018 0000D94B 50                  <1> 	PUSH    AX						;STORE AX
  1019 0000D94C 9C                  <1> 	PUSHF						;STORE FLAGS
  1020 0000D94D 58                  <1> 	POP     AX						;GET AX = FLAGS
  1021 0000D94E 55                  <1> 	PUSH    BP						;STORE BP
  1022 0000D94F 89E5                <1> 	MOV     BP, SP              	;Copy SP to BP for use as index
  1023 0000D951 83C508              <1> 	ADD     BP, 0X08				;offset 8
  1024 0000D954 836600FE            <1> 	AND     WORD [BP], 0XFFFE		;CLEAR CF = ZER0
  1025 0000D958 83E001              <1> 	AND     AX, 0X0001				;ONLY CF 
  1026 0000D95B 094600              <1> 	OR	    WORD [BP], AX			;SET CF AX
  1027 0000D95E 5D                  <1> 	POP     BP               		;RESTORE BASE POINTER
  1028 0000D95F 58                  <1> 	POP     AX						;RESTORE AX	
  1029 0000D960 FB                  <1>     STI
  1030 0000D961 CF                  <1> 	IRET						;RETRUN
  1031                              <1> 
  1032                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1033                              <1> ; WHEN REQUEST IS NOT A VALID DRIVE NUMBER
  1034                              <1> ; INVOKE OLD BIOS VECTOR AND RETURN
  1035                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1036                              <1> .NOT_A_DRIVE:
  1037 0000D962 BE[6BD9]            <1>     mov     si, drvInvalid
  1038 0000D965 E815F9              <1>     call    pstr
  1039                              <1> 
  1040 0000D968 9D                  <1>   	POPF        ; we want the flags we stored before the original compare
  1041                              <1> 
  1042                              <1> 	;INT     0x40
  1043                              <1> 	;PUSH    BP
  1044                              <1> 	;MOV     BP,SP
  1045                              <1> 	;PUSHF
  1046                              <1> 	;POP     WORD [SS:BP+6]
  1047                              <1> 	;POP     BP
  1048 0000D969 FB                  <1>     STI
  1049 0000D96A CF                  <1> 	IRET
  1050 0000D96B 0D0A496E76616C6964- <1> drvInvalid  db 0x0d,0x0a,'Invalid driver...',0x0d,0x0a,0
  1050 0000D974 206472697665722E2E- <1>
  1050 0000D97D 2E0D0A00            <1>
  1051                              <1> ;WAIT_2:
  1052                              <1> ;	PUSH CX
  1053                              <1> ;	MOV CX, 0xFFFF		; 65536 runs = ~300k cycles = 40ms
  1054                              <1> ;DELAY: LOOP DELAY
  1055                              <1> ;	MOV CX, 0xFFFF		; 65536 runs = ~300k cycles = 40ms
  1056                              <1> ;DELAY2: LOOP DELAY2
  1057                              <1> ;	POP CX
  1058                              <1> ;	RET
  1059                              <1> 
  1060                              <1> ;WAIT_8:
  1061                              <1> ;	PUSH CX
  1062                              <1> ;	MOV CX, 8
  1063                              <1> ;  .LOOP1A:
  1064                              <1> ;	PUSH CX
  1065                              <1> ;	MOV CX, 0XFFFF
  1066                              <1> ;  .LOOP2A:
  1067                              <1> ;	LOOP .LOOP2A
  1068                              <1> ;	POP CX
  1069                              <1> ;	LOOP .LOOP1A
  1070                              <1> ;	POP CX
  1071                              <1> ;	RET
  1072                              <1> 		
  1073                              <1> ;;;;;;;;;;;;;;;;;;;;;;;
  1074                              <1> ;WRITE TO SCREEN;;;;;;;
  1075                              <1> ;;;;;;;;;;;;;;;;;;;;;;;
  1076                              <1> ;WRITE_AL_INT10_E:
  1077                              <1> ;
  1078                              <1> ;	PUSH AX
  1079                              <1> ;	PUSH BX
  1080                              <1> ;	PUSH CX
  1081                              <1> ;	PUSH DX
  1082                              <1> ;
  1083                              <1> ;	MOV BL, AL
  1084                              <1> ;
  1085                              <1> ;	MOV DH, AL
  1086                              <1> ;	MOV CL, 0X04
  1087                              <1> ;	SHR DH, CL
  1088                              <1> ;
  1089                              <1> ;	MOV AL, DH
  1090                              <1> ;	AND AL, 0X0F
  1091                              <1> ;	CMP AL, 0X09
  1092                              <1> ;	JA LETTER_HIGH
  1093                              <1> ;
  1094                              <1> ;	ADD AL, 0X30
  1095                              <1> ;	JMP PRINT_VALUE_HIGH
  1096                              <1> ;
  1097                              <1> ;	LETTER_HIGH:
  1098                              <1> ;	ADD AL, 0X37
  1099                              <1> ;
  1100                              <1> ;	PRINT_VALUE_HIGH:
  1101                              <1> ;	MOV AH, 0X0E
  1102                              <1> ;	INT 0X10
  1103                              <1> ;
  1104                              <1> ;	MOV AL, BL
  1105                              <1> ;	AND AL, 0X0F
  1106                              <1> ;	CMP AL, 0X09
  1107                              <1> ;	JA LETTER_LOW
  1108                              <1> ;
  1109                              <1> ;	ADD AL, 0X30
  1110                              <1> ;	JMP PRINT_VALUE_LOW
  1111                              <1> ;
  1112                              <1> ;	LETTER_LOW:
  1113                              <1> ;	ADD AL, 0X37
  1114                              <1> ;
  1115                              <1> ;	PRINT_VALUE_LOW:
  1116                              <1> ;	MOV AH, 0X0E
  1117                              <1> ;	INT 0X10
  1118                              <1> ;
  1119                              <1> ;	POP DX
  1120                              <1> ;	POP CX
  1121                              <1> ;	POP BX
  1122                              <1> ;	POP AX
  1123                              <1> ;
  1124                              <1> ;	RET
  1125                              <1> 
  1126                              <1> 
  1127                              <1> WRITE_SECTORS_IN_MB:
  1128                              <1> 	; Assumes sectors in DX:ax
  1129                              <1> 	; Likely to get confused on devices over 64Gb as the first div below
  1130                              <1> 	; overflows.
  1131 0000D981 50                  <1> 	PUSH AX
  1132 0000D982 51                  <1> 	PUSH CX
  1133 0000D983 52                  <1> 	PUSH DX
  1134 0000D984 53                  <1> 	PUSH BX
  1135 0000D985 31DB                <1> 	XOR BX, BX
  1136 0000D987 81FA0008            <1> 	CMP DX, 2048 ; 2048 x 10000h + sectors will overflow the DIV
  1137 0000D98B 7C13                <1> 	JL CONVERT_TO_MB_GB
  1138 0000D98D B301                <1> 	MOV BL, 1 ; FLAG TO USE GB
  1139 0000D98F 89D0                <1> 	MOV AX, DX
  1140 0000D991 BA0000              <1> 	MOV DX, 0
  1141                              <1> 			  ; Instead of dividing sectors (512 bytes) by 2048 to get MB
  1142                              <1> 			  ; Divide 10000h-sectors (32Mb units) by 32 to get GB
  1143 0000D994 D1E8                <1> 	SHR AX,1	  ; This remains 8088 version because it's not performance critical
  1144 0000D996 D1E8                <1> 	SHR AX,1
  1145 0000D998 D1E8                <1> 	SHR AX,1
  1146 0000D99A D1E8                <1> 	SHR AX,1
  1147 0000D99C D1E8                <1> 	SHR AX,1
  1148 0000D99E EB05                <1> 	JMP CONVERT_TO_DECIMAL
  1149                              <1> 
  1150                              <1> 
  1151                              <1> CONVERT_TO_MB_GB:
  1152 0000D9A0 B90008              <1> 	MOV CX, 2048
  1153 0000D9A3 F7F1                <1> 	DIV CX
  1154                              <1> 
  1155                              <1> CONVERT_TO_DECIMAL:
  1156 0000D9A5 BA0000              <1> 	MOV DX, 0 ; Divide by 10000, take the digit and convert to ASCII, and print
  1157 0000D9A8 B91027              <1> 	MOV CX, 10000
  1158 0000D9AB F7F1                <1> 	DIV CX
  1159 0000D9AD B40E                <1> 	MOV AH, 0x0E
  1160 0000D9AF 0C30                <1> 	OR AL, 0x30
  1161 0000D9B1 CD10                <1> 	INT 0x10
  1162                              <1> 
  1163                              <1> 
  1164 0000D9B3 89D0                <1> 	MOV AX, DX	  ;  Take remainder, divide by 1000, repeat
  1165 0000D9B5 BA0000              <1> 	mov DX, 0
  1166 0000D9B8 B9E803              <1> 	MOV CX, 1000
  1167 0000D9BB F7F1                <1> 	DIV CX
  1168 0000D9BD B40E                <1> 	MOV AH, 0x0E
  1169 0000D9BF 0C30                <1> 	OR AL, 0x30
  1170 0000D9C1 CD10                <1> 	INT 0x10
  1171                              <1> 
  1172 0000D9C3 89D0                <1> 	MOV AX, DX	  ;  Take remainder, divide by 100, repeat
  1173 0000D9C5 BA0000              <1> 	MOV DX, 0
  1174 0000D9C8 B96400              <1> 	MOV CX, 100
  1175 0000D9CB F7F1                <1> 	DIV CX
  1176 0000D9CD B40E                <1> 	MOV AH, 0x0E
  1177 0000D9CF 0C30                <1> 	OR AL, 0x30
  1178 0000D9D1 CD10                <1> 	INT 0x10
  1179                              <1> 
  1180 0000D9D3 89D0                <1> 	MOV AX, DX
  1181 0000D9D5 BA0000              <1> 	MOV DX, 0
  1182 0000D9D8 B90A00              <1> 	MOV CX, 10	  ;  Take remainder, divide by 10, repeat
  1183 0000D9DB F7F1                <1> 	DIV CX
  1184 0000D9DD B40E                <1> 	MOV AH, 0x0E
  1185 0000D9DF 0C30                <1> 	OR AL, 0x30
  1186 0000D9E1 CD10                <1> 	INT 0x10
  1187                              <1> 
  1188 0000D9E3 B40E                <1> 	MOV AH, 0x0E
  1189 0000D9E5 88D0                <1> 	MOV AL, DL	  ; Last remainder is a single digit.
  1190 0000D9E7 0C30                <1> 	OR AL, 0x30
  1191 0000D9E9 CD10                <1> 	INT 0x10
  1192 0000D9EB 80FB01              <1> 	CMP BL, 1
  1193 0000D9EE 7507                <1> 	JNE DISPLAY_M
  1194 0000D9F0 B8470E              <1> 	MOV AX, 0E47H	; Display "G"
  1195 0000D9F3 CD10                <1> 	INT 0x10
  1196 0000D9F5 EB05                <1> 	JMP LEAVE_SECTOR_DISPLAY
  1197                              <1> DISPLAY_M:
  1198 0000D9F7 B84D0E              <1> 	MOV AX, 0E4DH    ; Display "M"
  1199 0000D9FA CD10                <1> 	INT 0x10
  1200                              <1> 	
  1201                              <1> 
  1202                              <1> LEAVE_SECTOR_DISPLAY:
  1203                              <1>  
  1204 0000D9FC 5B                  <1> 	POP BX
  1205 0000D9FD 5A                  <1> 	POP DX
  1206 0000D9FE 59                  <1> 	POP CX
  1207 0000D9FF 58                  <1> 	POP AX
  1208 0000DA00 C3                  <1> 	RET
  1209                              <1> 
  1210                              <1> OVERSIZE_MESSAGE:
  1211 0000DA01 0D0A2A2A2A2A204E4F- <1> 	DB 0x0D, 0x0A, '**** NOTE: Device exceeds 504M limit and will be presented as 504M ****',0
  1211 0000DA0A 54453A204465766963- <1>
  1211 0000DA13 652065786365656473- <1>
  1211 0000DA1C 203530344D206C696D- <1>
  1211 0000DA25 697420616E64207769- <1>
  1211 0000DA2E 6C6C20626520707265- <1>
  1211 0000DA37 73656E746564206173- <1>
  1211 0000DA40 203530344D202A2A2A- <1>
  1211 0000DA49 2A00                <1>
  1212                              <1> END_OVERSIZE_MESSAGE:
  1213                              <1> 
  1214                              <1> BELOW_TABLE_SIZE_MESSAGE:
  1215 0000DA4B 0D0A44657669636520- <1> 	DB 0x0D, 0x0A, 'Device smaller than ROM parameter table.',0x0D, 0x0A,0
  1215 0000DA54 736D616C6C65722074- <1>
  1215 0000DA5D 68616E20524F4D2070- <1>
  1215 0000DA66 6172616D6574657220- <1>
  1215 0000DA6F 7461626C652E0D0A00  <1>
  1216 0000DA78 537567676573746564- <1>     DB 'Suggested cylinder count: 0x',0
  1216 0000DA81 2063796C696E646572- <1>
  1216 0000DA8A 20636F756E743A2030- <1>
  1216 0000DA93 7800                <1>
  1217                              <1> END_BELOW_TABLE_SIZE_MESSAGE:
  1218                              <1> 
  1219                              <1> AWAIT_INTERRUPT:
  1220 0000DA95 50                  <1> 	PUSH AX
  1221                              <1> INTERRUPT_LOOP:
  1222 0000DA96 E4E4                <1> 	IN AL, COMMAND_PORT				; Loop waiting for the interrupt
  1223 0000DA98 2480                <1> 	AND AL, 0x80
  1224 0000DA9A 75FA                <1> 	JNZ INTERRUPT_LOOP
  1225 0000DA9C 58                  <1> 	POP AX
  1226 0000DA9D C3                  <1> 	RET
  1227                              <1> 
  1228                              <1> ; Expects CX to have cylinder/sector and DH to have head number
  1229                              <1> ; Leaves sector count in DX:AX
  1230                              <1> 
  1231                              <1> CONVERT_CHS_TO_LBA:
  1232 0000DA9E 51                  <1> 	PUSH CX					;STORE CX / SECTOR NUMBER
  1233 0000DA9F 52                  <1> 	PUSH DX					;STORE DX / DH HEAD NUMBER
  1234                              <1> 
  1235 0000DAA0 88E8                <1> 	MOV AL, CH				;GET LOWER CYLINDER NUMBER
  1236 0000DAA2 D0E9                <1> 	SHR CL, 0X01			;SHIFT RIGHT 6 TIMES FOR UPPER 2 BITS CYLINDER
  1237 0000DAA4 D0E9                <1> 	SHR CL, 0X01			;
  1238 0000DAA6 D0E9                <1> 	SHR CL, 0X01			;
  1239 0000DAA8 D0E9                <1> 	SHR CL, 0X01			;	
  1240 0000DAAA D0E9                <1> 	SHR CL, 0X01			;
  1241 0000DAAC D0E9                <1> 	SHR CL, 0X01			;
  1242                              <1> 
  1243 0000DAAE 88CC                <1> 	MOV AH, CL				;AX HOLDS CYLINDER NUMBER			;
  1244 0000DAB0 B91000              <1> 	MOV CX, MAX_HPC			;NUMBER OF HEADS / SIDES (HPC)
  1245 0000DAB3 F7E1                <1> 	MUL CX					;AX = C X HPC
  1246 0000DAB5 59                  <1> 	POP CX					;GET HEAD NUMBER
  1247 0000DAB6 88E9                <1> 	MOV CL, CH				;MOV HEAD NUMBER
  1248 0000DAB8 B500                <1> 	MOV CH, 0X00			;CLEAR CH
  1249 0000DABA 01C8                <1> 	ADD AX, CX				;ADD IN HEAD (C X HPC + H)
  1250 0000DABC B93F00              <1> 	MOV CX, MAX_SPT			;SECTORS PER TRACK	
  1251 0000DABF F7E1                <1> 	MUL CX					;DX:AX (C X HPC + H) X SPT
  1252 0000DAC1 59                  <1> 	POP CX					;GET SECTOR NUMBER
  1253 0000DAC2 83E13F              <1> 	AND CX, 0X003F			;CLEAR OUT CYLINDER
  1254 0000DAC5 49                  <1> 	DEC CX					;(S - 1)
  1255 0000DAC6 01C8                <1> 	ADD AX, CX				;LBA = (C × HPC + H) × SPT + (S − 1)
  1256 0000DAC8 83D200              <1> 	ADC DX, 0X00			;IF THERE IS A CARRY POSIBLE I DONT KNOW
  1257 0000DACB C3                  <1> 	RET
  1258                              <1> 
  1259                              <1> ; Does the CH376S lookup and reads sector count into DX:AX
  1260                              <1> GET_CAPACITY:
  1261 0000DACC 53                  <1> 	PUSH BX
  1262 0000DACD B03E                <1>  	MOV AL, CH376S_DISK_CAPACITY	; Get Disc Capacity
  1263 0000DACF E6E4                <1>     OUT COMMAND_PORT, AL
  1264                              <1> 
  1265 0000DAD1 E8C1FF              <1> 	CALL AWAIT_INTERRUPT
  1266                              <1> 
  1267 0000DAD4 B027                <1> 	MOV AL, CH376S_RD_USB_DATA0 	; Read device data
  1268 0000DAD6 E6E4                <1>     OUT COMMAND_PORT, AL
  1269 0000DAD8 E4E0                <1> 	IN AL, DATA_PORT    			; count- should be four bytes
  1270 0000DADA E4E0                <1>     IN AL, DATA_PORT    			; lowest byte
  1271 0000DADC 88C3                <1> 	mov BL, AL
  1272 0000DADE E4E0                <1> 	IN AL, DATA_PORT    			; second lowest
  1273 0000DAE0 88C7                <1> 	MOV BH, AL
  1274 0000DAE2 53                  <1> 	PUSH BX
  1275 0000DAE3 E4E0                <1> 	IN AL, DATA_PORT				; third
  1276 0000DAE5 88C3                <1> 	MOV BL, AL
  1277 0000DAE7 E4E0                <1> 	IN AL, DATA_PORT				; fourth
  1278 0000DAE9 88C7                <1> 	MOV BH, AL
  1279 0000DAEB 53                  <1> 	PUSH BX
  1280                              <1> 
  1281 0000DAEC 5A                  <1> 	POP DX							; DX:AX now contains sector count.
  1282 0000DAED 58                  <1> 	POP AX
  1283 0000DAEE 5B                  <1> 	POP BX
  1284 0000DAEF C3                  <1> 	RET
  1285                              <1> 
  1286                              <1> END_OF_LINE:
  1287 0000DAF0 50                  <1> 	PUSH AX
  1288 0000DAF1 B80D0E              <1> 	MOV AX, 0x0E0D		; Print a newline
  1289 0000DAF4 CD10                <1>     INT 0x10
  1290 0000DAF6 B00A                <1>     MOV AL, 0x0A		; and line feed
  1291 0000DAF8 CD10                <1>     INT 0x10
  1292 0000DAFA 58                  <1> 	POP AX
  1293 0000DAFB C3                  <1> 	RET;
  1294                              <1> 
  1295                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1296                              <1> ;THIS LOADS THE MBR TO 0XF400:0000
  1297                              <1> ;LOADS THE VBR TO 0XF400:0200
  1298                              <1> ;USED BY INT 0X13 FOR CHS->LBA CALC	
  1299                              <1> ;THE VBR HAS THE DRIVE GEOMETRY AT 
  1300                              <1> ;0XF400:0X0218 DW SPT
  1301                              <1> ;0XF400:0X021A DW HPC
  1302                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1303                              <1> 
  1304                              <1> LOAD_BOOT_RECORD:
  1305                              <1> 	
  1306 0000DAFC 9C                  <1> 	PUSHF			;STORE FLAGS
  1307 0000DAFD FA                  <1> 	CLI				;
  1308 0000DAFE 50                  <1> 	PUSH AX			;STORE AX
  1309 0000DAFF 53                  <1> 	PUSH BX			;STORE BX
  1310 0000DB00 51                  <1> 	PUSH CX			;STORE CX
  1311 0000DB01 1E                  <1> 	PUSH DS			;STORE DS
  1312 0000DB02 B80014              <1> 	MOV AX, 0X1400	;
  1313 0000DB05 8ED8                <1> 	MOV DS, AX		;SET DS 0XF400 UPPER RAM
  1314 0000DB07 BB0000              <1> 	MOV BX, 0X0000	;SET BX 0 FOR INDEX
  1315                              <1> 					;READ MBR
  1316 0000DB0A B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1317 0000DB0C E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1318 0000DB0E B000                <1> 	MOV AL, 0X00	;LBA 0X00000000
  1319 0000DB10 E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1320 0000DB12 E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1321 0000DB14 E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1322 0000DB16 E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1323 0000DB18 B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1324 0000DB1A E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1325                              <1> 
  1326                              <1> .READ_MBR_SECTOR:
  1327 0000DB1C B9FF00              <1> 	MOV CX, 0X00FF		;DELAY 
  1328 0000DB1F E2FE                <1> 	DB 0XE2, 0XFE		;LOOP BACK
  1329                              <1> 	
  1330 0000DB21 B022                <1> 	MOV AL, 0X22		;GET_STATUS
  1331 0000DB23 E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1332 0000DB25 E4E0                <1> 	IN AL, 0XE0			;READ IN STATUS DATA PORT
  1333 0000DB27 3C14                <1> 	CMP AL, 0X14		;CHECK FOR USB_INT_SUCCESS COMPLETED READING
  1334 0000DB29 7474                <1> 	JE .READ_MBR_SUCCESS;IF USB_INT_SUCCESS
  1335 0000DB2B 3C1D                <1> 	CMP AL, 0X1D		;COMPARE TO USB_INT_DISK_READ
  1336 0000DB2D 7517                <1> 	JNE .NOT_1D			;IF NOT USB_INT_DISK_READ
  1337                              <1> 	
  1338 0000DB2F B027                <1> 	MOV AL, 0X27		;RD_USB_DATA0
  1339 0000DB31 E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1340 0000DB33 E4E0                <1> 	IN AL, 0XE0			;READ NUMBER OF BYTES FROM DATA PORT 
  1341 0000DB35 B400                <1> 	MOV AH, 0X00		;CLEAR AH
  1342 0000DB37 89C1                <1> 	MOV CX, AX			;SET CX TO NUMBER OF BYTES
  1343                              <1> .READ_MBR_LOOP:			;LOOP LABLE
  1344 0000DB39 E4E0                <1> 	IN AL, 0XE0			;READ BYTE
  1345 0000DB3B 8807                <1> 	MOV [BX], AL		;WRITE BYTE TO DS:BX
  1346 0000DB3D 43                  <1> 	INC BX				;INC INDEX
  1347 0000DB3E E2F9                <1> 	LOOP .READ_MBR_LOOP	;LOOP UNTIL DONE
  1348                              <1> 	
  1349 0000DB40 B055                <1> 	MOV AL, 0X55		;DISK_RD_GO READ NEXT 64 BYTES
  1350 0000DB42 E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1351 0000DB44 EBD6                <1> 	JMP .READ_MBR_SECTOR;LOOP UNTIL DONE
  1352                              <1> 
  1353                              <1> .NOT_1D:
  1354 0000DB46 E8B71D              <1> 	CALL WRITE_AL_INT10_E			;PRINTS ERROR NUMBER TO SCREEN	
  1355 0000DB49 8CC8                <1> 	MOV AX, CS						;GET CS 
  1356 0000DB4B 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
  1357 0000DB4D B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
  1358 0000DB4F B91200              <1> 	MOV CX, .END_READ_ERROR_MESSAGE - .READ_ERROR_MESSAGE
  1359 0000DB52 BB[5FDB]            <1> 	MOV BX, .READ_ERROR_MESSAGE	
  1360                              <1> 	.LOOP_NOT_1D:
  1361 0000DB55 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
  1362 0000DB57 CD10                <1> 	INT 0X10						;PRINT TO SCREEN
  1363 0000DB59 43                  <1> 	INC BX							;INC BX
  1364 0000DB5A E2F9                <1> 	LOOP .LOOP_NOT_1D				;LOOP UNTIL DONE
  1365                              <1> 	
  1366 0000DB5C E99301              <1> 	JMP .END_LOAD_BOOT_RECORD
  1367                              <1> 
  1368                              <1> 	.READ_ERROR_MESSAGE:
  1369 0000DB5F 205553422052454144- <1> 	DB ' USB READ ERR0R', 0X0D, 0X0A,0
  1369 0000DB68 2045525230520D0A00  <1>
  1370                              <1> 	.END_READ_ERROR_MESSAGE:
  1371                              <1> 	
  1372                              <1> .NOT_BOOTABLE_MBR:
  1373 0000DB71 8CC8                <1> 	MOV AX, CS						;GET CS 
  1374 0000DB73 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
  1375 0000DB75 B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
  1376 0000DB77 B91800              <1> 	MOV CX, .END_NOT_MBR_MESSAGE - .NOT_MBR_MESSAGE
  1377 0000DB7A BB[87DB]            <1> 	MOV BX, .NOT_MBR_MESSAGE
  1378                              <1>     .LOOP_NOT_MBR:	
  1379 0000DB7D 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
  1380 0000DB7F CD10                <1> 	INT 0X10						;PRINT TO SCREEN
  1381 0000DB81 43                  <1> 	INC BX							;INC BX
  1382 0000DB82 E2F9                <1> 	LOOP .LOOP_NOT_MBR				;LOOP UNTIL DONE
  1383                              <1> 	
  1384 0000DB84 E96B01              <1> 	JMP .END_LOAD_BOOT_RECORD
  1385                              <1> 
  1386                              <1> 	.NOT_MBR_MESSAGE:
  1387 0000DB87 4E4F20424F4F542053- <1> 	DB 'NO BOOT SIGNATURE MBR', 0X0D, 0X0A,0
  1387 0000DB90 49474E415455524520- <1>
  1387 0000DB99 4D42520D0A00        <1>
  1388                              <1> 	.END_NOT_MBR_MESSAGE:
  1389                              <1> 	
  1390                              <1> .READ_MBR_SUCCESS:
  1391 0000DB9F BBFE01              <1> 	MOV BX, 0X01FE			;END OF MBR DS ST ILL IS 0XF400
  1392 0000DBA2 813F55AA            <1> 	CMP WORD [BX], 0XAA55	;BOOT SIGNATURE DS:BX
  1393 0000DBA6 75C9                <1> 	JNE .NOT_BOOTABLE_MBR	;IF BOOT SIGNATURE IS NOT THERE
  1394                              <1> 	
  1395 0000DBA8 E89F1D              <1> 	CALL WAIT_8			;DELAY NEEDED BEFORE READING THE NEXT SECTOR 
  1396                              <1> 			
  1397                              <1> 	
  1398 0000DBAB BBBE01              <1> 	MOV BX, 0X01BE			;FIRST PARTITION ENTRY 
  1399 0000DBAE 803F80              <1> 	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
  1400 0000DBB1 741B                <1> 	JE .BOOT_FIRST_ENTRY	;
  1401 0000DBB3 BBCE01              <1> 	MOV BX, 0X01CE			;SECOND PARTITION ENTRY 
  1402 0000DBB6 803F80              <1> 	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
  1403 0000DBB9 7437                <1> 	JE .BOOT_SECOND_ENTRY	;
  1404 0000DBBB BBDE01              <1> 	MOV BX, 0X01DE			;THRID PARTITION ENTRY 
  1405 0000DBBE 803F80              <1> 	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
  1406 0000DBC1 7453                <1> 	JE .BOOT_THIRD_ENTRY	;
  1407 0000DBC3 BBEE01              <1> 	MOV BX, 0X01EE			;FORTH PARTITION ENTRY 
  1408 0000DBC6 803F80              <1> 	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
  1409 0000DBC9 746F                <1> 	JE .BOOT_FORTH_ENTRY	;
  1410 0000DBCB E9F500              <1> 	JMP .NO_BOOTABLE_PARTITION
  1411                              <1> 	
  1412                              <1> .BOOT_FIRST_ENTRY:	
  1413 0000DBCE B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1414 0000DBD0 E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1415 0000DBD2 BBC601              <1> 	MOV BX, 0X01C6	;PARTITION LBA START LOCATION
  1416 0000DBD5 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1417 0000DBD7 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1418 0000DBD9 43                  <1> 	INC BX			;NEXT BYTE
  1419 0000DBDA 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1420 0000DBDC E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1421 0000DBDE 43                  <1> 	INC BX			;NEXT BYTE
  1422 0000DBDF 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1423 0000DBE1 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1424 0000DBE3 43                  <1> 	INC BX			;NEXT BYTE
  1425 0000DBE4 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1426 0000DBE6 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1427 0000DBE8 43                  <1> 	INC BX			;NEXT BYTE
  1428 0000DBE9 B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1429 0000DBEB E6E0                <1> 	OUT 0XE0, AL
  1430 0000DBED BB0002              <1> 	MOV BX, 0X0200	;SET BX 200 FOR INDEX
  1431 0000DBF0 EB6C                <1> 	JMP .READ_VBR_SECTOR
  1432                              <1> .BOOT_SECOND_ENTRY:
  1433 0000DBF2 B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1434 0000DBF4 E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1435 0000DBF6 BBD601              <1> 	MOV BX, 0X01D6	;PARTITION LBA START LOCATION
  1436 0000DBF9 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1437 0000DBFB E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1438 0000DBFD 43                  <1> 	INC BX			;NEXT BYTE
  1439 0000DBFE 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1440 0000DC00 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1441 0000DC02 43                  <1> 	INC BX			;NEXT BYTE
  1442 0000DC03 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1443 0000DC05 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1444 0000DC07 43                  <1> 	INC BX			;NEXT BYTE
  1445 0000DC08 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1446 0000DC0A E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1447 0000DC0C 43                  <1> 	INC BX			;NEXT BYTE
  1448 0000DC0D B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1449 0000DC0F E6E0                <1> 	OUT 0XE0, AL
  1450 0000DC11 BB0002              <1> 	MOV BX, 0X0200	;SET BX 200 FOR INDEX
  1451 0000DC14 EB48                <1> 	JMP .READ_VBR_SECTOR
  1452                              <1> .BOOT_THIRD_ENTRY:
  1453 0000DC16 B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1454 0000DC18 E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1455 0000DC1A BBE601              <1> 	MOV BX, 0X01E6	;PARTITION LBA START LOCATION
  1456 0000DC1D 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1457 0000DC1F E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1458 0000DC21 43                  <1> 	INC BX			;NEXT BYTE
  1459 0000DC22 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1460 0000DC24 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1461 0000DC26 43                  <1> 	INC BX			;NEXT BYTE
  1462 0000DC27 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1463 0000DC29 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1464 0000DC2B 43                  <1> 	INC BX			;NEXT BYTE
  1465 0000DC2C 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1466 0000DC2E E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1467 0000DC30 43                  <1> 	INC BX			;NEXT BYTE
  1468 0000DC31 B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1469 0000DC33 E6E0                <1> 	OUT 0XE0, AL
  1470 0000DC35 BB0002              <1> 	MOV BX, 0X0200	;SET BX 200 FOR INDEX
  1471 0000DC38 EB24                <1> 	JMP .READ_VBR_SECTOR
  1472                              <1> .BOOT_FORTH_ENTRY:
  1473 0000DC3A B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1474 0000DC3C E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1475 0000DC3E BBF601              <1> 	MOV BX, 0X01F6	;PARTITION LBA START LOCATION
  1476 0000DC41 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1477 0000DC43 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1478 0000DC45 43                  <1> 	INC BX			;NEXT BYTE
  1479 0000DC46 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1480 0000DC48 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1481 0000DC4A 43                  <1> 	INC BX			;NEXT BYTE
  1482 0000DC4B 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1483 0000DC4D E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1484 0000DC4F 43                  <1> 	INC BX			;NEXT BYTE
  1485 0000DC50 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1486 0000DC52 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1487 0000DC54 43                  <1> 	INC BX			;NEXT BYTE
  1488 0000DC55 B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1489 0000DC57 E6E0                <1> 	OUT 0XE0, AL
  1490 0000DC59 BB0002              <1> 	MOV BX, 0X0200	;SET BX 200 FOR INDEX
  1491 0000DC5C EB00                <1> 	JMP .READ_VBR_SECTOR
  1492                              <1> 	
  1493                              <1> .READ_VBR_SECTOR:
  1494 0000DC5E B9FF00              <1> 	MOV CX, 0X00FF		;DELAY 
  1495 0000DC61 E2FE                <1> 	DB 0XE2, 0XFE		;LOOP BACK
  1496                              <1> 	
  1497 0000DC63 B022                <1> 	MOV AL, 0X22		;GET_STATUS
  1498 0000DC65 E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1499 0000DC67 E4E0                <1> 	IN AL, 0XE0			;READ IN STATUS DATA PORT
  1500 0000DC69 3C14                <1> 	CMP AL, 0X14		;CHECK FOR USB_INT_SUCCESS COMPLETED READING
  1501 0000DC6B 741E                <1> 	JE .READ_VBR_SUCCESS;IF USB_INT_SUCCESS
  1502 0000DC6D 3C1D                <1> 	CMP AL, 0X1D		;COMPARE TO USB_INT_DISK_READ
  1503 0000DC6F 7403E9D2FE          <1> 	JNE .NOT_1D			;IF NOT USB_INT_DISK_READ
  1504                              <1> 	
  1505 0000DC74 B027                <1> 	MOV AL, 0X27		;RD_USB_DATA0
  1506 0000DC76 E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1507 0000DC78 E4E0                <1> 	IN AL, 0XE0			;READ NUMBER OF BYTES FROM DATA PORT 
  1508 0000DC7A B400                <1> 	MOV AH, 0X00		;CLEAR AH
  1509 0000DC7C 89C1                <1> 	MOV CX, AX			;SET CX TO NUMBER OF BYTES
  1510                              <1>   .READ_VBR_LOOP:		;LOOP LABLE
  1511 0000DC7E E4E0                <1> 	IN AL, 0XE0			;READ BYTE
  1512 0000DC80 8807                <1> 	MOV [BX], AL		;WRITE BYTE TO DS:BX
  1513 0000DC82 43                  <1> 	INC BX				;INC INDEX
  1514                              <1> 
  1515 0000DC83 E2F9                <1> 	LOOP .READ_VBR_LOOP	;LOOP UNTIL DONE
  1516                              <1> 	
  1517 0000DC85 B055                <1> 	MOV AL, 0X55		;DISK_RD_GO READ NEXT 64 BYTES
  1518 0000DC87 E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1519 0000DC89 EBD3                <1> 	JMP .READ_VBR_SECTOR	;LOOP UNTIL DONE
  1520                              <1> 
  1521                              <1> .READ_VBR_SUCCESS:
  1522 0000DC8B BBFE01              <1> 	MOV BX, 0X01FE			;END OF MBR
  1523 0000DC8E 813F55AA            <1> 	CMP WORD [BX], 0XAA55	;BOOT SIGNATURE
  1524 0000DC92 7502                <1> 	JNE .NOT_BOOTABLE_VBR 	;IF BOOT SIGNATURE IS NOT THERE
  1525                              <1> 	
  1526 0000DC94 EB5C                <1> 	JMP .END_LOAD_BOOT_RECORD	
  1527                              <1> 	
  1528                              <1> .NOT_BOOTABLE_VBR:
  1529 0000DC96 8CC8                <1> 	MOV AX, CS						;GET CS 
  1530 0000DC98 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
  1531 0000DC9A B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
  1532 0000DC9C B91800              <1> 	MOV CX, .END_NOT_VBR_MESSAGE - .NOT_VBR_MESSAGE
  1533 0000DC9F BB[ABDC]            <1> 	MOV BX, .NOT_VBR_MESSAGE	
  1534                              <1> 	.LOOP_NOT_VBR:
  1535 0000DCA2 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
  1536 0000DCA4 CD10                <1> 	INT 0X10						;PRINT TO SCREEN
  1537 0000DCA6 43                  <1> 	INC BX							;INC BX
  1538 0000DCA7 E2F9                <1> 	LOOP .LOOP_NOT_VBR				;LOOP UNTIL DONE
  1539                              <1> 	
  1540 0000DCA9 EB47                <1> 	JMP .END_LOAD_BOOT_RECORD
  1541                              <1> 
  1542                              <1> 	.NOT_VBR_MESSAGE:
  1543 0000DCAB 4E4F20424F4F542053- <1> 	DB 'NO BOOT SIGNATURE VBR', 0X0D, 0X0A,0
  1543 0000DCB4 49474E415455524520- <1>
  1543 0000DCBD 5642520D0A00        <1>
  1544                              <1> 	.END_NOT_VBR_MESSAGE:
  1545                              <1> 
  1546                              <1> .NO_BOOTABLE_PARTITION:
  1547 0000DCC3 8CC8                <1> 	MOV AX, CS						;GET CS 
  1548 0000DCC5 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
  1549 0000DCC7 B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
  1550 0000DCC9 B91A00              <1> 	MOV CX, .END_NO_BOOTABLE_PARTITION_MESSAGE - .NO_BOOTABLE_PARTITION_MESSAGE
  1551 0000DCCC BB[D8DC]            <1> 	MOV BX, .NO_BOOTABLE_PARTITION_MESSAGE	
  1552                              <1> 	.LOOP_NO_BOOT_PARTITION:
  1553 0000DCCF 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
  1554 0000DCD1 CD10                <1> 	INT 0X10						;PRINT TO SCREEN
  1555 0000DCD3 43                  <1> 	INC BX							;INC BX
  1556 0000DCD4 E2F9                <1> 	LOOP .LOOP_NO_BOOT_PARTITION	;LOOP UNTIL DONE
  1557                              <1> 	
  1558 0000DCD6 EB1A                <1> 	JMP .END_LOAD_BOOT_RECORD
  1559                              <1> 
  1560                              <1> 	.NO_BOOTABLE_PARTITION_MESSAGE:
  1561 0000DCD8 4E4F20424F4F542050- <1> 	DB 'NO BOOT PARTITION FOUND', 0X0D, 0X0A,0
  1561 0000DCE1 4152544954494F4E20- <1>
  1561 0000DCEA 464F554E440D0A00    <1>
  1562                              <1> 	.END_NO_BOOTABLE_PARTITION_MESSAGE:
  1563                              <1> 
  1564                              <1> .END_LOAD_BOOT_RECORD:
  1565 0000DCF2 BE[FEDC]            <1> 	mov si, loadedMsg
  1566 0000DCF5 E885F5              <1> 	call	pstr
  1567 0000DCF8 1F                  <1> 	POP DS	;RESTORE DS
  1568 0000DCF9 59                  <1> 	POP CX	;RESTORE CX
  1569 0000DCFA 5B                  <1> 	POP BX 	;RESTORE BX
  1570 0000DCFB 58                  <1> 	POP AX	;RESTORE AX
  1571 0000DCFC 9D                  <1> 	POPF	;RESTORE FLAGS
  1572 0000DCFD C3                  <1> 	RET		;RETURN NOT A INT
  1573                              <1> 
  1574 0000DCFE 426F6F742053656374- <1> loadedMsg	DB 'Boot Sector loaded...', 0X0D, 0X0A,0
  1574 0000DD07 6F72206C6F61646564- <1>
  1574 0000DD10 2E2E2E0D0A00        <1>
  1575                              <1> 
  1576                              <1> ; This is a cheat:  We put in the disc as the maximum specs we support, if anyone reads this vector
  1577                              <1> ; it assumes a 504Mb drive.  Given that even dirt-cheap bulk drives are multiple gigabytes and we ignore most of it
  1578                              <1> ; people using actual small drives may want to edit this to match the actual cylinder count.
  1579                              <1> ; Since this is just a passive storage in memory, unlike int 0x13, function 8, we can't just calculate it on the fly
  1580                              <1> ; unless we wanted to write it into RAM on boot.  We could locate it somewhere in the F0000 block but then we lose the
  1581                              <1> ; "doesn't need to reserve any RAM for housekeeping" factor
  1582                              <1> DISK_1_TABLE:
  1583 0000DD16 0004                <1> 	dw MAX_CYL  ; Cylinders
  1584 0000DD18 1000                <1> 	dw MAX_HPC  ; Heads
  1585 0000DD1A 0000                <1> 	dw 0        ; Starts reduced write current cylinder
  1586 0000DD1C 0000                <1> 	dw 0		; Write precomp cylinder number
  1587 0000DD1E 00                  <1> 	db 0		; Max ECC Burst Length
  1588 0000DD1F 40                  <1> 	db 40h		; Control byte: Disable ECC retries, leave access retries, drive step speed 3ms
  1589 0000DD20 00                  <1> 	db 0		; Standard Timeout
  1590 0000DD21 00                  <1> 	db 0		; Formatting Timeout
  1591 0000DD22 0000                <1> 	dw 0		; Landing Zone
  1592 0000DD24 3F                  <1> 	db MAX_SPT	; Sectors per track
  1593 0000DD25 00                  <1> 	db 0		; reserved
  1594                              <1> 
  1595                              <1> DISK_2_TABLE:
  1596 0000DD26 0000                <1> 	dw 0		; Cylinders
  1597 0000DD28 0000                <1> 	dw 0  		; Heads
  1598 0000DD2A 0000                <1> 	dw 0        ; Starts reduced write current cylinder
  1599 0000DD2C 0000                <1> 	dw 0		; Write precomp cylinder number
  1600 0000DD2E 00                  <1> 	db 0		; Max ECC Burst Length
  1601 0000DD2F 00                  <1> 	db 00h		; Control byte: Disable ECC retries, leave access retries, drive step speed 3ms
  1602 0000DD30 00                  <1> 	db 0		; Standard Timeout
  1603 0000DD31 00                  <1> 	db 0		; Formatting Timeout
  1604 0000DD32 0000                <1> 	dw 0		; Landing Zone
  1605 0000DD34 00                  <1> 	db 0		; Sectors per track
  1606 0000DD35 00                  <1> 	db 0		; reserved
  1607                              <1>     
   265                                  ;%include "DRVch376s2.asm"
   266                                  
   267                                  %include "screen.asm"
     1                              <1> 
     2 0000DD36 1B5B324A00          <1> cls     db 0x1B,"[2J",0
     3 0000DD3B 1B5B213B214800      <1> curpos  db 0x1B,"[!;!H",0
     4                              <1> 
     5                              <1> ;=====================
     6                              <1> ; ESC [ 2 J
     7                              <1> ;
     8                              <1> scr_clear:
     9 0000DD42 BE[36DD]            <1>         mov	si, cls
    10 0000DD45 E835F5              <1>         call    pstr	
    11 0000DD48 C3                  <1>         ret
    12                              <1> ;=====================
    13                              <1> ; ESC [ Pl ; Pc H
    14                              <1> ; input:
    15                              <1> ;	dh = y position
    16                              <1> ; 	dl = x position
    17                              <1> ; MARK: scr_goto
    18                              <1> scr_goto:
    19 0000DD49 1E                  <1>         push DS
    20 0000DD4A B80000              <1>         mov AX, 0x0
    21 0000DD4D 8ED8                <1>         mov DS, AX
    22 0000DD4F 89C3                <1>         mov bx, AX
    23 0000DD51 3EC6071B            <1>         mov byte ds:[bx],0x1B
    24 0000DD55 43                  <1>         inc bx
    25 0000DD56 3EC6075B            <1>         mov byte ds:[bx],'['
    26 0000DD5A 43                  <1>         inc bx
    27 0000DD5B 3EC6070A            <1>         mov byte ds:[bx],10
    28 0000DD5F 43                  <1>         inc bx
    29 0000DD60 3EC6073B            <1>         mov byte ds:[bx],';'
    30 0000DD64 43                  <1>         inc bx
    31 0000DD65 3EC6070A            <1>         mov byte ds:[bx],10
    32 0000DD69 43                  <1>         inc bx
    33 0000DD6A 3EC60748            <1>         mov byte ds:[bx],'H'  
    34 0000DD6E 43                  <1>         inc bx
    35 0000DD6F 3EC60700            <1>         mov byte ds:[bx],0x0
    36                              <1> 
    37                              <1> 
    38 0000DD73 B80000              <1>         mov AX, 0x0
    39 0000DD76 89C6                <1>         mov si, AX
    40 0000DD78 E802F5              <1>         call pstr
    41 0000DD7B 1F                  <1>         POP DS
    42 0000DD7C C3                  <1> 		ret
    43                              <1> 
    44 0000DD7D 666E30300D00        <1> s123 db "fn00",0dh,0
    45 0000DD83 666E30310D00        <1> s124 db "fn01",0dh,0
    46 0000DD89 666E30320D00        <1> s125 db "fn02",0dh,0
    47 0000DD8F 666E30330D00        <1> s126 db "fn03",0dh,0
    48 0000DD95 666E30340D00        <1> s127 db "fn04",0dh,0
    49 0000DD9B 666E30350D00        <1> s128 db "fn05",0dh,0
    50                              <1> 
    51                              <1> TESTE:
    52 0000DDA1 E8FAF4              <1>         call cout
    53                              <1> 
    54 0000DDA4 3C30                <1>         cmp   al, '0'
    55 0000DDA6 7415                <1>         jz    .fn00
    56 0000DDA8 3C31                <1>         cmp   al, '1'
    57 0000DDAA 7418                <1>         jz    .fn01
    58 0000DDAC 3C32                <1>         cmp   al, '2'
    59 0000DDAE 741B                <1>         jz    .fn02
    60 0000DDB0 3C33                <1>         cmp   al, '3'
    61 0000DDB2 741E                <1>         jz    .fn03
    62 0000DDB4 3C34                <1>         cmp   al, '4'
    63 0000DDB6 7421                <1>         jz    .fn04
    64 0000DDB8 3C35                <1>         cmp   al, '5'
    65 0000DDBA 7424                <1>         jz    .fn05
    66 0000DDBC C3                  <1>         ret        
    67                              <1> 
    68                              <1> .fn00: 
    69 0000DDBD BE[7DDD]            <1>         mov  si, s123
    70 0000DDC0 E8BAF4              <1>         call pstr
    71 0000DDC3 C3                  <1>         ret
    72                              <1> .fn01: 
    73 0000DDC4 BE[83DD]            <1>         mov  si, s124
    74 0000DDC7 E8B3F4              <1>         call pstr
    75 0000DDCA C3                  <1>         ret        
    76                              <1> .fn02: 
    77 0000DDCB BE[89DD]            <1>         mov  si, s125
    78 0000DDCE E8ACF4              <1>         call pstr
    79 0000DDD1 C3                  <1>         ret
    80                              <1> .fn03: 
    81 0000DDD2 BE[8FDD]            <1>         mov  si, s126
    82 0000DDD5 E8A5F4              <1>         call pstr
    83 0000DDD8 C3                  <1>         ret
    84                              <1> .fn04:   
    85 0000DDD9 BE[95DD]            <1>         mov  si, s127
    86 0000DDDC E89EF4              <1>         call pstr
    87 0000DDDF C3                  <1>         ret
    88                              <1> .fn05: 
    89 0000DDE0 BE[9BDD]            <1>         mov  si, s128
    90 0000DDE3 E897F4              <1>         call pstr
    91 0000DDE6 C3                  <1>         ret
    92                              <1> 
    93                              <1>         
    94                              <1> 
    95                              <1> 
   268                                  %include "errorLed.asm"
     1                              <1> 
     2                              <1> ledblinkOk:
     3                              <1> .loop0:
     4                              <1>           
     5 0000DDE7 B001                <1>                 mov     al, 0x01
     6 0000DDE9 E680                <1>                 out     0x80, al
     7 0000DDEB B9FF3F              <1>                 mov     cx, 0x3fff
     8                              <1> .label01:
     9 0000DDEE 49                  <1>                 dec     cx
    10 0000DDEF 75FD                <1>                 jnz     .label01
    11 0000DDF1 B000                <1>                 mov     al, 0x00
    12 0000DDF3 E680                <1>                 out     0x80, al
    13 0000DDF5 B9FF7F              <1>                 mov     cx, 0x7fff
    14                              <1> .label02:
    15 0000DDF8 49                  <1>                 dec     cx
    16 0000DDF9 75FD                <1>                 jnz     .label02
    17 0000DDFB C3                  <1>                 ret      
    18                              <1> 
    19                              <1> led2blinks:
    20                              <1> .loop0:
    21 0000DDFC BB0300              <1>                 mov     bx, 3
    22                              <1> .loop:            
    23 0000DDFF B001                <1>                 mov     al, 0x01
    24 0000DE01 E680                <1>                 out     0x80, al
    25 0000DE03 B9FFFF              <1>                 mov     cx, 0xffff
    26                              <1> .label01:
    27 0000DE06 49                  <1>                 dec     cx
    28 0000DE07 75FD                <1>                 jnz     .label01
    29 0000DE09 B000                <1>                 mov     al, 0x00
    30 0000DE0B E680                <1>                 out     0x80, al
    31 0000DE0D B9FFFF              <1>                 mov     cx, 0xffff
    32                              <1> .label02:
    33 0000DE10 49                  <1>                 dec     cx
    34 0000DE11 75FD                <1>                 jnz     .label02
    35                              <1> 
    36 0000DE13 4B                  <1>                 dec     bx
    37 0000DE14 75E9                <1>                 jnz     .loop
    38                              <1> ;                mov     al, 0x01
    39                              <1> ;                out     0x80, al
    40                              <1>                 
    41 0000DE16 BB0500              <1>                 mov     bx, 5
    42                              <1> .longDelay:                
    43 0000DE19 B9FFFF              <1>                 mov     cx, 0xffff
    44                              <1> .labelLD:
    45 0000DE1C 49                  <1>                 dec     cx
    46 0000DE1D 75FD                <1>                 jnz     .labelLD
    47 0000DE1F 4B                  <1>                 dec     bx
    48 0000DE20 75F7                <1>                 jnz     .longDelay
    49                              <1>                 ;mov     bx, 3 
    50 0000DE22 EBD8                <1>                 jmp     .loop0         
    51                              <1> 
    52                              <1> led3blinks:
    53                              <1> .loop0:
    54 0000DE24 BB0300              <1>                 mov     bx, 3
    55                              <1> .loop:            
    56 0000DE27 B001                <1>                 mov     al, 0x01
    57 0000DE29 E680                <1>                 out     0x80, al
    58 0000DE2B B9FFFF              <1>                 mov     cx, 0xffff
    59                              <1> .label01:
    60 0000DE2E 49                  <1>                 dec     cx
    61 0000DE2F 75FD                <1>                 jnz     .label01
    62 0000DE31 B000                <1>                 mov     al, 0x00
    63 0000DE33 E680                <1>                 out     0x80, al
    64 0000DE35 B9FFFF              <1>                 mov     cx, 0xffff
    65                              <1> .label02:
    66 0000DE38 49                  <1>                 dec     cx
    67 0000DE39 75FD                <1>                 jnz     .label02
    68                              <1> 
    69 0000DE3B 4B                  <1>                 dec     bx
    70 0000DE3C 75E9                <1>                 jnz     .loop
    71                              <1> ;                mov     al, 0x01
    72                              <1> ;                out     0x80, al
    73                              <1>                 
    74 0000DE3E BB0500              <1>                 mov     bx, 5
    75                              <1> .longDelay:                
    76 0000DE41 B9FFFF              <1>                 mov     cx, 0xffff
    77                              <1> .labelLD:
    78 0000DE44 49                  <1>                 dec     cx
    79 0000DE45 75FD                <1>                 jnz     .labelLD
    80 0000DE47 4B                  <1>                 dec     bx
    81 0000DE48 75F7                <1>                 jnz     .longDelay
    82                              <1>                 ;mov     bx, 3 
    83 0000DE4A EBD8                <1>                 jmp     .loop0         
    84                              <1> 
    85                              <1> led4blinks:
    86                              <1> .loop0:
    87 0000DE4C BB0400              <1>                 mov     bx, 4
    88                              <1> .loop:            
    89 0000DE4F B001                <1>                 mov     al, 0x01
    90 0000DE51 E680                <1>                 out     0x80, al
    91 0000DE53 B9FFFF              <1>                 mov     cx, 0xffff
    92                              <1> .label01:
    93 0000DE56 49                  <1>                 dec     cx
    94 0000DE57 75FD                <1>                 jnz     .label01
    95 0000DE59 B000                <1>                 mov     al, 0x00
    96 0000DE5B E680                <1>                 out     0x80, al
    97 0000DE5D B9FFFF              <1>                 mov     cx, 0xffff
    98                              <1> .label02:
    99 0000DE60 49                  <1>                 dec     cx
   100 0000DE61 75FD                <1>                 jnz     .label02
   101                              <1> 
   102 0000DE63 4B                  <1>                 dec     bx
   103 0000DE64 75E9                <1>                 jnz     .loop
   104                              <1> ;                mov     al, 0x01
   105                              <1> ;                out     0x80, al
   106                              <1>                 
   107 0000DE66 BB0500              <1>                 mov     bx, 5
   108                              <1> .longDelay:                
   109 0000DE69 B9FFFF              <1>                 mov     cx, 0xffff
   110                              <1> .labelLD:
   111 0000DE6C 49                  <1>                 dec     cx
   112 0000DE6D 75FD                <1>                 jnz     .labelLD
   113 0000DE6F 4B                  <1>                 dec     bx
   114 0000DE70 75F7                <1>                 jnz     .longDelay
   115                              <1>                 ;mov     bx, 3 
   116 0000DE72 EBD8                <1>                 jmp     .loop0         
   269                                  %include "testSram.asm"
     1                              <1> ;-------------------------------------------------------------------------
     2                              <1> %define MIN_RAM_SIZE    64              ; At least 32 KiB to boot the system
     3 0000DE74 0D0A54657374696E67- <1> testMem:        db      0Dh,0Ah,"Testing memory:",0Dh , 0
     3 0000DE7D 206D656D6F72793A0D- <1>
     3 0000DE86 00                  <1>
     4 0000DE87 0D0A31303030302074- <1> bloco01:        db      0Dh,0Ah,"10000 to 1FFFF", 0     ;128k
     4 0000DE90 6F20314646464600    <1>
     5 0000DE98 0D0A32303030302074- <1> bloco02:        db      0Dh,0Ah,"20000 to 2FFFF", 0     ;192k
     5 0000DEA1 6F20324646464600    <1>
     6 0000DEA9 0D0A33303030302074- <1> bloco03:        db      0Dh,0Ah,"30000 to 3FFFF", 0     ;256k
     6 0000DEB2 6F20334646464600    <1>
     7 0000DEBA 0D0A34303030302074- <1> bloco04:        db      0Dh,0Ah,"40000 to 4FFFF", 0     ;320k
     7 0000DEC3 6F20344646464600    <1>
     8 0000DECB 0D0A35303030302074- <1> bloco05:        db      0Dh,0Ah,"50000 to 5FFFF", 0     ;384k
     8 0000DED4 6F20354646464600    <1>
     9 0000DEDC 0D0A36303030302074- <1> bloco06:        db      0Dh,0Ah,"60000 to 6FFFF", 0     ;448k
     9 0000DEE5 6F20364646464600    <1>
    10 0000DEED 0D0A37303030302074- <1> bloco07:        db      0Dh,0Ah,"70000 to 7FFFF", 0     ;512k
    10 0000DEF6 6F20374646464600    <1>
    11 0000DEFE 0D0A38303030302074- <1> bloco08:        db      0Dh,0Ah,"80000 to 8FFFF", 0     ;640k
    11 0000DF07 6F20384646464600    <1>
    12 0000DF0F 0D0A39303030302074- <1> bloco09:        db      0Dh,0Ah,"90000 to 9FFFF", 0     ;768k
    12 0000DF18 6F20394646464600    <1>
    13                              <1> 
    14                              <1> 
    15 0000DF20 207365676D656E7420- <1> blocoOK:        db      " segment OK",0
    15 0000DF29 4F4B00              <1>
    16 0000DF2C 207365676D656E7420- <1> blocoNOK:       db      " segment NOT exists", 0Dh, 0Ah,0
    16 0000DF35 4E4F54206578697374- <1>
    16 0000DF3E 730D0A00            <1>
    17 0000DF42 0D0A546F74616C206F- <1> totalMem:       db      0Dh,0Ah,"Total of memory: ",0
    17 0000DF4B 66206D656D6F72793A- <1>
    17 0000DF54 2000                <1>
    18 0000DF56 3036342E303030204B- <1> qtdMem0:        db      "064.000 KBytes.", 0Dh, 0Ah, 0
    18 0000DF5F 42797465732E0D0A00  <1>
    19 0000DF68 3133312E303732204B- <1> qtdMem1:        db      "131.072 KBytes.", 0Dh, 0Ah, 0
    19 0000DF71 42797465732E0D0A00  <1>
    20 0000DF7A 3139362E363038204B- <1> qtdMem2:        db      "196.608 KBytes.", 0Dh, 0Ah, 0
    20 0000DF83 42797465732E0D0A00  <1>
    21 0000DF8C 3236322E313434204B- <1> qtdMem3:        db      "262.144 KBytes.", 0Dh, 0Ah, 0
    21 0000DF95 42797465732E0D0A00  <1>
    22 0000DF9E 3332372E363830204B- <1> qtdMem4:        db      "327.680 KBytes.", 0Dh, 0Ah, 0
    22 0000DFA7 42797465732E0D0A00  <1>
    23 0000DFB0 3339332E323136204B- <1> qtdMem5:        db      "393.216 KBytes.", 0Dh, 0Ah, 0
    23 0000DFB9 42797465732E0D0A00  <1>
    24 0000DFC2 3435382E373532204B- <1> qtdMem6:        db      "458.752 KBytes.", 0Dh, 0Ah, 0
    24 0000DFCB 42797465732E0D0A00  <1>
    25 0000DFD4 3532342E323838204B- <1> qtdMem7:        db      "524.288 KBytes.", 0Dh, 0Ah, 0
    25 0000DFDD 42797465732E0D0A00  <1>
    26 0000DFE6 3635352E333630204B- <1> qtdMem8:        db      "655.360 KBytes.", 0Dh, 0Ah, 0
    26 0000DFEF 42797465732E0D0A00  <1>
    27 0000DFF8 3738362E343332204B- <1> qtdMem9:        db      "786.432 KBytes.", 0Dh, 0Ah, 0
    27 0000E001 42797465732E0D0A00  <1>
    28                              <1> 
    29                              <1> 
    30                              <1> ;-------------------------------------------------------------------------
    31                              <1> ; Test first 64 KiB (MIN_RAM_SIZE) of RAM
    32                              <1> testFirst64kb:
    33                              <1> 	;mov	al,e_low_ram_test
    34                              <1> 	;out	post_reg,al
    35 0000E00A 31F6                <1> 	xor	si,si
    36 0000E00C 31FF                <1> 	xor	di,di
    37 0000E00E 8EDF                <1> 	mov	ds,di
    38 0000E010 8EC7                <1> 	mov	es,di
    39                              <1> 
    40                              <1> ;Inicio da carga do valor de AX
    41 0000E012 B8AA55              <1> 	mov	ax,55AAh		; first test pattern
    42 0000E015 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    43 0000E018 F3AB                <1>     rep	stosw				; store test pattern
    44                              <1> ;Fim da carga do valor de AX        
    45                              <1> ;inicio da comparação    
    46                              <1> ;lodsw CX=total repetição, SI=Endereço a ser lido AX recebe o dado
    47 0000E01A B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    48                              <1> .1:
    49 0000E01D AD                  <1> 	lodsw
    50 0000E01E 3DAA55              <1> 	cmp	ax,55AAh		; compare to the test pattern
    51 0000E021 7524                <1> 	jne	low_ram_fail
    52 0000E023 E2F8                <1> 	loop	.1
    53                              <1> ;Fim da comparação        
    54 0000E025 31F6                <1> 	xor	si,si
    55 0000E027 31FF                <1> 	xor	di,di
    56 0000E029 B855AA              <1> 	mov	ax,0AA55h		; second test pattern
    57 0000E02C B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    58 0000E02F F3AB                <1>     rep stosw				; store test pattern
    59 0000E031 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    60                              <1> .2:
    61 0000E034 AD                  <1> 	lodsw
    62 0000E035 3D55AA              <1> 	cmp	ax,0AA55h		; compare to the test pattern
    63 0000E038 750D                <1> 	jne	low_ram_fail
    64 0000E03A E2F8                <1> 	loop	.2
    65 0000E03C 31FF                <1> 	xor	di,di
    66 0000E03E 31C0                <1> 	xor	ax,ax			; zero
    67 0000E040 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    68 0000E043 F3AB                <1>     rep stosw				; zero the memory
    69 0000E045 EB03                <1> 	jmp	low_ram_ok		; test passed
    70                              <1> 
    71                              <1> low_ram_fail:
    72                              <1> 	;mov	al,e_low_ram_fail	; test failed
    73                              <1> 	;out	post_reg,al
    74 0000E047 E9B2FD              <1>     jmp     led2blinks
    75                              <1> 
    76                              <1> ;-------------------------------------------------------------------------
    77                              <1> ;-------------------------------------------------------------------------
    78                              <1> ; Low memory test passed
    79                              <1> 
    80                              <1> low_ram_ok:
    81 0000E04A BB0104              <1>         mov     bx, 0x401
    82 0000E04D 3E8807              <1>         mov     byte ds:[bx], al
    83 0000E050 E90CF0              <1>         jmp     initBios
    84                              <1> 
    85                              <1> ;-------------------------------------------------------------------------
    86                              <1> ; Test of 64k bytes of memory
    87                              <1> ; Reg ds = segment to test
    88                              <1> ;	  es = segment to test
    89                              <1> ;
    90                              <1> test64kb:
    91                              <1> 	;mov	al,e_low_ram_test
    92                              <1> 	;out	post_reg,al
    93 0000E053 31F6                <1> 	xor	si,si
    94 0000E055 31FF                <1> 	xor	di,di
    95                              <1> 
    96                              <1> ;Inicio da carga do valor de AX
    97 0000E057 B8AA55              <1> 	mov	ax,55AAh		; first test pattern
    98 0000E05A B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    99 0000E05D F3AB                <1>     rep	stosw				; store test pattern
   100                              <1> ;Fim da carga do valor de AX        
   101                              <1> ;inicio da comparação    
   102                              <1> ;lodsw CX=total repetição, SI=Endereço a ser lido AX recebe o dado
   103 0000E05F B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   104                              <1> .1:
   105 0000E062 AD                  <1> 	lodsw
   106 0000E063 3DAA55              <1> 	cmp	ax,55AAh		; compare to the test pattern
   107 0000E066 7524                <1> 	jne	low_ram_fail1
   108 0000E068 E2F8                <1> 	loop	.1
   109                              <1> ;Fim da comparação        
   110 0000E06A 31F6                <1> 	xor	si,si
   111 0000E06C 31FF                <1> 	xor	di,di
   112 0000E06E B855AA              <1> 	mov	ax,0AA55h		; second test pattern
   113 0000E071 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   114 0000E074 F3AB                <1>     rep stosw				; store test pattern
   115 0000E076 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   116                              <1> .2:
   117 0000E079 AD                  <1> 	lodsw
   118 0000E07A 3D55AA              <1> 	cmp	ax,0AA55h		; compare to the test pattern
   119 0000E07D 750D                <1> 	jne	low_ram_fail1
   120 0000E07F E2F8                <1> 	loop	.2
   121 0000E081 31FF                <1> 	xor	di,di
   122 0000E083 31C0                <1> 	xor	ax,ax			; zero
   123 0000E085 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   124 0000E088 F3AB                <1>     rep stosw				; zero the memory
   125 0000E08A EB02                <1> 	jmp	ram_ok		; test passed
   126                              <1> low_ram_fail1:
   127 0000E08C F9                  <1> 	STC 
   128 0000E08D C3                  <1> 	ret
   129                              <1> ;-------------------------------------------------------------------------
   130                              <1> ;-------------------------------------------------------------------------
   131                              <1> ; Low memory test passed
   132                              <1> 
   133                              <1> ram_ok:
   134                              <1> ;        mov ax, 0xF000
   135                              <1> ;        mov ds, ax
   136                              <1> ;        mov  bx, blocoOK
   137                              <1> ;        call print2
   138                              <1> 
   139 0000E08E BB0104              <1>         mov     bx, 0x401
   140 0000E091 3E8807              <1>         mov     byte ds:[bx], al
   141 0000E094 F8                  <1> 		CLC
   142 0000E095 C3                  <1>         ret
   143                              <1> ;I know it could be better but I'm lazy and besides 
   144                              <1> ;I have a lot of flash memory so don't criticize me
   145                              <1> 
   146                              <1> memoryTest:
   147 0000E096 1E                  <1> 		push DS
   148 0000E097 B80000              <1> 		mov	 ax,0x0
   149 0000E09A 8EC0                <1> 		mov  es, ax
   150 0000E09C B000                <1> 		mov  al,0
   151 0000E09E 26A20104            <1> 		mov  byte es:[flagMemOk], al
   152 0000E0A2 BE[74DE]            <1> 		mov  si, testMem
   153 0000E0A5 E8D5F1              <1> 		call pstr
   154                              <1> 
   155                              <1> 		;Block 1 64K
   156 0000E0A8 BE[87DE]            <1> 		mov  si, bloco01
   157 0000E0AB E8CFF1              <1> 		call pstr
   158 0000E0AE B80010              <1> 		mov  ax, 0x1000
   159 0000E0B1 8ED8                <1> 		mov  ds, ax
   160 0000E0B3 8EC0                <1> 		mov  es, ax
   161 0000E0B5 E89BFF              <1> 		call test64kb
   162 0000E0B8 7303E91101          <1> 		jc	 memoryTestEnd
   163 0000E0BD E83B01              <1> 		call segmentOK
   164 0000E0C0 B80000              <1> 		mov	 ax,0x0
   165 0000E0C3 8EC0                <1> 		mov  es, ax
   166 0000E0C5 26FE060104          <1> 		inc byte es:[flagMemOk]
   167                              <1> 
   168                              <1> 		;Block 2 64K
   169 0000E0CA BE[98DE]            <1> 		mov  si, bloco02
   170 0000E0CD E8ADF1              <1> 		call pstr
   171 0000E0D0 B80020              <1> 		mov  ax, 0x2000
   172 0000E0D3 8ED8                <1> 		mov  ds, ax
   173 0000E0D5 8EC0                <1> 		mov  es, ax
   174 0000E0D7 E879FF              <1> 		call    test64kb
   175 0000E0DA 7303E9EF00          <1> 		jc	memoryTestEnd
   176 0000E0DF E81901              <1> 		call segmentOK
   177 0000E0E2 B80000              <1> 		mov	 ax,0x0
   178 0000E0E5 8EC0                <1> 		mov  es, ax
   179 0000E0E7 26FE060104          <1> 		inc byte es:[flagMemOk]
   180                              <1> 
   181                              <1> 		;Block 3 64K
   182 0000E0EC BE[A9DE]            <1> 		mov  si, bloco03
   183 0000E0EF E88BF1              <1> 		call pstr
   184 0000E0F2 B80030              <1> 		mov  ax, 0x3000
   185 0000E0F5 8ED8                <1> 		mov  ds, ax
   186 0000E0F7 8EC0                <1> 		mov  es, ax
   187 0000E0F9 E857FF              <1> 		call    test64kb
   188 0000E0FC 7303E9CD00          <1> 		jc	memoryTestEnd
   189 0000E101 E8F700              <1> 		call segmentOK
   190 0000E104 B80000              <1> 		mov	 ax,0x0
   191 0000E107 8EC0                <1> 		mov  es, ax
   192 0000E109 26FE060104          <1> 		inc byte es:[flagMemOk]
   193                              <1> 
   194                              <1> 		;Block 4 64K
   195 0000E10E BE[BADE]            <1> 		mov  si, bloco04
   196 0000E111 E869F1              <1> 		call pstr
   197 0000E114 B80040              <1> 		mov  ax, 0x4000
   198 0000E117 8ED8                <1> 		mov  ds, ax
   199 0000E119 8EC0                <1> 		mov  es, ax
   200 0000E11B E835FF              <1> 		call    test64kb
   201 0000E11E 7303E9AB00          <1> 		jc	memoryTestEnd
   202 0000E123 E8D500              <1> 		call segmentOK
   203 0000E126 B80000              <1> 		mov	 ax,0x0
   204 0000E129 8EC0                <1> 		mov  es, ax
   205 0000E12B 26FE060104          <1> 		inc byte es:[flagMemOk]
   206                              <1> 
   207                              <1> 		;Block 5 64K
   208 0000E130 BE[CBDE]            <1> 		mov  si, bloco05
   209 0000E133 E847F1              <1> 		call pstr
   210 0000E136 B80050              <1> 		mov  ax, 0x5000
   211 0000E139 8ED8                <1> 		mov  ds, ax
   212 0000E13B 8EC0                <1> 		mov  es, ax
   213 0000E13D E813FF              <1> 		call    test64kb
   214 0000E140 7303E98900          <1> 		jc	memoryTestEnd
   215 0000E145 E8B300              <1> 		call segmentOK
   216 0000E148 B80000              <1> 		mov	 ax,0x0
   217 0000E14B 8EC0                <1> 		mov  es, ax
   218 0000E14D 26FE060104          <1> 		inc byte es:[flagMemOk]
   219                              <1> 
   220                              <1> 		;Block 6 64K
   221 0000E152 BE[DCDE]            <1> 		mov  si, bloco06
   222 0000E155 E825F1              <1> 		call pstr
   223 0000E158 B80060              <1> 		mov  ax, 0x6000
   224 0000E15B 8ED8                <1> 		mov  ds, ax
   225 0000E15D 8EC0                <1> 		mov  es, ax
   226 0000E15F E8F1FE              <1> 		call    test64kb
   227 0000E162 726A                <1> 		jc	memoryTestEnd
   228 0000E164 E89400              <1> 		call segmentOK
   229 0000E167 B80000              <1> 		mov	 ax,0x0
   230 0000E16A 8EC0                <1> 		mov  es, ax
   231 0000E16C 26FE060104          <1> 		inc byte es:[flagMemOk]
   232                              <1> 
   233                              <1> 		;Block 7 64K
   234 0000E171 BE[EDDE]            <1> 		mov  si, bloco07
   235 0000E174 E806F1              <1> 		call pstr
   236 0000E177 B80070              <1> 		mov  ax, 0x7000
   237 0000E17A 8ED8                <1> 		mov  ds, ax
   238 0000E17C 8EC0                <1> 		mov  es, ax
   239 0000E17E E8D2FE              <1> 		call    test64kb
   240 0000E181 724B                <1> 		jc	memoryTestEnd
   241 0000E183 E87500              <1> 		call segmentOK
   242 0000E186 B80000              <1> 		mov	 ax,0x0
   243 0000E189 8EC0                <1> 		mov  es, ax
   244 0000E18B 26FE060104          <1> 		inc byte es:[flagMemOk]
   245                              <1> 
   246                              <1> 		;Block 8 64K
   247 0000E190 BE[FEDE]            <1> 		mov  si, bloco08
   248 0000E193 E8E7F0              <1> 		call pstr
   249 0000E196 B80080              <1> 		mov  ax, 0x8000
   250 0000E199 8ED8                <1> 		mov  ds, ax
   251 0000E19B 8EC0                <1> 		mov  es, ax
   252 0000E19D E8B3FE              <1> 		call    test64kb
   253 0000E1A0 722C                <1> 		jc	memoryTestEnd
   254 0000E1A2 E85600              <1> 		call segmentOK
   255 0000E1A5 B80000              <1> 		mov	 ax,0x0
   256 0000E1A8 8EC0                <1> 		mov  es, ax
   257 0000E1AA 26FE060104          <1> 		inc byte es:[flagMemOk]
   258                              <1> 
   259                              <1> 		;Block 9 64K
   260 0000E1AF BE[0FDF]            <1> 		mov  si, bloco09
   261 0000E1B2 E8C8F0              <1> 		call pstr
   262 0000E1B5 B80090              <1> 		mov  ax, 0x9000
   263 0000E1B8 8ED8                <1> 		mov  ds, ax
   264 0000E1BA 8EC0                <1> 		mov  es, ax
   265 0000E1BC E894FE              <1> 		call    test64kb
   266 0000E1BF 720D                <1> 		jc	memoryTestEnd
   267 0000E1C1 E83700              <1> 		call segmentOK
   268 0000E1C4 B80000              <1> 		mov	 ax,0x0
   269 0000E1C7 8EC0                <1> 		mov  es, ax
   270 0000E1C9 26FE060104          <1> 		inc byte es:[flagMemOk]
   271                              <1> 
   272                              <1> 
   273                              <1> memoryTestEnd:
   274 0000E1CE 1F                  <1> 		pop  	ds
   275 0000E1CF B80000              <1> 		mov 	ax, 0x0
   276 0000E1D2 8EC0                <1> 		mov 	es, ax
   277                              <1> 
   278 0000E1D4 26A00104            <1> 		mov		al, byte es:[flagMemOk]
   279 0000E1D8 3C07                <1> 		cmp		al, 7
   280 0000E1DA 7406                <1> 		jz      onlyTotal
   281                              <1> 
   282 0000E1DC BE[2CDF]            <1> 		mov		si, blocoNOK
   283 0000E1DF E89BF0              <1> 		call	pstr
   284                              <1> onlyTotal:		
   285                              <1> 
   286 0000E1E2 BE[42DF]            <1> 		mov		si, totalMem
   287 0000E1E5 E895F0              <1> 		call	pstr
   288 0000E1E8 B81200              <1> 		mov     ax, 18
   289 0000E1EB 268A0E0104          <1> 		mov		cl, byte es:[flagMemOk]
   290 0000E1F0 F6E1                <1> 		mul		cl
   291                              <1> 		;call	print_hex
   292 0000E1F2 BE[56DF]            <1> 		mov		si, qtdMem0
   293 0000E1F5 01C6                <1> 		add		si, ax
   294 0000E1F7 E883F0              <1> 		call 	pstr
   295                              <1> 
   296 0000E1FA C3                  <1> 		ret
   297                              <1> 	
   298                              <1> 
   299                              <1> segmentOK:
   300 0000E1FB B800F0              <1>         mov		ax, 0xF000
   301 0000E1FE 8ED8                <1>         mov		ds, ax
   302 0000E200 BE[20DF]            <1>         mov		si, blocoOK
   303 0000E203 E877F0              <1>         call	pstr
   304 0000E206 C3                  <1> 		ret
   305                              <1> 
   306                              <1> ;-------------------------------------------------------------------------
   307                              <1> ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
   308                              <1> beep:
   309                              <1> ;	mov	al,0B6h
   310                              <1> ;	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   311                              <1> ;	mov	ax,pic_freq/400		; 400 Hz signal
   312                              <1> ;	out	pit_ch2_reg,al
   313                              <1> ;	mov	al,ah
   314                              <1> ;	out	pit_ch2_reg,al
   315                              <1> ;	in	al,ppi_pb_reg
   316                              <1> ;.1:
   317                              <1> ;	or	al,3			; turn speaker on and enable
   318                              <1> ;	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   319                              <1> ;	mov	cx,0
   320                              <1> ;.2:
   321                              <1> ;	nop
   322                              <1> ;	loop	.2
   323                              <1> ;	and	al,0FCh			; turn of speaker
   324                              <1> ;	out	ppi_pb_reg,al
   325                              <1> ;	mov	cx,0
   326                              <1> ;.3:
   327                              <1> ;	nop
   328                              <1> ;	loop	.3
   329                              <1> ;	jmp	.1
   270                                  %include "mprintRegs.asm"
     1                              <1> 	CPU 8086
     2                              <1> ;=========================================================================
     3                              <1> ; print_hex - print 16-bit number in hexadecimal
     4                              <1> ; Input:
     5                              <1> ;	AX - number to print
     6                              <1> ; Output:
     7                              <1> ;	none
     8                              <1> ;-------------------------------------------------------------------------
     9                              <1> printw_hex:
    10                              <1> print_hex:
    11 0000E207 50                  <1>     push    AX
    12 0000E208 86C4                <1> 	xchg	al,ah
    13 0000E20A E82100              <1> 	call	print_byte		; print the upper byte
    14 0000E20D 86C4                <1> 	xchg	al,ah
    15 0000E20F E81C00              <1> 	call	print_byte		; print the lower byte
    16 0000E212 58                  <1>     pop     AX
    17 0000E213 C3                  <1> 	ret
    18                              <1> ;=========================================================================
    19                              <1> ; printb_hex - print 8-bit number in hexadecimal
    20                              <1> ; Input:
    21                              <1> ;	AL - number to print
    22                              <1> ; Output:
    23                              <1> ;	none
    24                              <1> ;-------------------------------------------------------------------------
    25                              <1> printb_hex:
    26 0000E214 50                  <1>     push    AX
    27 0000E215 E81600              <1> 	call	print_byte		; print the upper byte
    28 0000E218 58                  <1> 	pop		AX
    29 0000E219 C3                  <1> 	ret
    30                              <1> ;=========================================================================
    31                              <1> ; print_digit - print hexadecimal digit
    32                              <1> ; Input:
    33                              <1> ;	AL - bits 3...0 - digit to print (0...F)
    34                              <1> ; Output:
    35                              <1> ;	none
    36                              <1> ;-------------------------------------------------------------------------
    37                              <1> print_digit:
    38 0000E21A 50                  <1> 	push	ax
    39 0000E21B 53                  <1> 	push	bx
    40 0000E21C 52                  <1> 	push	dx
    41 0000E21D 240F                <1> 	and	al,0Fh
    42 0000E21F 0430                <1> 	add	al,'0'			; convert to ASCII
    43 0000E221 3C39                <1> 	cmp	al,'9'			; less or equal 9?
    44 0000E223 7602                <1> 	jna	.1
    45 0000E225 0407                <1> 	add	al,'A'-'9'-1		; a hex digit
    46                              <1> .1:
    47 0000E227 E874F0              <1>     call    cout
    48 0000E22A 5A                  <1> 	pop	dx
    49 0000E22B 5B                  <1> 	pop	bx
    50 0000E22C 58                  <1> 	pop	ax
    51 0000E22D C3                  <1> 	ret
    52                              <1> ;=========================================================================
    53                              <1> ; print_byte - print a byte in hexadecimal
    54                              <1> ; Input:
    55                              <1> ;	AL - byte to print
    56                              <1> ; Output:
    57                              <1> ;	none
    58                              <1> ;-------------------------------------------------------------------------
    59                              <1> print_byte:
    60 0000E22E D0C0                <1> 	rol	al,1
    61 0000E230 D0C0                <1> 	rol	al,1
    62 0000E232 D0C0                <1> 	rol	al,1
    63 0000E234 D0C0                <1> 	rol	al,1
    64 0000E236 E8E1FF              <1> 	call	print_digit
    65 0000E239 D0C0                <1> 	rol	al,1
    66 0000E23B D0C0                <1> 	rol	al,1
    67 0000E23D D0C0                <1> 	rol	al,1
    68 0000E23F D0C0                <1> 	rol	al,1
    69 0000E241 E8D6FF              <1> 	call	print_digit
    70 0000E244 C3                  <1> 	ret
    71                              <1> ;=========================================================================
    72                              <1> ;byte_to_hex_str
    73                              <1> ;This function return in AX the ascii code for hexadecimal number from 0 to F
    74                              <1> ;Parameters:
    75                              <1> ;               AL = imput
    76                              <1> ;               AX = output
    77                              <1> ;This routines expands the data 1 byte returns 2 bytes
    78                              <1> ;Ex.: 0xA5 returns 4135 41 = 'A' 35 = '5' 
    79                              <1> ;
    80                              <1> ;Changes CL
    81                              <1> byte_to_hex_str:
    82 0000E245 51                  <1>         PUSH CX
    83 0000E246 88C4                <1>         mov ah, al
    84 0000E248 B104                <1>         mov cl, 4
    85 0000E24A D2E8                <1>         shr al, cl
    86 0000E24C 250F0F              <1>         and ax, 0x0f0f
    87 0000E24F 3C09                <1>         cmp al, 0x09
    88 0000E251 7602                <1>         jbe .11
    89 0000E253 0407                <1>         add al, 'A' - '0' - 10
    90                              <1> .11:
    91 0000E255 80FC09              <1>         cmp ah, 0x09
    92 0000E258 7603                <1>         jbe .22
    93 0000E25A 80C407              <1>         add ah, 'A' - '0' - 10
    94                              <1> .22:
    95 0000E25D 053030              <1>         add ax, "00"
    96                              <1> .ret:
    97 0000E260 59                  <1>         POP CX
    98 0000E261 C3                  <1>         ret
    99                              <1> 
   100                              <1> ;==========================================================================
   101                              <1> ;hex_str_to_hex
   102                              <1> ;Parameters: DX = data to be converted
   103                              <1> ;            bh = return data
   104                              <1> ;
   105                              <1> ;This routines compress the data 2 bytes returns 1 byte
   106                              <1> ;Ex.: A5 in memory 41 35 41 = 'A' 35 = '5' returns 0xA5  A=1010 and 5 = 0101 
   107                              <1> ;
   108                              <1> ;A crude and simple implementation is to split 
   109                              <1> ;the byte into two nibbles and then use each 
   110                              <1> ;nibble as an index into a hex character "table".
   111                              <1> ; cdecl calling convention (google if you're not familiar with)
   112 0000E262 000102030405060708- <1> HEX_CHARSET		db 0,1,2,3,4,5,6,7,8,9,0xA,0xB,0xC,0xD,0xE,0xF
   112 0000E26B 090A0B0C0D0E0F      <1>
   113                              <1> 
   114                              <1> ; void byteToHex(byte val, char* buffer)
   115                              <1> hex_str_to_hex:
   116                              <1>     ; nibble 1
   117 0000E272 31DB                <1> 	xor		BX, BX
   118 0000E274 89D0                <1>     mov 	ax,	dx
   119 0000E276 E81700              <1> 	call	getNibble
   120 0000E279 D0E4                <1> 	shl		ah, 1
   121 0000E27B D0E4                <1> 	shl		ah, 1
   122 0000E27D D0E4                <1> 	shl		ah, 1
   123 0000E27F D0E4                <1> 	shl		ah, 1
   124 0000E281 88E7                <1> 	mov		bh, ah
   125                              <1>     ; nibble 2
   126 0000E283 89D0                <1>     mov 	ax,	dx
   127 0000E285 88C4                <1> 	mov		ah, al
   128 0000E287 E80600              <1> 	call	getNibble
   129 0000E28A 80E40F              <1> 	and		ah, 0x0F
   130 0000E28D 08E7                <1> 	or		bh, ah
   131 0000E28F C3                  <1> 	ret
   132                              <1> 		
   133                              <1> getNibble:	
   134 0000E290 80FC41              <1> 	cmp ah, 0x41
   135 0000E293 7D04                <1> 	jge getHexSuperior
   136 0000E295 80EC30              <1> 	sub ah, 0x30
   137 0000E298 C3                  <1> 	ret
   138                              <1> getHexSuperior:
   139 0000E299 80EC37              <1> 	sub ah, 0x37
   140 0000E29C C3                  <1> 	ret
   141                              <1> 
   142                              <1> ;=======================================================	
   143                              <1> ;nibbleToHex
   144                              <1> ;Parameters AX = data to be converted
   145                              <1> ;Return data in AL
   146                              <1> nibbleToHex:
   147 0000E29D 83E00F              <1> 	and AX, 0Fh ; 
   148 0000E2A0 3E8D36[62E2]        <1> 	lea si, ds:[HEX_CHARSET]
   149 0000E2A5 01C6                <1> 	add si, ax
   150 0000E2A7 AC                  <1> 	lodsb
   151 0000E2A8 C3                  <1> 	ret
   152                              <1> 
   153                              <1> 
   154                              <1> convertByteToHex:
   155 0000E2A9 52                  <1> 	push	DX
   156 0000E2AA 53                  <1> 	push	BX
   157 0000E2AB 268A360F05          <1> 	mov		dh, byte es:[buff_read]
   158 0000E2B0 268A161005          <1> 	mov		dl, byte es:[buff_read+1]
   159 0000E2B5 E8BAFF              <1> 	call	hex_str_to_hex
   160 0000E2B8 26883E8F05          <1> 	mov		byte es:[buff_write], bh
   161 0000E2BD 5B                  <1> 	pop		BX
   162 0000E2BE 5A                  <1> 	pop		DX
   163 0000E2BF C3                  <1> 	ret
   164                              <1> 
   165                              <1> convertWordToHex:
   166 0000E2C0 52                  <1> 	push	DX
   167 0000E2C1 53                  <1> 	push	BX
   168 0000E2C2 268A360F05          <1> 	mov		dh, byte es:[buff_read]
   169 0000E2C7 268A161005          <1> 	mov		dl, byte es:[buff_read+1]
   170 0000E2CC E8A3FF              <1> 	call	hex_str_to_hex
   171 0000E2CF 26883E8F05          <1> 	mov		byte es:[buff_write], bh
   172 0000E2D4 268A361105          <1> 	mov		dh, byte es:[buff_read+2]
   173 0000E2D9 268A161205          <1> 	mov		dl, byte es:[buff_read+3]
   174 0000E2DE E891FF              <1> 	call	hex_str_to_hex
   175 0000E2E1 26883E9005          <1> 	mov		byte es:[buff_write+1], bh
   176 0000E2E6 5B                  <1> 	pop		BX
   177 0000E2E7 5A                  <1> 	pop		DX
   178 0000E2E8 C3                  <1> 	ret
   179                              <1> 
   180                              <1> ;==============================================================================
   181                              <1> ;to_hex
   182                              <1> ; convert ASCII letter to one nibble 0-F
   183                              <1> ; 0-9 -> al-30
   184                              <1> ; A-F -> al-7
   185                              <1> ; entry: al
   186                              <1> ; exit: al
   187                              <1> 
   188                              <1> to_hex:  
   189 0000E2E9 2C30                <1> 		sub al,	"0"
   190 0000E2EB 3C0A                <1> 		cmp al,	10
   191 0000E2ED 7C04                <1> 		jl 	zero_nine
   192 0000E2EF 24DF                <1> 		and al,	11011111b
   193 0000E2F1 2C07                <1> 		sub al,	7
   194                              <1> zero_nine: 
   195 0000E2F3 C3                  <1> 		ret
   196                              <1> 
   197                              <1> ; convert ASCII to 16-bit hex number
   198                              <1> ; entry: string in inline buffer
   199                              <1> ; exit: ax
   200                              <1> 
   201                              <1> atohex:
   202 0000E2F4 E8C9FF              <1> 		call	convertWordToHex
   203 0000E2F7 26A18F05            <1> 		mov		AX, word es:[buff_write]
   204 0000E2FB C3                  <1> 		ret
   271                                  %include "mHardwareInit.asm"
     1                              <1>         CPU 8086
     2                              <1>         BITS 16
     3                              <1> 
     4                              <1> 
     5                              <1> init_system:
     6                              <1> 
     7 0000E2FC E80500              <1>         call pic_init
     8                              <1>  
     9 0000E2FF E83900              <1>         call pit_init
    10                              <1> 
    11 0000E302 FB                  <1>         sti
    12 0000E303 C3                  <1>         ret
    13                              <1> 
    14                              <1> 
    15                              <1> 
    16                              <1> 
   272                                  %include "mpic8259A.asm"
     1                              <1>         CPU 8086
     2                              <1>         BITS 16
     3                              <1> 
     4                              <1>         
     5                              <1> ;--------------------------------------
     6                              <1> ; PIC (8259)
     7                              <1> ;--------------------------------------
     8                              <1> PIC_REG_0           EQU     0x20
     9                              <1> PIC_REG_1           EQU     0x21
    10                              <1> PIC_ISR             EQU     0x20
    11                              <1> PIC_IRR             EQU     0x20
    12                              <1> PIC_IMR             EQU     0x21
    13                              <1> PIC_INT_VEC         EQU     0x08
    14                              <1> 
    15                              <1> ;PIC_INIT        db 0Dh,0Ah,"pc_init: init",0Dh, 0
    16                              <1> ;INIT_IRQ        db 0Dh,0Ah,"pic_enable_ir: init",0Dh, 0
    17                              <1> ;INT_VECT        db 0Dh,0Ah,"set_int_vector: init",0Dh, 0
    18                              <1> 
    19                              <1> ;--------------------------------------
    20                              <1> ; void pic_init(void)
    21                              <1> ;--------------------------------------
    22                              <1> pic_init:
    23                              <1>         ;mov     si, PIC_INIT 
    24                              <1>         ;call    pstr
    25 0000E304 9C                  <1>         pushf
    26 0000E305 FA                  <1>         cli
    27 0000E306 B017                <1>         mov al, 0b00010111      ; ICW1
    28 0000E308 E620                <1>         out PIC_REG_0, al
    29 0000E30A B008                <1>         mov al, (PIC_INT_VEC & 0b11111000)  ; ICW2
    30 0000E30C E621                <1>         out PIC_REG_1, al
    31                              <1>         ;Precisa de codigo para informar ao 8259 o termino da interrupção
    32                              <1>         ;mov al, 0b00000001      ; ICW4
    33                              <1>         ;Não precisa de codigo para informar ao 8259 o termino da interrupção
    34 0000E30E B003                <1>         mov al, 0b00000011      ; ICW4
    35 0000E310 E621                <1>         out PIC_REG_1, al
    36                              <1> 
    37 0000E312 B0FF                <1>         mov al, 0b11111111      ; mask all interrupts
    38 0000E314 E621                <1>         out PIC_IMR, al
    39                              <1> 
    40 0000E316 B008                <1>         mov al, 0b00001000
    41 0000E318 E620                <1>         out PIC_REG_0, al
    42                              <1> 
    43 0000E31A 9D                  <1>         popf
    44 0000E31B C3                  <1>         ret
    45                              <1> 
    46                              <1> ;--------------------------------------
    47                              <1> ; void pic_disable_ir(uint8_t irNo)
    48                              <1> ;--------------------------------------
    49                              <1> pic_disable_ir:
    50 0000E31C 9C                  <1>         pushf
    51 0000E31D FA                  <1>         cli
    52                              <1> 
    53 0000E31E 89E3                <1>         mov bx, sp
    54 0000E320 B108                <1>         mov cl, 8 ;[bx + 2]
    55 0000E322 80E107              <1>         and cl, 0b00000111
    56 0000E325 B401                <1>         mov ah, 1
    57 0000E327 D2E4                <1>         shl ah, cl
    58 0000E329 E421                <1>         in al, PIC_IMR
    59 0000E32B 08E0                <1>         or al, ah
    60 0000E32D E621                <1>         out PIC_IMR, al
    61                              <1> 
    62 0000E32F 9D                  <1>         popf
    63 0000E330 C3                  <1>         ret
    64                              <1> 
    65                              <1> ;--------------------------------------
    66                              <1> ; void pic_enable_ir(uint8_t irNo)
    67                              <1> ;--------------------------------------
    68                              <1> pic_enable_ir:
    69                              <1>         ;mov     si, INIT_IRQ 
    70                              <1>         ;call    pstr
    71                              <1> 
    72 0000E331 9C                  <1>         pushf
    73 0000E332 FA                  <1>         cli
    74 0000E333 B0FE                <1>         mov al, 0FEh
    75 0000E335 E621                <1>         out PIC_IMR, al
    76 0000E337 E421                <1>         in al, PIC_IMR
    77                              <1>         ;call print_hex
    78                              <1> 
    79 0000E339 9D                  <1>         popf
    80 0000E33A C3                  <1>         ret
    81                              <1> 
    82                              <1> ;%include "intVect.asm"
    83                              <1> 
    84                              <1> 
    85                              <1> ;#1 tentar testar sem ter terminado wireup de I/0 RD WR e dados no barramento
    86                              <1> ;#2 negligenciar o pino de CS na hora de ligá-lo ao 74138 pois fiz uma gambeta
    87                              <1> ;   para que o mesmo 74138 pudesse atuar com endereços 0x20 e 0x40
    88                              <1> ;#3 negligenciar a forma de habilitar a interrupção na função pic_enable_ir
    89                              <1> ;#4 A chave conectada ao pino da interrupção com certeza dava problemas pois
    90                              <1> ;   foi tirar a chave e colocar o 8253 fazendo a interrupção que todos os
    91                              <1> ;   probremas de reset acabaram.
   273                                  %include "mpit8254.asm"
     1                              <1>         CPU 8086
     2                              <1>         BITS 16
     3                              <1> 
     4                              <1> 
     5                              <1> SYSTEM_CPU_CLK      EQU     4771000    ; this is the CPU clk (1/3 of the used crystal)
     6                              <1> SYSTEM_PCLK         EQU     (SYSTEM_CPU_CLK / 2) ; PCLK from 8284 is half the rate of the CPU clk
     7                              <1> ;--------------------------------------
     8                              <1> ; PIT (8254)
     9                              <1> ;--------------------------------------
    10                              <1> PIT_COUNTER_0       EQU     0x40
    11                              <1> PIT_COUNTER_1       EQU     0x41
    12                              <1> PIT_COUNTER_2       EQU     0x42
    13                              <1> PIT_CTRL_REG        EQU     0x43
    14                              <1> 
    15                              <1> PIT_COUNTER0_INT    EQU     (PIC_INT_VEC + 0)
    16                              <1> SYSTEM_TICKS_SEC    EQU     100         ; 100 ticks per second = 100Hz
    17                              <1> 
    18                              <1> ;--------------------------------------
    19                              <1> ; void pit_init(void)
    20                              <1> ;--------------------------------------
    21                              <1> pit_init:
    22 0000E33B 9C                  <1>         pushf
    23 0000E33C FA                  <1>         cli
    24                              <1> 
    25 0000E33D E86100              <1>         call init8253
    26                              <1> 
    27 0000E340 E83A00              <1>         call set_int_vector     ; => set_int_vector(PIT_COUNTER0_INT, &counter0_int_handler);
    28                              <1> 
    29                              <1> ; enable pin IR0 in the PIC
    30 0000E343 31C0                <1>         xor ax, ax
    31 0000E345 50                  <1>         push ax
    32 0000E346 E8E8FF              <1>         call pic_enable_ir      ; => pic_enable_ir(0);
    33 0000E349 83C402              <1>         add sp, 2
    34                              <1> 
    35 0000E34C 9D                  <1>         popf
    36 0000E34D C3                  <1>         ret
    37                              <1> 
    38                              <1> ;--------------------------------------
    39                              <1> ; uint32_t get_sys_ticks(void)
    40                              <1> ;--------------------------------------
    41                              <1> get_sys_ticks:
    42 0000E34E 9C                  <1>         pushf
    43 0000E34F FA                  <1>         cli
    44 0000E350 B84000              <1>         mov AX, 0x0040
    45 0000E353 8EC0                <1>         mov ES, AX
    46 0000E355 BB6C00              <1>         MOV BX, 0x006C			;SET BX TO TICK COUNTER
    47 0000E358 268B07              <1>         mov ax, word es:[BX]
    48 0000E35B 268B5702            <1>         mov dx, word es:[BX + 2]
    49 0000E35F FB                  <1>         sti
    50 0000E360 9D                  <1>         popf
    51 0000E361 C3                  <1>         ret
    52                              <1> 
    53                              <1> ;--------------------------------------
    54                              <1> counter0_int_handler:
    55 0000E362 06                  <1>         push ES
    56 0000E363 50                  <1>         push AX
    57 0000E364 31C0                <1>         xor AX, AX
    58 0000E366 8EC0                <1>         mov ES, AX
    59 0000E368 26FF066C00          <1>         inc word es:[sys_tick_count]
    60 0000E36D 7505                <1>         jnz .1
    61 0000E36F 26FF066E00          <1>         inc word es:[sys_tick_count + 2]
    62                              <1> .1:
    63                              <1>         pic_eoi_cmd
    42 0000E374 50                  <2>  push ax
    43                              <2> 
    44                              <2> 
    45                              <2> 
    46                              <2> 
    47 0000E375 B020                <2>  mov al, 0b00100000
    48 0000E377 E620                <2>  out PIC_REG_0, al
    49 0000E379 58                  <2>  pop ax
    64 0000E37A 58                  <1>         pop AX
    65 0000E37B 07                  <1>         pop ES
    66 0000E37C CF                  <1>         iret
    67                              <1> 
    68                              <1> ;--------------------------------------
    69                              <1> ; void set_int_vector(uint8_t intNo, void* ptr)
    70                              <1> ;--------------------------------------
    71                              <1> set_int_vector:
    72                              <1>         ;MOV si, INT_VECT 
    73                              <1>         ;call    pstr
    74                              <1> 
    75 0000E37D 06                  <1>         push es
    76 0000E37E 31C0                <1>         xor ax, ax
    77 0000E380 8EC0                <1>         mov es, ax
    78                              <1> 
    79 0000E382 FA                  <1>         cli
    80                              <1> 
    81 0000E383 26C7062000[C1EE]    <1>         mov word es:[8h*4], INT08
    82 0000E38A 26C706220000F0      <1>         mov word es:[8h*4+2], 0F000h
    83                              <1> 
    84 0000E391 07                  <1>         pop es
    85 0000E392 C3                  <1>         ret
    86                              <1> myInit8253:
    87 0000E393 B036                <1>         mov al, 0b00110110      ; Counter 0, binary, mode 3, write both bytes
    88 0000E395 E643                <1>         out PIT_CTRL_REG, al
    89                              <1> 
    90 0000E397 B82F5D              <1>         mov ax, ((SYSTEM_PCLK + (SYSTEM_TICKS_SEC / 2)) / SYSTEM_TICKS_SEC) ; set system tick counter
    91 0000E39A E640                <1>         out PIT_COUNTER_0, al
    92 0000E39C 86E0                <1>         xchg ah, al
    93 0000E39E E640                <1>         out PIT_COUNTER_0, al
    94 0000E3A0 C3                  <1>         ret
    95                              <1> 
    96                              <1> init8253:
    97                              <1> 
    98 0000E3A1 50                  <1> 	PUSH AX
    99 0000E3A2 51                  <1> 	PUSH CX
   100                              <1> 
   101 0000E3A3 B036                <1> 	MOV AL, 0X36 		;00110110b  
   102                              <1> 			        ;CHANNEL 0
   103                              <1> 			        ;WRITE LOW BYTE THEN HIGH BYTE
   104                              <1> 			        ;MODE 3 
   105                              <1> 			        ;16 BIT COUNTER 
   106                              <1> 			
   107 0000E3A5 E643                <1> 	OUT 0X43, AL		;CONTROL REG
   108                              <1> 
   109 0000E3A7 B9FFFF              <1> 	MOV CX, 0XFFFF		;COUNT 
   110                              <1> 
   111 0000E3AA 88C8                <1> 	MOV AL, CL		;WRITE LOW BYTE OF COUNT
   112 0000E3AC E640                <1> 	OUT 0X40, AL		;PORT 0X40 ;INTERNAL FLIP-FLOP INC
   113                              <1> 			
   114 0000E3AE 88E8                <1> 	MOV AL, CH		;WRITE HIGH BYTE OF COUNT 
   115 0000E3B0 E640                <1> 	OUT 0X40, AL		;PORT 040
   116                              <1> 
   117                              <1> 	;;;;;;;;;;;
   118                              <1> 	;TEST TONE
   119                              <1> 	;;;;;;;;;;;
   120 0000E3B2 B003                <1> 	MOV AL, 0X03		;ENABLE SPK AND TIMMER 2 'GO'
   121 0000E3B4 E661                <1> 	OUT 0X61, AL		;PORT 0X61 CONTROL PORT
   122 0000E3B6 B0B6                <1> 	MOV AL, 0XB6
   123 0000E3B8 E643                <1> 	OUT 0X43, AL
   124 0000E3BA B000                <1> 	MOV AL, 0X00
   125 0000E3BC E642                <1> 	OUT 0X42, AL
   126 0000E3BE B005                <1> 	MOV AL, 0X05
   127 0000E3C0 E642                <1> 	OUT 0X42, AL
   128                              <1> 
   129 0000E3C2 59                  <1> 	POP CX
   130 0000E3C3 58                  <1> 	POP AX
   131                              <1> 
   132 0000E3C4 C3                  <1> 	RET
   274                                  %include "mmath.asm"
     1                              <1> 
     2                              <1> 
     3                              <1>  
     4                              <1> subtract:
     5 0000E3C5 B200                <1>         mov dl, 00h
     6 0000E3C7 26A10F06            <1>         mov ax, word es:[abc]
     7 0000E3CB 268B1E1406          <1>         mov bx, word es:[def]
     8 0000E3D0 29D8                <1>         sub ax, bx
     9 0000E3D2 26A31806            <1>         mov word es:[ghi], ax
    10 0000E3D6 26A11106            <1>         mov ax, word es:[abc+2]
    11 0000E3DA 268B1E1606          <1>         mov bx, word es:[def+2]
    12 0000E3DF 19D8                <1>         sbb ax, bx
    13 0000E3E1 26A31A06            <1>         mov word es:[ghi+2],ax
    14 0000E3E5 7302                <1>         jnc move
    15 0000E3E7 FEC2                <1>         inc dl
    16                              <1> move: 
    17 0000E3E9 2688161C06          <1>         mov byte es:[ghi+4], dl
    18 0000E3EE CD03                <1>         int 3
   275                                  %include "mmemoryDump.asm"
     1                              <1> 
     2                              <1> 
     3 0000E3F0 0D0A3C4553433E4669- <1> msg04   db 0Dh,0Ah,"<ESC>Fim, <Enter>Continua: ", 0
     3 0000E3F9 6D2C203C456E746572- <1>
     3 0000E402 3E436F6E74696E7561- <1>
     3 0000E40B 3A2000              <1>
     4 0000E40E 0D0A45533A2000      <1> msg05   db 0Dh,0Ah,"ES: ", 0
     5                              <1> 
     6                              <1> ;=================================
     7                              <1> ; Dump memory
     8                              <1> ; Segment address: ES
     9                              <1> ; Memory  address: bx
    10                              <1> ;         
    11                              <1> dump:
    12 0000E415 E8F803              <1>         call    readAddress
    13                              <1> NewBlock:
    14 0000E418 53                  <1>         push    BX
    15 0000E419 BE[0EE4]            <1>         mov     si, msg05
    16 0000E41C E85EEE              <1>         call    pstr
    17 0000E41F 8CC0                <1>         mov     AX, ES
    18 0000E421 E8E3FD              <1>         call    print_hex      
    19 0000E424 B03A                <1>         mov     al, ':'
    20 0000E426 E875EE              <1>         call    cout
    21 0000E429 5B                  <1>         pop     BX
    22 0000E42A 89D8                <1>         mov     AX, BX
    23 0000E42C E8D8FD              <1>         call    print_hex      
    24                              <1> 
    25 0000E42F B110                <1>         mov  CL, 16
    26 0000E431 E813EE              <1>         call newLine
    27                              <1> dump_01:        
    28 0000E434 89D8                <1>         mov  AX, BX
    29 0000E436 E8CEFD              <1>         call print_hex
    30 0000E439 B03A                <1>         mov  al, ':'
    31 0000E43B E860EE              <1>         call cout
    32 0000E43E B020                <1>         MOV  AL, ' '
    33 0000E440 E85BEE              <1>         CALL cout
    34                              <1>         
    35                              <1>         ;;Write 16 bytes em hexadecimal
    36 0000E443 B510                <1>         MOV  CH, 16
    37                              <1> dump_02:
    38 0000E445 268A07              <1>         MOV  AL, ES:[BX]
    39 0000E448 E8FAFD              <1>         CALL byte_to_hex_str
    40 0000E44B 50                  <1>         PUSH AX
    41 0000E44C E84FEE              <1>         CALL cout
    42 0000E44F 58                  <1>         POP  AX
    43 0000E450 88E0                <1>         MOV  AL, AH
    44 0000E452 E849EE              <1>         CALL cout
    45 0000E455 B020                <1>         MOV  AL, ' '
    46 0000E457 E844EE              <1>         CALL cout
    47 0000E45A 43                  <1>         INC  BX
    48 0000E45B FECD                <1>         DEC  CH
    49 0000E45D 75E6                <1>         JNZ  dump_02
    50                              <1>         ;;Wrote 16 bytes
    51                              <1> 
    52 0000E45F B020                <1>         MOV  AL, ' '
    53 0000E461 E83AEE              <1>         CALL cout
    54                              <1> 
    55 0000E464 83EB10              <1>         SUB  BX, 16
    56                              <1> 
    57                              <1>         ;;Write 16 bytes em ASCII
    58 0000E467 B510                <1>         MOV  CH, 16
    59                              <1> dump_03:
    60 0000E469 268A07              <1>         MOV  AL, ES:[BX]
    61 0000E46C 3C20                <1>         CMP  AL, 0x20
    62 0000E46E 720E                <1>         JC  printPonto ; Flag carry set to 1 AL < 0x20
    63 0000E470 3C80                <1>         CMP  AL, 0x80
    64 0000E472 730A                <1>         JnC  printPonto ; Flag carry set to 0 AL > 0x80
    65 0000E474 E827EE              <1>         CALL cout
    66 0000E477 43                  <1>         INC  BX
    67 0000E478 FECD                <1>         DEC  CH
    68 0000E47A 75ED                <1>         JNZ  dump_03
    69 0000E47C EB0A                <1>         jmp  dump_Fim
    70                              <1> printPonto:        
    71 0000E47E B02E                <1>         MOV  AL, '.'
    72 0000E480 E81BEE              <1>         CALL cout
    73 0000E483 43                  <1>         INC  BX
    74 0000E484 FECD                <1>         DEC  CH
    75 0000E486 75E1                <1>         JNZ  dump_03
    76                              <1>         ;;Wrote 16 bytes
    77                              <1> 
    78                              <1> dump_Fim:
    79 0000E488 E8BCED              <1>         call newLine
    80 0000E48B FEC9                <1>         DEC  CL
    81 0000E48D 75A5                <1>         JNZ  dump_01
    82                              <1>         ;;mov  AX, 0F000h
    83                              <1>         ;;mov  DS, AX
    84 0000E48F EB07                <1>         jmp continua
    85 0000E491 C3                  <1>         ret
    86                              <1> 
    87                              <1> printPrompt:
    88 0000E492 B03E                <1>         mov al, '>'
    89 0000E494 E807EE              <1>         call cout
    90 0000E497 C3                  <1>         ret
    91                              <1> 
    92                              <1> continua:
    93 0000E498 53                  <1>         push BX
    94 0000E499 BE[F0E3]            <1>         mov  si, msg04
    95 0000E49C E8DEED              <1>         call pstr
    96 0000E49F 31C0                <1>         XOR  AX, AX
    97 0000E4A1 5B                  <1>         pop  BX
    98 0000E4A2 E817EE              <1>         call cin_blct
    99 0000E4A5 3C0D                <1>         cmp  al, cr
   100 0000E4A7 7503E96CFF          <1>         je   NewBlock
   101 0000E4AC C3                  <1>         ret
   102                              <1> 
   103                              <1> 
   276                                  %include "meditMemory.asm"
     1                              <1> ;=================================
     2                              <1> ; Edit memory
     3                              <1> ; Segment address: ES
     4                              <1> ; Memory  address: bx
     5                              <1> ;  
     6                              <1> 
     7                              <1> p1ltch      equ     0x80
     8 0000E4AD 0D0A636865636B7375- <1> check_sum_error db cr,lf,"checksum errors!",eos
     8 0000E4B6 6D206572726F727321- <1>
     8 0000E4BF 00                  <1>
     9 0000E4C0 0D0A6F6B00          <1> check_sum_ok    db cr,lf,"ok",eos
    10                              <1> 
    11                              <1> 
    12                              <1> edit_memory: 
    13 0000E4C5 E84803              <1>             call    readAddress
    14 0000E4C8 89DF                <1>             mov     di, bx
    15                              <1> edit:            
    16 0000E4CA E87AED              <1>             call    newLine
    17 0000E4CD 8CC0                <1>             mov     AX, ES
    18 0000E4CF E835FD              <1>             call    print_hex
    19 0000E4D2 B03A                <1>             mov     al, ':'
    20 0000E4D4 E8C7ED              <1>             call    cout
    21 0000E4D7 89F8                <1>             mov     AX, DI
    22 0000E4D9 E82BFD              <1>             call    printw_hex
    23 0000E4DC E8EAED              <1>             call    space
    24 0000E4DF B05B                <1>             mov     al, '['
    25 0000E4E1 E8BAED              <1>             call    cout
    26 0000E4E4 268A05              <1>             mov     al, byte es:[di]
    27 0000E4E7 E82AFD              <1>             call    printb_hex
    28 0000E4EA B05D                <1>             mov     al, ']'
    29 0000E4EC E8AFED              <1>             call    cout
    30 0000E4EF E8D7ED              <1>             call    space
    31 0000E4F2 E82203              <1>             call    readByteHexX
    32 0000E4F5 7306                <1>             jnc     edit_memoryEnd
    33 0000E4F7 268805              <1>             mov     byte es:[di], al 
    34 0000E4FA 47                  <1>             inc     di
    35 0000E4FB EBCD                <1>             jmp     edit        
    36                              <1> edit_memoryEnd:
    37 0000E4FD C3                  <1>             ret
    38                              <1> 
    39                              <1> 
    40                              <1> ;LOAD FILE 
    41                              <1> 
    42 0000E4FE 0D0A4C6F616420496E- <1> load_hex db cr, lf, "Load Intel hex file...",eos
    42 0000E507 74656C206865782066- <1>
    42 0000E510 696C652E2E2E00      <1>
    43                              <1> 
    44 0000E517 BE[FEE4]            <1> load_intel_hex:     mov si, load_hex
    45 0000E51A E860ED              <1>           call pstr
    46                              <1> 
    47 0000E51D B000                <1>           mov al,0
    48 0000E51F A21F06              <1>           mov [bcs_error],al
    49                              <1> 
    50 0000E522 E80100              <1>           call get_record
    51 0000E525 C3                  <1>           ret
    52                              <1>             
    53                              <1> ; get record and write to SRAM
    54                              <1> ;
    55                              <1> esc     equ 1bh
    56                              <1> 
    57 0000E526 E884ED              <1> get_record: call cin
    58 0000E529 3C1B                <1>             cmp al,esc
    59 0000E52B 7501                <1>             jne is_colon?
    60 0000E52D C3                  <1>             ret
    61                              <1> 
    62 0000E52E 3C3A                <1> is_colon?:  cmp al, ":"
    63 0000E530 75F4                <1>             jne get_record	    ; wait until found begin of record
    64 0000E532 30C0                <1>             xor al, al           
    65 0000E534 26A21E06            <1>             mov byte es:[bcs],al        ; clear byte check sum
    66 0000E538 B90000              <1>             mov cx, 0		    ; clear counter 
    67 0000E53B E891ED              <1>             call get_hex	    ; get number of byte
    68 0000E53E 88C1                <1>             mov cl, al		    ; put to cl
    69 0000E540 2600061E06          <1>             add byte es:[bcs],al        
    70 0000E545 E887ED              <1>             call get_hex	    ; get destination address, put to bx register
    71 0000E548 88C7                <1>             mov bh, al           ; save high byte
    72 0000E54A 2600061E06          <1>             add byte es:[bcs],al        
    73 0000E54F E87DED              <1>             call get_hex        
    74 0000E552 88C3                <1>             mov bl, al           ; and low byte
    75 0000E554 2600061E06          <1>             add byte es:[bcs],al        
    76 0000E559 E873ED              <1>             call get_hex        
    77 0000E55C 2600061E06          <1>             add byte es:[bcs],al        
    78 0000E561 3C01                <1>             cmp  al,  1           ; end of record type is 01 ?
    79 0000E563 7523                <1>             jne  data_record    ; jump if not 01
    80                              <1> 
    81                              <1> wait_lf:    
    82 0000E565 E845ED              <1>             call    cin
    83 0000E568 3C0A                <1>             cmp     al,lf
    84 0000E56A 75F9                <1>             jne     wait_lf         ; until end of record sending! with lf detection
    85 0000E56C B0FF                <1>             mov     al, 0ffh        ; finish loading turn debug led off
    86 0000E56E BA8000              <1>             mov     dx, p1ltch
    87 0000E571 EE                  <1>             out     dx, al
    88 0000E572 26A01F06            <1>             mov     al,byte es:[bcs_error]
    89 0000E576 3C01                <1>             cmp     al,1
    90 0000E578 7507                <1>             jne     no_error
    91 0000E57A BE[ADE4]            <1>             mov     si, check_sum_error
    92 0000E57D E8FDEC              <1>             call    pstr
    93 0000E580 C3                  <1>             ret
    94                              <1> no_error:   
    95 0000E581 BE[C0E4]            <1>             mov     si, check_sum_ok
    96 0000E584 E8F6EC              <1>             call    pstr
    97 0000E587 C3                  <1>             ret
    98                              <1> data_record: 
    99 0000E588 E844ED              <1>             call    get_hex                ; get data byte
   100 0000E58B 268807              <1>             mov     byte es:[bx],al        ; save to SRAM at es:[bx]
   101 0000E58E 2600061E06          <1>             add     byte es:[bcs],al
   102 0000E593 43                  <1>             inc     bx                     ; next location
   103 0000E594 BA8000              <1>             mov     dx, p1ltch             ; light debug led indicates loading is running
   104 0000E597 EE                  <1>             out     dx, al
   105 0000E598 E2EE                <1>             loop    data_record            ; until cx = 0
   106 0000E59A 26A01E06            <1>             mov     al, byte es:[bcs]
   107 0000E59E F6D8                <1>             neg     al
   108 0000E5A0 26A21E06            <1>             mov     byte es:[bcs],al
   109 0000E5A4 E828ED              <1>             call    get_hex                ; get check sum
   110 0000E5A7 263A061E06          <1>             cmp     al, byte es:[bcs]
   111 0000E5AC 7406                <1>             je      record_correct
   112 0000E5AE B001                <1>             mov     al,1
   113 0000E5B0 26A21F06            <1>             mov     byte es:[bcs_error],al ; set byte check sum error flag
   114                              <1> record_correct:
   115 0000E5B4 E96FFF              <1>             jmp     get_record	; back to next record
   116                              <1> 
   117 0000E5B7 0D0A57726974652070- <1> write_text:    db cr,lf,"Write peripherals with 16-bit data"
   117 0000E5C0 65726970686572616C- <1>
   117 0000E5C9 732077697468203136- <1>
   117 0000E5D2 2D6269742064617461  <1>
   118 0000E5DB 0D0A6F666673657420- <1>                db cr,lf,"offset address FF:OFFSET=",eos
   118 0000E5E4 616464726573732046- <1>
   118 0000E5ED 463A4F46465345543D- <1>
   118 0000E5F6 00                  <1>
   119 0000E5F7 0D0A31362D62697420- <1> word_text:     db cr,lf,"16-bit data=",eos
   119 0000E600 646174613D00        <1>
   120 0000E606 0D0A6F757470757420- <1> outbyte_text:  db cr,lf,"output 16-bit data to output port"
   120 0000E60F 31362D626974206461- <1>
   120 0000E618 746120746F206F7574- <1>
   120 0000E621 70757420706F7274    <1>
   121 0000E629 0D0A706F7274206164- <1>                db cr,lf,"port address=",eos
   121 0000E632 64726573733D00      <1>
   122 0000E639 0D0A696E7075742031- <1> inbyte_text:   db cr,lf,"input 16-bit data from input port"
   122 0000E642 362D62697420646174- <1>
   122 0000E64B 612066726F6D20696E- <1>
   122 0000E654 70757420706F7274    <1>
   123 0000E65C 0D0A706F7274206164- <1>                db cr,lf,"port address=",eos
   123 0000E665 64726573733D00      <1>
   124                              <1> 
   125                              <1> ; write peripheral
   126                              <1> 
   127                              <1> write_peripherals:  
   128 0000E66C BE[B7E5]            <1>             mov si,write_text
   129 0000E66F E80BEC              <1>             call pstr
   130                              <1>             ;call getstr_hex
   131                              <1>             ;call atohex
   132 0000E672 E84C01              <1>             call inputAddress
   133 0000E675 50                  <1>             push ax
   134 0000E676 BE[F7E5]            <1>             mov  si,word_text
   135 0000E679 E801EC              <1>             call pstr
   136                              <1>             ;call getstr_hex
   137                              <1>             ;call atohex
   138 0000E67C E84201              <1>             call inputAddress
   139                              <1> 
   140 0000E67F 89C3                <1>             mov bx,ax
   141 0000E681 58                  <1>             pop ax
   142 0000E682 0D00FF              <1>             or  ax,0ff00h   ; PCB was set to FF
   143 0000E685 89C2                <1>             mov dx,ax
   144 0000E687 89D8                <1>             mov ax,bx
   145 0000E689 EF                  <1>             out dx,ax
   146 0000E68A C3                  <1>             ret
   147                              <1> 
   148                              <1> outbyte:    
   149 0000E68B BE[06E6]            <1>             mov si,outbyte_text
   150 0000E68E E8ECEB              <1>             call pstr
   151                              <1>             ;call getstr_hex
   152                              <1>             ;call atohex
   153 0000E691 E82D01              <1>             call inputAddress
   154 0000E694 E8B0EB              <1>             call newLine
   155 0000E697 E86DFB              <1>             call printw_hex
   156 0000E69A 50                  <1>             push ax
   157 0000E69B BE[F7E5]            <1>             mov  si,word_text
   158 0000E69E E8DCEB              <1>             call pstr
   159                              <1>             ;call getstr_hex
   160                              <1>             ;call atohex
   161 0000E6A1 E81D01              <1>             call inputAddress
   162 0000E6A4 E8A0EB              <1>             call newLine
   163 0000E6A7 E85DFB              <1>             call printw_hex
   164                              <1> 
   165 0000E6AA 89C3                <1>             mov bx,ax
   166 0000E6AC 58                  <1>             pop ax
   167 0000E6AD 89C2                <1>             mov dx,ax
   168 0000E6AF 89D8                <1>             mov ax,bx
   169 0000E6B1 EE                  <1>             out dx,al
   170 0000E6B2 C3                  <1>             ret
   171                              <1> 
   172                              <1> inbyte:  
   173 0000E6B3 BE[39E6]            <1>             mov si,inbyte_text
   174 0000E6B6 E8C4EB              <1>             call pstr
   175                              <1>             ;call getstr_hex
   176                              <1>             ;call atohex
   177 0000E6B9 E80501              <1>             call inputAddress
   178 0000E6BC E888EB              <1>             call newLine
   179 0000E6BF E845FB              <1>             call printw_hex
   180 0000E6C2 89C2                <1>             mov  dx, ax
   181 0000E6C4 ED                  <1>             in   ax, dx
   182 0000E6C5 E87FEB              <1>             call newLine
   183 0000E6C8 E83CFB              <1>             call printw_hex
   184 0000E6CB C3                  <1>             ret
   185 0000E6CC 0D0A696E7075742020- <1> inbyte8b_text   db cr,lf,"input  8-bit  data ",eos
   185 0000E6D5 382D62697420206461- <1>
   185 0000E6DE 74612000            <1>
   186 0000E6E2 0D0A696E7075742031- <1> inbyte16b_text  db cr,lf,"input 16-bits data ",eos
   186 0000E6EB 362D62697473206461- <1>
   186 0000E6F4 74612000            <1>
   187                              <1> 
   188 0000E6F8 0D0A46696C6C696E67- <1> mem2fill1       db cr,lf,"Filling memory :",eos
   188 0000E701 206D656D6F7279203A- <1>
   188 0000E70A 00                  <1>
   189 0000E70B 2073697A65206F6620- <1> mem2fill2       db " size of ",eos
   189 0000E714 00                  <1>
   190 0000E715 20776974682000      <1> mem2fill3       db " with ",eos
   191                              <1>                 
   192                              <1> 
   193                              <1> fill_memory:
   194 0000E71C E8F100              <1>             call    readAddress
   195 0000E71F 89DF                <1>             mov     DI, BX
   196 0000E721 BE[E2E6]            <1>             mov     si, inbyte16b_text
   197 0000E724 E856EB              <1>             call    pstr
   198 0000E727 E89700              <1>             call    inputAddress
   199 0000E72A 268A2E8F05          <1>     		mov		ch, byte es:[buff_write]
   200 0000E72F 268A0E9005          <1>     		mov		cl, byte es:[buff_write+1]
   201 0000E734 BE[CCE6]            <1>             mov     si, inbyte8b_text
   202 0000E737 E843EB              <1>             call    pstr
   203 0000E73A E80301              <1>             call    inputData
   204 0000E73D 50                  <1>             push    AX
   205                              <1>             
   206 0000E73E BE[F8E6]            <1>             mov     si, mem2fill1
   207 0000E741 E839EB              <1>             call    pstr
   208 0000E744 89F8                <1>             mov     AX, DI
   209 0000E746 E8BEFA              <1>             call    printw_hex
   210                              <1> 
   211                              <1>     		
   212 0000E749 BE[0BE7]            <1>             mov     si, mem2fill2
   213 0000E74C E82EEB              <1>             call    pstr
   214 0000E74F 89C8                <1>             mov     AX, CX
   215 0000E751 E8B3FA              <1>             call    printw_hex
   216                              <1> 
   217 0000E754 BE[15E7]            <1>             mov     si, mem2fill3
   218 0000E757 E823EB              <1>             call    pstr 		
   219 0000E75A 58                  <1>             pop     AX
   220 0000E75B E8B6FA              <1>             call    printb_hex
   221 0000E75E E8E6EA              <1>     		call	newLine
   222                              <1> loopFM:            
   223 0000E761 268805              <1>             mov     byte es:[di], al 
   224 0000E764 47                  <1>             inc     di
   225 0000E765 49                  <1>             dec     cx
   226 0000E766 75F9                <1>             jnz loopFM
   227 0000E768 C3                  <1>             ret
   228                              <1> 
   277                                  %include "minputs.asm"
     1 0000E769 0D0A44696769746520- <1> msg01	db 0Dh,0Ah,"Digite o endereco: ", 0
     1 0000E772 6F20656E6465726563- <1>
     1 0000E77B 6F3A2000            <1>
     2 0000E77F 0D0A3C4553433E7061- <1> msg02   db 0Dh,0Ah,"<ESC>para novo segment <Enter>continua ES: ", 0
     2 0000E788 7261206E6F766F2073- <1>
     2 0000E791 65676D656E74203C45- <1>
     2 0000E79A 6E7465723E636F6E74- <1>
     2 0000E7A3 696E75612045533A20- <1>
     2 0000E7AC 00                  <1>
     3 0000E7AD 0D0A4E6F766F207365- <1> msg03   db 0Dh,0Ah,"Novo segment ES: ", 0
     3 0000E7B6 676D656E742045533A- <1>
     3 0000E7BF 2000                <1>
     4                              <1> 
     5                              <1> 
     6                              <1> inputAddress:
     7 0000E7C1 E894EA              <1>         call readLine
     8 0000E7C4 E8F9FA              <1>         call convertWordToHex
     9 0000E7C7 268A268F05          <1> 	mov 	ah, byte es:[buff_write]
    10 0000E7CC 26A09005            <1> 	mov	al, byte es:[buff_write+1]
    11 0000E7D0 C3                  <1>         ret
    12                              <1> 
    13                              <1> loadBX:
    14 0000E7D1 06                  <1>         push    ES
    15 0000E7D2 B80000              <1>         mov     AX, 0x0
    16 0000E7D5 8EC0                <1>         mov     ES, AX
    17 0000E7D7 BE[69E7]            <1>         mov     si, msg01
    18 0000E7DA E8A0EA              <1>         call    pstr
    19 0000E7DD E8E1FF              <1>         call    inputAddress
    20 0000E7E0 89C3                <1>         mov     BX, AX
    21                              <1>         ;call    print_hex
    22 0000E7E2 07                  <1>         pop     ES
    23 0000E7E3 C3                  <1>         ret        
    24                              <1> showES:
    25 0000E7E4 53                  <1>         push BX
    26 0000E7E5 BE[7FE7]            <1>         mov  si, msg02
    27 0000E7E8 E892EA              <1>         call pstr
    28 0000E7EB 8CC0                <1>         mov  AX, ES
    29 0000E7ED E817FA              <1>         call print_hex
    30 0000E7F0 31C0                <1>         XOR  AX, AX
    31 0000E7F2 E8C7EA              <1>         call cin_blct
    32 0000E7F5 3C0D                <1>         cmp  al, 0x0d
    33 0000E7F7 7403                <1>         je   .retorna
    34 0000E7F9 E80200              <1>         call    changeES
    35                              <1> .retorna:
    36 0000E7FC 5B                  <1>         pop BX
    37 0000E7FD C3                  <1>         ret
    38                              <1> 
    39                              <1> changeES:
    40 0000E7FE 53                  <1>         push    BX
    41 0000E7FF 31C0                <1>         xor     AX, AX
    42 0000E801 8EC0                <1>         mov     ES, AX
    43 0000E803 BE[ADE7]            <1>         mov     si, msg03
    44 0000E806 E874EA              <1>         call    pstr
    45 0000E809 E8B5FF              <1>         call    inputAddress
    46 0000E80C 8EC0                <1>         mov     ES, AX
    47 0000E80E 5B                  <1>         pop     BX
    48 0000E80F C3                  <1>         ret
    49                              <1> 
    50                              <1> ;Return the address in: ES:BX
    51                              <1> readAddress:
    52 0000E810 E8D1FF              <1>         call    showES
    53 0000E813 E8BBFF              <1>         call    loadBX
    54 0000E816 C3                  <1>         ret
    55                              <1> 
    56                              <1> readByteHexX:
    57 0000E817 F8                  <1>         clc
    58 0000E818 E8A1EA              <1>         call cin_blct
    59 0000E81B 3C1B                <1>         cmp  al, 0x1b
    60 0000E81D 7420                <1>         je   readByteHexEnd   
    61 0000E81F E8C7FA              <1>         call to_hex
    62 0000E822 88C4                <1>         mov  ah, al
    63 0000E824 E8F3F9              <1>         call print_digit
    64 0000E827 E892EA              <1>         call cin_blct
    65 0000E82A 3C1B                <1>         cmp  al, 0x1b
    66 0000E82C 7411                <1>         je   readByteHexEnd   
    67 0000E82E E8B8FA              <1>         call to_hex
    68 0000E831 D0E4                <1>         shl  ah, 1
    69 0000E833 D0E4                <1>         shl  ah, 1
    70 0000E835 D0E4                <1>         shl  ah, 1
    71 0000E837 D0E4                <1>         shl  ah, 1
    72 0000E839 08E0                <1>         or   al, ah
    73 0000E83B E8DCF9              <1>         call  print_digit
    74 0000E83E F9                  <1>         stc
    75                              <1> readByteHexEnd:        
    76 0000E83F C3                  <1>         ret          
    77                              <1> 
    78                              <1> 
    79                              <1> ;Return byte in hexadecmal in: AL
    80                              <1> inputData:
    81 0000E840 E815EA              <1>         call readLine
    82 0000E843 E863FA              <1>         call convertByteToHex
    83 0000E846 26A08F05            <1>         mov  al, byte es:[buff_write]
    84 0000E84A C3                  <1>         ret
    85                              <1>            
    86                              <1> ;;;****************************************************************
    87                              <1> ;;; TESTES
    88                              <1> ;;;****************************************************************
    89                              <1> 
    90 0000E84B FA33C08ED0BC007C8B- <1> sector1bkp db 0xFA,0x33,0xC0,0x8E,0xD0,0xBC,0x00,0x7C,0x8B,0xF4,0x50,0x07,0x50,0x1F,0xFB,0xFC 
    90 0000E854 F45007501FFBFC      <1>
    91 0000E85B BF0006B90001F2A5EA- <1>         db 0xBF,0x00,0x06,0xB9,0x00,0x01,0xF2,0xA5,0xEA,0x1D,0x06,0x00,0x00,0xBE,0xBE,0x07 
    91 0000E864 1D060000BEBE07      <1>
    92 0000E86B B304803C80740E803C- <1>         db 0xB3,0x04,0x80,0x3C,0x80,0x74,0x0E,0x80,0x3C,0x00,0x75,0x1C,0x83,0xC6,0x10,0xFE 
    92 0000E874 00751C83C610FE      <1>
    93 0000E87B CB75EFCD188B148B4C- <1>         db 0xCB,0x75,0xEF,0xCD,0x18,0x8B,0x14,0x8B,0x4C,0x02,0x8B,0xEE,0x83,0xC6,0x10,0xFE 
    93 0000E884 028BEE83C610FE      <1>
    94 0000E88B CB741A803C0074F4BE- <1>         db 0xCB,0x74,0x1A,0x80,0x3C,0x00,0x74,0xF4,0xBE,0x8B,0x06,0xAC,0x3C,0x00,0x74,0x0B
    94 0000E894 8B06AC3C00740B      <1>
    95 0000E89B 56BB0700B40ECD105E- <1>         db 0x56,0xBB,0x07,0x00,0xB4,0x0E,0xCD,0x10,0x5E,0xEB,0xF0,0xEB,0xFE,0xBF,0x05,0x00
    95 0000E8A4 EBF0EBFEBF0500      <1>
    96 0000E8AB BB007CB8010257CD13- <1>         db 0xBB,0x00,0x7C,0xB8,0x01,0x02,0x57,0xCD,0x13,0x5F,0x73,0x0C,0x33,0xC0,0xCD,0x13
    96 0000E8B4 5F730C33C0CD13      <1>
    97 0000E8BB 4F75EDBEA306EBD3BE- <1>         db 0x4F,0x75,0xED,0xBE,0xA3,0x06,0xEB,0xD3,0xBE,0xC2,0x06,0xBF,0xFE,0x7D,0x81,0x3D
    97 0000E8C4 C206BFFE7D813D      <1>
    98 0000E8CB 55AA75C78BF5EA007C- <1>         db 0x55,0xAA,0x75,0xC7,0x8B,0xF5,0xEA,0x00,0x7C,0x00,0x00,0x49,0x6E,0x76,0x61,0x6C
    98 0000E8D4 0000496E76616C      <1>
    99 0000E8DB 696420706172746974- <1>         db 0x69,0x64,0x20,0x70,0x61,0x72,0x74,0x69,0x74,0x69,0x6F,0x6E,0x20,0x74,0x61,0x62
    99 0000E8E4 696F6E20746162      <1>
   100 0000E8EB 6C65004572726F7220- <1>         db 0x6C,0x65,0x00,0x45,0x72,0x72,0x6F,0x72,0x20,0x6C,0x6F,0x61,0x64,0x69,0x6E,0x67
   100 0000E8F4 6C6F6164696E67      <1>
   101 0000E8FB 206F7065726174696E- <1>         db 0x20,0x6F,0x70,0x65,0x72,0x61,0x74,0x69,0x6E,0x67,0x20,0x73,0x79,0x73,0x74,0x65
   101 0000E904 67207379737465      <1>
   102 0000E90B 6D004D697373696E67- <1>         db 0x6D,0x00,0x4D,0x69,0x73,0x73,0x69,0x6E,0x67,0x20,0x6F,0x70,0x65,0x72,0x61,0x74
   102 0000E914 206F7065726174      <1>
   103 0000E91B 696E67207379737465- <1>         db 0x69,0x6E,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6D,0x00,0x00,0x00,0x00,0x00,0x00
   103 0000E924 6D000000000000      <1>
   104 0000E92B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   104 0000E934 00000000000000      <1>
   105 0000E93B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   105 0000E944 00000000000000      <1>
   106 0000E94B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   106 0000E954 00000000000000      <1>
   107 0000E95B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   107 0000E964 00000000000000      <1>
   108 0000E96B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   108 0000E974 00000000000000      <1>
   109 0000E97B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   109 0000E984 00000000000000      <1>
   110 0000E98B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   110 0000E994 00000000000000      <1>
   111 0000E99B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   111 0000E9A4 00000000000000      <1>
   112 0000E9AB 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   112 0000E9B4 00000000000000      <1>
   113 0000E9BB 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   113 0000E9C4 00000000000000      <1>
   114 0000E9CB 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   114 0000E9D4 00000000000000      <1>
   115 0000E9DB 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   115 0000E9E4 00000000000000      <1>
   116 0000E9EB 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   116 0000E9F4 00000000000000      <1>
   117 0000E9FB 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01
   117 0000EA04 00000000008001      <1>
   118 0000EA0B 01000B7FBFFD3F0000- <1>         db 0x01,0x00,0x0B,0x7F,0xBF,0xFD,0x3F,0x00,0x00,0x00,0xC1,0x40,0x5E,0x00,0x00,0x00 
   118 0000EA14 00C1405E000000      <1>
   119 0000EA1B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
   119 0000EA24 00000000000000      <1>
   120 0000EA2B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
   120 0000EA34 00000000000000      <1>
   121 0000EA3B 000000000000000000- <1>         db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xAA 
   121 0000EA44 000000000055AA      <1>
   122                              <1> 
   123 0000EA4B FCBB147CB410CD10B8- <1> sector11  db 0xfc,0xbb,0x14,0x7c,0xb4,0x10,0xcd,0x10,0xb8,0x00,0xf0,0x8e,0xd8,0x8e,0xc8,0xea
   123 0000EA54 00F08ED88EC8EA      <1>
   124 0000EA5B 9ED000F00D0A426F6F- <1>          db 0x9e,0xd0,0x00,0xf0,0x0d,0x0a,0x42,0x6f,0x6f,0x74,0x20,0x72,0x65,0x63,0x6f,0x72
   124 0000EA64 74207265636F72      <1>
   125 0000EA6B 64206C6F6164656420- <1>          db 0x64,0x20,0x6c,0x6f,0x61,0x64,0x65,0x64,0x20,0x66,0x72,0x6f,0x6d,0x20,0x70,0x65
   125 0000EA74 66726F6D207065      <1>
   126 0000EA7B 6E64726976652E0D0A- <1>          db 0x6e,0x64,0x72,0x69,0x76,0x65,0x2e,0x0d,0x0a,0x52,0x65,0x74,0x75,0x72,0x6e,0x69
   126 0000EA84 52657475726E69      <1>
   127 0000EA8B 6E6720746F206D6F6E- <1>          db 0x6e,0x67,0x20,0x74,0x6f,0x20,0x6d,0x6f,0x6e,0x69,0x74,0x6f,0x72,0x2e,0x00,0xff
   127 0000EA94 69746F722E00FF      <1>
   128 0000EA9B FFFFFFFFFFFFFFFFFF- <1>          db 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   128 0000EAA4 FFFFFFFFFFFFFF      <1>
   129                              <1> 
   130                              <1> 
   131 0000EAAB FCBB0D7CB410CD10EA- <1> sector1  db 0xfc,0xbb,0x0d,0x7c,0xb4,0x10,0xcd,0x10,0xea,0x00,0xd0,0x00,0xf0,0x0d,0x0a,0x42
   131 0000EAB4 00D000F00D0A42      <1>
   132 0000EABB 6F6F74207265636F72- <1>          db 0x6f,0x6f,0x74,0x20,0x72,0x65,0x63,0x6f,0x72,0x64,0x20,0x6c,0x6f,0x61,0x64,0x65
   132 0000EAC4 64206C6F616465      <1>
   133 0000EACB 642066726F6D207065- <1>          db 0x64,0x20,0x66,0x72,0x6f,0x6d,0x20,0x70,0x65,0x6e,0x64,0x72,0x69,0x76,0x65,0x2e
   133 0000EAD4 6E64726976652E      <1>
   134 0000EADB 0D0A52657475726E69- <1>          db 0x0d,0x0a,0x52,0x65,0x74,0x75,0x72,0x6e,0x69,0x6e,0x67,0x20,0x74,0x6f,0x20,0x6d
   134 0000EAE4 6E6720746F206D      <1>
   135 0000EAEB 6F6E69746F722E00FF- <1>          db 0x6f,0x6e,0x69,0x74,0x6f,0x72,0x2e,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   135 0000EAF4 FFFFFFFFFFFFFF      <1>
   136 0000EAFB FFFFFFFFFFFFFFFFFF- <1>          db 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   136 0000EB04 FFFFFFFFFFFFFF      <1>
   137 0000EB0B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   137 0000EB14 00000000000000      <1>
   138 0000EB1B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   138 0000EB24 00000000000000      <1>
   139 0000EB2B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   139 0000EB34 00000000000000      <1>
   140 0000EB3B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   140 0000EB44 00000000000000      <1>
   141 0000EB4B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   141 0000EB54 00000000000000      <1>
   142 0000EB5B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   142 0000EB64 00000000000000      <1>
   143 0000EB6B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   143 0000EB74 00000000000000      <1>
   144 0000EB7B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   144 0000EB84 00000000000000      <1>
   145 0000EB8B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   145 0000EB94 00000000000000      <1>
   146 0000EB9B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   146 0000EBA4 00000000000000      <1>
   147 0000EBAB 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   147 0000EBB4 00000000000000      <1>
   148 0000EBBB 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   148 0000EBC4 00000000000000      <1>
   149 0000EBCB 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   149 0000EBD4 00000000000000      <1>
   150 0000EBDB 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   150 0000EBE4 00000000000000      <1>
   151 0000EBEB 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   151 0000EBF4 00000000000000      <1>
   152 0000EBFB 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   152 0000EC04 00000000000000      <1>
   153 0000EC0B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   153 0000EC14 00000000000000      <1>
   154 0000EC1B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   154 0000EC24 00000000000000      <1>
   155 0000EC2B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   155 0000EC34 00000000000000      <1>
   156 0000EC3B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   156 0000EC44 00000000000000      <1>
   157 0000EC4B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   157 0000EC54 00000000000000      <1>
   158 0000EC5B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01
   158 0000EC64 00000000008001      <1>
   159 0000EC6B 01000B7FBFFD3F0000- <1>          db 0x01,0x00,0x0b,0x7f,0xbf,0xfd,0x3f,0x00,0x00,0x00,0xc1,0x40,0x5e,0x00,0x00,0x00
   159 0000EC74 00C1405E000000      <1>
   160 0000EC7B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   160 0000EC84 00000000000000      <1>
   161 0000EC8B 000000000000000000- <1>          db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xaa
   161 0000EC94 000000000055AA      <1>
   162                              <1> 
   163                              <1> ;00000000  0xfc,0xbb,0x09,0x7c,0xb4,0x10,0xcd,0x0a,0xc3,0x0d,0x0a,0x42,0x6f,0x6f,0x74,0x20
   164                              <1> ;00000010  0x72,0x65,0x63,0x6f,0x72,0x64,0x20,0x6c,0x6f,0x61,0x64,0x65,0x64,0x20,0x66,0x72
   165                              <1> ;00000020  0x6f,0x6d,0x20,0x70,0x65,0x6e,0x64,0x72,0x69,0x76,0x65,0x2e,0x00,0x0d,0x0a,0x52
   166                              <1> ;00000030  0x65,0x74,0x75,0x72,0x6e,0x69,0x6e,0x67,0x20,0x74,0x6f,0x20,0x6d,0x6f,0x6e,0x69
   167                              <1> ;00000040  0x74,0x6f,0x72,0x2e,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   168                              <1> ;00000050  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   169                              <1> ;00000060  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   170                              <1> ;00000070  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   171                              <1> ;00000080  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   172                              <1> ;00000090  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   173                              <1> ;000000A0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   174                              <1> ;000000B0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   175                              <1> ;000000C0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   176                              <1> ;000000D0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   177                              <1> ;000000E0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   178                              <1> ;000000F0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   179                              <1> ;00000100  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   180                              <1> ;00000110  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   181                              <1> ;00000120  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   182                              <1> ;00000130  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   183                              <1> ;00000140  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   184                              <1> ;00000150  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   185                              <1> ;00000160  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   186                              <1> ;00000170  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   187                              <1> ;00000180  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   188                              <1> ;00000190  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   189                              <1> ;000001A0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   190                              <1> ;000001b0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01
   191                              <1> ;000001c0  0x01,0x00,0x0b,0x7f,0xbf,0xfd,0x3f,0x00,0x00,0x00,0xc1,0x40,0x5e,0x00,0x00,0x00
   192                              <1> ;000001d0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   193                              <1> ;000001e0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   194                              <1> ;000001f0  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xaa
   195                              <1> ;
   196                              <1> 
   278                                  ;===========================
   279                                  %include "code/bios.asm"
     1                              <1> 
     2                              <1> 
     3                              <1> BiosLoad:
     4 0000EC9B E80700              <1> 		CALL LOAD_INT_VECTOR_TABLE	;COPIES INTERRUPT VECTOR TABLE TO ADDRESS 0X0000:0X0000
     5 0000EC9E E81A00              <1> 		CALL LOAD_BIOS_DATA_AREA	;COPIES BIOS DATA TO ADDRESS 0X0000:0X0400
     6 0000ECA1 E847E6              <1> 		call INITIALIZE_CH376S_0XE0
     7 0000ECA4 C3                  <1>         ret
     8                              <1> 
     9                              <1> 
    10                              <1> LOAD_INT_VECTOR_TABLE:
    11 0000ECA5 FC                  <1> 	CLD
    12 0000ECA6 B80000              <1> 	MOV AX, 0X0000
    13 0000ECA9 8EC0                <1> 	MOV ES, AX
    14 0000ECAB BF0000              <1> 	MOV DI, 0X0000
    15 0000ECAE 8CC8                <1> 	MOV AX, CS
    16 0000ECB0 8ED8                <1> 	MOV DS, AX
    17 0000ECB2 BE[C9ED]            <1> 	MOV SI, INT_VECTOR_TABLE
    18 0000ECB5 B98000              <1> 	MOV CX, INT_VECTOR_TABLE.END - INT_VECTOR_TABLE
    19 0000ECB8 F3A4                <1> 	REP MOVSB
    20 0000ECBA C3                  <1> 	RET
    21                              <1> 
    22                              <1> LOAD_BIOS_DATA_AREA:
    23 0000ECBB FC                  <1> 	CLD
    24 0000ECBC B84000              <1> 	MOV AX, 0X0040
    25 0000ECBF 8EC0                <1> 	MOV ES, AX
    26 0000ECC1 BF0000              <1> 	MOV DI, 0X0000
    27 0000ECC4 8CC8                <1> 	MOV AX, CS
    28 0000ECC6 8ED8                <1> 	MOV DS, AX
    29 0000ECC8 BE[D1EC]            <1> 	MOV SI, BIOS_DATA_AREA
    30 0000ECCB B99800              <1> 	MOV CX, BIOS_DATA_AREA.END - BIOS_DATA_AREA
    31 0000ECCE F3A4                <1> 	REP MOVSB
    32 0000ECD0 C3                  <1> 	RET
    33                              <1> 
    34                              <1> 
    35                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    36                              <1> ;BIOS DATA AREA
    37                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    38                              <1> %INCLUDE "code/asm/bios_data.asm"
     1                              <2> BIOS_DATA_AREA:
     2                              <2> 	;0x0400 (4 words)	IO ports for COM1-COM4 serial (each address is 1 word, zero if none)
     3 0000ECD1 0000                <2> 	DW 0X0000
     4 0000ECD3 0000                <2> 	DW 0X0000
     5 0000ECD5 0000                <2> 	DW 0X0000
     6 0000ECD7 0000                <2> 	DW 0X0000
     7                              <2> 
     8                              <2> 	;0x0408 (4 words)	IO ports for LPT1-LPT4 parallel (each address is 1 word, zero if none)
     9 0000ECD9 0000                <2> 	DW 0X0000
    10 0000ECDB 0000                <2> 	DW 0X0000
    11 0000ECDD 0000                <2> 	DW 0X0000
    12 0000ECDF 0000                <2> 	DW 0X0000	;!!
    13                              <2> 
    14                              <2> 	;0x0410 (word)		(Equip Flag) packed bit flags for detected hardware
    15                              <2> 	;look up number google, right now one floppy drive, 80x25 color, no coprocessor
    16 0000ECE1 2D00                <2> 	DW 0X002D
    17                              <2> 
    18                              <2> 	;0x0412	 (byte)		MFG test
    19 0000ECE3 01                  <2> 	DB 0x01
    20                              <2> 
    21                              <2> 	;0x0413 (word)		Memory Size
    22 0000ECE4 0002                <2> 	DW 0x0200			;200 512K, 
    23                              <2> 
    24                              <2> 	;0x0415 (word)		IO Ram Size
    25 0000ECE6 0000                <2> 	DW 0x0000
    26                              <2> 
    27                              <2> 	;0x0417 (byte)		keyboard state flag 0
    28 0000ECE8 00                  <2> 	DB 0X00
    29                              <2> 
    30                              <2> 	;0x0418 (byte)		keyboard state flag 1
    31 0000ECE9 00                  <2> 	DB 0X00	
    32                              <2> 
    33                              <2> 	;0x0419 (byte)		ALT_INPUT
    34 0000ECEA 00                  <2> 	DB 0X00	
    35                              <2> 
    36                              <2> 	;0x041A (word) 		keyboard head 
    37 0000ECEB 1E00                <2> 	DW 0x001E
    38                              <2> 
    39                              <2> 	;0x041C (word)		keyboard tail
    40 0000ECED 1E00                <2> 	DW 0x001E 
    41                              <2> 
    42                              <2> 	;0x041E (32 bytes)	keyboard buffer
    43 0000ECEF 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    44 0000ECF3 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    45 0000ECF7 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    46 0000ECFB 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    47 0000ECFF 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    48 0000ED03 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    49 0000ED07 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    50 0000ED0B 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    51                              <2> 
    52                              <2> 	;0x043E 		DISKETTE DATA AREAS
    53 0000ED0F 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    54 0000ED13 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    55 0000ED17 000000              <2> 	DB 0X00, 0X00, 0X00
    56                              <2> 
    57                              <2> 	;0x0449 (byte)		Display Mode [VIDEO DISPLAY DATA AREA]
    58 0000ED1A 03                  <2> 	DB 0X03				;80x25  8x8   640x200   16 Colors 0xB800 CGA
    59                              <2> 
    60                              <2> 	;0x044A (word)		number of columns in text mode
    61 0000ED1B 1400                <2> 	DW 0X0014
    62                              <2> 
    63                              <2> 	;0X044C (word)
    64 0000ED1D 0000                <2> 	DW 0X0000
    65                              <2> 
    66                              <2> 	;0X044E (word)
    67 0000ED1F 0000                <2> 	DW 0X0000	
    68                              <2> 
    69                              <2> 	;0X0450 (16 BYTE AS WORD)	:CURSOR_POSN 8 PAGES   col, row
    70 0000ED21 00000000            <2> 	DW 0X0000, 0X0000
    71 0000ED25 00000000            <2> 	DW 0X0000, 0X0000
    72 0000ED29 00000000            <2> 	DW 0X0000, 0X0000
    73 0000ED2D 00000000            <2> 	DW 0X0000, 0X0000
    74                              <2> 
    75                              <2> 	;0X0460 (word)		Cursor Mode
    76 0000ED31 0000                <2> 	DW 0X0000
    77                              <2> 	;0x0462			Active Page
    78 0000ED33 00                  <2> 	DB 0X00
    79                              <2> 
    80                              <2> 	;0x0463 (2 bytes, taken as a word)	base IO port for video
    81 0000ED34 00                  <2> 	DB 0X00
    82 0000ED35 00                  <2> 	DB 0X00
    83                              <2> 
    84                              <2> 	;0x0465	(byte)
    85 0000ED36 00                  <2> 	DB 0x00
    86                              <2> 
    87                              <2> 	;0x0466	(byte)
    88 0000ED37 00                  <2> 	DB 0x00
    89                              <2> 
    90                              <2> 	;0x0467	(word)
    91 0000ED38 0000                <2> 	DW 0x0000
    92                              <2> 
    93                              <2> 	;0x0469	(word)
    94 0000ED3A 0000                <2> 	DW 0x0000
    95                              <2> 
    96                              <2> 	;0x046B	(byte)
    97 0000ED3C 00                  <2> 	DB 0x00
    98                              <2> 
    99                              <2> 	;0x046C (word)		# of IRQ0 timer ticks since boot
   100 0000ED3D 0000                <2> 	DW 0X0000
   101 0000ED3F 0000                <2> 	DW 0X0000
   102                              <2> 
   103                              <2> 	;LATER 0x0470
   104 0000ED41 0000                <2> 	DB 0X00, 0X00
   105 0000ED43 000000              <2> 	DB 0X00, 0X00, 0X00
   106                              <2> 	;
   107                              <2> 	
   108                              <2> 	;0x0475 (byte)		# of hard disk drives detected
   109 0000ED46 00                  <2> 	DB 0X00
   110                              <2> 	
   111                              <2> 	;LATER 0x0476
   112 0000ED47 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   113 0000ED4B 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   114 0000ED4F 0000                <2> 	DB 0X00, 0X00
   115                              <2> 	;
   116                              <2> 	
   117                              <2> 	;0x0480 (word)		keyboard buffer start
   118 0000ED51 1E00                <2> 	DW 0X001E
   119                              <2> 	;0x0482 (word)		keyboard buffer end
   120 0000ED53 3E00                <2> 	DW 0X003E
   121                              <2> 	
   122                              <2> 	;LATER 0x0484
   123 0000ED55 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   124 0000ED59 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   125 0000ED5D 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   126 0000ED61 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   127 0000ED65 000000              <2> 	DB 0X00, 0X00, 0X00
   128                              <2> 	
   129                              <2> 	;0x0497 (byte)		last keyboard LED/Shift key state
   130 0000ED68 00                  <2> 	DB 0X00	
   131                              <2> 
   132                              <2> .END:
   133                              <2> 
   134                              <2> 
   135                              <2> 
   136                              <2> 
   137                              <2> 
   138                              <2> .CHARACTER_CODES_UPPERCASE:
   139 0000ED69 001B21402324255E26- <2> DB 0X00, 0X1B, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 0X08, 0X09 ;0X00-0X0F
   139 0000ED72 2A28295F2B0809      <2>
   140 0000ED79 51574552545955494F- <2> DB 'Q','W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', 0X0D, 0x00, 'A', 'S'    ;0X10-0X1F
   140 0000ED82 507B7D0D004153      <2>
   141 0000ED89 444647484A4B4C3A22- <2> DB 'D','F', 'G', 'H', 'J', 'K', 'L', ':', '"', '~', 0x00, '|', 'Z', 'X', 'C', 'V'     ;0X20-0X2F
   141 0000ED92 7E007C5A584356      <2>
   142                              <2> .CHARACTER_CODES_LOWERCASE:
   143 0000ED99 001B31323334353637- <2> DB 0X00, 0X1B, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0X08, 0X09 ;0X00-0X0F
   143 0000EDA2 3839302D3D0809      <2>
   144 0000EDA9 71776572747975696F- <2> DB 'q','w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', 0X0D, 0x00, 'a', 's'    ;0X10-0X1F
   144 0000EDB2 705B5D0D006173      <2>
   145 0000EDB9 646667686A6B6C3B27- <2> DB 'd','f', 'g', 'h', 'j', 'k', 'l', ';', 0x27, '`', 0x00, 0X5C, 'z', 'x', 'c', 'v'   ;0X20-0X2F
   145 0000EDC2 60005C7A786376      <2>
   146                              <2> .CHARACTER_CODES_CTRL:
    39                              <1> 
    40                              <1> 
    41                              <1> INT_VECTOR_TABLE:
    42 0000EDC9 [49EE]00F0          <1> 	DW INT00, 0xF000
    43 0000EDCD [58EE]00F0          <1> 	DW INT01, 0xF000
    44 0000EDD1 [67EE]00F0          <1> 	DW INT02, 0xF000
    45 0000EDD5 [76EE]00F0          <1> 	DW INT03, 0xF000
    46 0000EDD9 [85EE]00F0          <1> 	DW INT04, 0xF000
    47 0000EDDD [94EE]00F0          <1> 	DW INT05, 0xF000
    48 0000EDE1 [A3EE]00F0          <1> 	DW INT06, 0xF000
    49 0000EDE5 [B2EE]00F0          <1> 	DW INT07, 0xF000
    50 0000EDE9 [C1EE]00F0          <1> 	DW INT08, 0xF000
    51 0000EDED [E0EE]00F0          <1> 	DW INT09, 0xF000
    52 0000EDF1 [1CF0]00F0          <1> 	DW INT0A, 0xF000
    53 0000EDF5 [2BF0]00F0          <1> 	DW INT0B, 0xF000
    54 0000EDF9 [3AF0]00F0          <1> 	DW INT0C, 0xF000
    55 0000EDFD [49F0]00F0          <1> 	DW INT0D, 0xF000
    56 0000EE01 [58F0]00F0          <1> 	DW INT0E, 0xF000
    57 0000EE05 [67F0]00F0          <1> 	DW INT0F, 0xF000
    58 0000EE09 [76F0]00F0          <1> 	DW INT10, 0xF000
    59 0000EE0D [64F7]00F0          <1> 	DW INT11, 0xF000
    60 0000EE11 [73F7]00F0          <1> 	DW INT12, 0xF000
    61 0000EE15 [0AD6]00F0          <1> 	DW INT13, 0xF000
    62 0000EE19 [82F7]00F0          <1> 	DW INT14, 0xF000
    63 0000EE1D [83F7]00F0          <1> 	DW INT15, 0xF000
    64 0000EE21 [9EF7]00F0          <1> 	DW INT16, 0xF000
    65 0000EE25 [0FF8]00F0          <1> 	DW INT17, 0xF000
    66 0000EE29 [10F8]00F0          <1> 	DW INT18, 0xF000
    67 0000EE2D [1FF8]00F0          <1> 	DW INT19, 0xF000
    68 0000EE31 [24F8]00F0          <1> 	DW INT1A, 0xF000
    69 0000EE35 [3EF8]00F0          <1> 	DW INT1B, 0xF000
    70 0000EE39 [4DF8]00F0          <1> 	DW INT1C, 0xF000
    71 0000EE3D [4EF8]00F0          <1> 	DW INT1D, 0xF000
    72 0000EE41 [5DF8]00F0          <1> 	DW INT1E, 0xF000
    73 0000EE45 [6CF8]00F0          <1> 	DW INT1F, 0xF000
    74                              <1> .END:
    75                              <1> INT00: ;Divide by Zero
    76 0000EE49 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
    77 0000EE4B B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
    78 0000EE4D CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    79 0000EE4F B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
    80 0000EE51 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    81 0000EE53 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR
    82 0000EE55 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    83                              <1> 	;HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
    84 0000EE57 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
    85                              <1> 
    86                              <1> INT01: ;Single Step
    87 0000EE58 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
    88 0000EE5A B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
    89 0000EE5C CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    90 0000EE5E B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
    91 0000EE60 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    92 0000EE62 B031                <1> 	MOV AL, '1'		;SET AL TO CHAR
    93 0000EE64 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    94                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
    95 0000EE66 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
    96                              <1> 
    97                              <1> INT02: ;Nonmaskable 
    98 0000EE67 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
    99 0000EE69 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   100 0000EE6B CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   101 0000EE6D B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   102 0000EE6F CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   103 0000EE71 B032                <1> 	MOV AL, '2'		;SET AL TO CHAR
   104 0000EE73 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   105                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   106 0000EE75 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   107                              <1> 
   108                              <1> INT03: ;Breakpoint
   109 0000EE76 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   110 0000EE78 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   111 0000EE7A CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   112 0000EE7C B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   113 0000EE7E CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   114 0000EE80 B033                <1> 	MOV AL, '3'		;SET AL TO CHAR
   115 0000EE82 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   116                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   117 0000EE84 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   118                              <1> 
   119                              <1> INT04: ;Overflow
   120 0000EE85 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   121 0000EE87 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   122 0000EE89 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   123 0000EE8B B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   124 0000EE8D CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   125 0000EE8F B034                <1> 	MOV AL, '4'		;SET AL TO CHAR
   126 0000EE91 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   127                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   128 0000EE93 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   129                              <1> 
   130                              <1> INT05: ;Print Screen
   131 0000EE94 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   132 0000EE96 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   133 0000EE98 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   134 0000EE9A B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   135 0000EE9C CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   136 0000EE9E B035                <1> 	MOV AL, '5'		;SET AL TO CHAR
   137 0000EEA0 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   138                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   139 0000EEA2 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   140                              <1> 
   141                              <1> INT06: ;Reserved
   142 0000EEA3 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   143 0000EEA5 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   144 0000EEA7 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   145 0000EEA9 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   146 0000EEAB CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   147 0000EEAD B036                <1> 	MOV AL, '6'		;SET AL TO CHAR
   148 0000EEAF CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   149                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   150 0000EEB1 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   151                              <1> 
   152                              <1> INT07: ;Reserved
   153 0000EEB2 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   154 0000EEB4 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   155 0000EEB6 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   156 0000EEB8 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   157 0000EEBA CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   158 0000EEBC B037                <1> 	MOV AL, '7'		;SET AL TO CHAR
   159 0000EEBE CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   160                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   161 0000EEC0 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   162                              <1> 
   163                              <1> INT08: ;Reserved
   164 0000EEC1 50                  <1> 	PUSH AX			;STORE AX
   165 0000EEC2 53                  <1> 	PUSH BX			;STORE BX
   166 0000EEC3 1E                  <1> 	PUSH DS			;STORE DS
   167 0000EEC4 B84000              <1> 	MOV AX, 0X0040			;BIOS DATA AREA
   168 0000EEC7 8ED8                <1> 	MOV DS, AX			;SET DATA SEGMENT 
   169 0000EEC9 BB6C00              <1> 	MOV BX, 0X006C			;SET BX TO TICK COUNTER
   170 0000EECC FF07                <1> 	INC WORD [BX]			;INC LOWER WORD TICK BY ONE
   171 0000EECE 833F00              <1> 	CMP WORD [BX], 0X0000			;CMP TO 0 TO SEE IF ROLLED OVER 	
   172 0000EED1 7505                <1> 	JNZ .END_INT08			;IF NOT END
   173 0000EED3 83C302              <1> 	ADD BX, 0X0002			;ADD 2 TO BX FOR NEXT WORD
   174 0000EED6 FF07                <1> 	INC WORD [BX]			;INC UPPER WORD
   175                              <1>   .END_INT08:				;END LABEL
   176 0000EED8 1F                  <1> 	POP DS			;RESTORE DS
   177 0000EED9 5B                  <1> 	POP BX			;RESTORE BX
   178                              <1> 
   179                              <1> 
   180 0000EEDA B020                <1>     MOV AL, 0x20
   181 0000EEDC E620                <1>     OUT 0x20, AL	
   182 0000EEDE 58                  <1> 	POP AX			;RESTORE AX
   183 0000EEDF CF                  <1> 	IRET			;RETURN FROM INTERRUPT	
   184                              <1> 
   185                              <1> ;INT09:	
   186                              <1> %INCLUDE "code/asm/int09.asm"
     1                              <2> INT09:
     2 0000EEE0 50                  <2> 	PUSH AX			;STORE AX
     3 0000EEE1 53                  <2> 	PUSH BX			;STORE BX
     4 0000EEE2 1E                  <2> 	PUSH DS			;STORE DS
     5 0000EEE3 0E                  <2> 	PUSH CS
     6 0000EEE4 1F                  <2> 	POP DS
     7                              <2> 
     8 0000EEE5 B400                <2> 	MOV AH, 0X00	;CLEAR AH
     9 0000EEE7 E460                <2> 	IN AL, 0X60		;GET SCANCODE
    10 0000EEE9 3CE0                <2> 	CMP AL, 0XE0	;EXTENDED
    11 0000EEEB 742C                <2> 	JZ .END			;DO NOTHING FOR NOW
    12 0000EEED 3C80                <2> 	CMP AL, 0X80	;BREAK CODES
    13 0000EEEF 7328                <2> 	JAE .END		;DO NOTHING FOR NOW
    14                              <2> 	
    15 0000EEF1 89C3                <2> 	MOV BX, AX		;SET INDEX
    16 0000EEF3 88C4                <2> 	MOV AH, AL		;SCAN CODE TO UPPER
    17 0000EEF5 8A87[21EF]          <2> 	MOV AL, [BX+.CHARACTER_CODE_UPPER_CASE]
    18 0000EEF9 50                  <2> 	PUSH AX			;STORE SCAN CODE/ CHAR CODE
    19                              <2> 		
    20 0000EEFA B84000              <2> 	MOV AX, 0X0040	;BIOS DATA SEGMENT 
    21 0000EEFD 8ED8                <2> 	MOV DS, AX		;SET DATA SEGMENT
    22 0000EEFF 8B1E1C00            <2> 	MOV BX, [0X001C];KEYBOARD HEAD LOCA
    23 0000EF03 58                  <2> 	POP AX			;GET SCAN CODE/ CHAR CODE
    24                              <2> 	
    25 0000EF04 8907                <2> 	MOV [BX], AX		;STORE IN KEYBOARD BUFFER
    26 0000EF06 83C302              <2> 	ADD BX, 0X02		;INC TWICE
    27 0000EF09 3B1E8200            <2> 	CMP BX, [0X0082]	;CHECK TO SEE IF ATT END OF BUFFER
    28 0000EF0D 7204                <2> 	JB .NOT_END_OF_BUFFER;JUMP OVER NEXT STEP IF NOT AT END
    29 0000EF0F 8B1E8000            <2> 	MOV BX, [0X0080]	;SET INDEX TO BEGINING  
    30                              <2>     .NOT_END_OF_BUFFER:
    31 0000EF13 891E1C00            <2> 	MOV [0X001C], BX	;STORE NEW  LOCATION
    32                              <2> 	
    33                              <2> 	
    34                              <2> 	
    35 0000EF17 EB00                <2> 	JMP .END
    36                              <2> 
    37                              <2> 	
    38                              <2> .END:
    39 0000EF19 1F                  <2> 	POP DS			;RESTORE DS
    40 0000EF1A 5B                  <2> 	POP BX			;RESTORE BX
    41 0000EF1B B020                <2> 	MOV AL, 0x20		;END OF INTERRUPT
    42 0000EF1D E620                <2> 	OUT 0x20, AL	
    43 0000EF1F 58                  <2> 	POP AX
    44 0000EF20 CF                  <2> 	IRET	
    45                              <2> 
    46                              <2> .CHARACTER_CODE_UPPER_CASE:
    47 0000EF21 001B31323334353637- <2> DB 0X00, 0X1B, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '_', '+', 0X08, 0X09	;0X0_
    47 0000EF2A 3839305F2B0809      <2>
    48 0000EF31 51574552545955494F- <2> DB 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '[', ']', 0X0D, 0X00, 'A', 'S'	;0X1_
    48 0000EF3A 505B5D0D004153      <2>
    49 0000EF41 444647484A4B4C3A27- <2> DB 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', 0X27, '~', 0X00, 0X5C, 'Z', 'X', 'C', 'V'	;0X2_
    49 0000EF4A 7E005C5A584356      <2>
    50 0000EF51 424E4D3C3E3F002A00- <2> DB 'B', 'N', 'M', '<', '>', '?', 0X00, '*', 0X00, ' ', 0X00
    50 0000EF5A 2000                <2>
    51                              <2> 	
    52                              <2> .FILL:
    53 0000EF5C 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    54 0000EF64 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    55 0000EF6C 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    56 0000EF74 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    57                              <2> 
    58 0000EF7C 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    59 0000EF84 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    60 0000EF8C 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    61 0000EF94 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    62                              <2> 
    63 0000EF9C 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    64 0000EFA4 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    65 0000EFAC 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    66 0000EFB4 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    67                              <2> 
    68 0000EFBC 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    69 0000EFC4 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    70 0000EFCC 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    71 0000EFD4 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    72                              <2> 
    73 0000EFDC 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    74 0000EFE4 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    75 0000EFEC 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    76 0000EFF4 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    77                              <2> 
    78 0000EFFC 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    79 0000F004 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    80 0000F00C 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    81 0000F014 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
   187                              <1> 
   188                              <1> INT0A: ;Reserved
   189 0000F01C B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELETYPE
   190 0000F01E B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   191 0000F020 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   192 0000F022 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   193 0000F024 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   194 0000F026 B041                <1> 	MOV AL, 'A'		;SET AL TO CHAR
   195 0000F028 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   196 0000F02A CF                  <1> 	IRET		;RETURN FROM INTERRUPT	
   197                              <1> 
   198                              <1> INT0B: ;Communications
   199 0000F02B B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   200 0000F02D B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   201 0000F02F CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   202 0000F031 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   203 0000F033 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   204 0000F035 B042                <1> 	MOV AL, 'B'		;SET AL TO CHAR
   205 0000F037 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   206 0000F039 CF                  <1> 	IRET		;RETURN FROM INTERRUPT	
   207                              <1> 	
   208                              <1> INT0C: ;Communications
   209 0000F03A B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   210 0000F03C B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   211 0000F03E CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   212 0000F040 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   213 0000F042 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   214 0000F044 B043                <1> 	MOV AL, 'C'		;SET AL TO CHAR
   215 0000F046 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   216 0000F048 CF                  <1> 	IRET		;RETURN FROM INTERRUPT			
   217                              <1> 
   218                              <1> INT0D: ;Disk
   219 0000F049 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   220 0000F04B B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   221 0000F04D CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   222 0000F04F B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   223 0000F051 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   224 0000F053 B044                <1> 	MOV AL, 'D'		;SET AL TO CHAR
   225 0000F055 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   226 0000F057 CF                  <1> 	IRET	
   227                              <1> INT0E: ;Disk
   228 0000F058 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   229 0000F05A B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   230 0000F05C CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   231 0000F05E B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   232 0000F060 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   233 0000F062 B045                <1> 	MOV AL, 'E'		;SET AL TO CHAR
   234 0000F064 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   235 0000F066 CF                  <1> 	IRET	;RETURN FROM INTERRUPT
   236                              <1> INT0F: ;Printer
   237 0000F067 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   238 0000F069 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   239 0000F06B CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   240 0000F06D B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   241 0000F06F CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   242 0000F071 B046                <1> 	MOV AL, 'F'		;SET AL TO CHAR
   243 0000F073 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   244 0000F075 CF                  <1> 	IRET		;RETURN FROM INTERRUPTINT0F:
   245                              <1> 
   246                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <1> ;INT 0X10
   248                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <1> %INCLUDE "code/asm/int10.asm"
     1                              <2> ;40:49	byte	Current video mode
     2                              <2> ;40:4A	word	Number of screen columns
     3                              <2> ;40:4C	word	Size of current video regen buffer in bytes
     4                              <2> ;40:4E	word	Offset of current video page in video regen buffer
     5                              <2> ;40:50  8 words	Cursor position of pages 1-8, high order byte=row
     6                              <2> ;				low order byte=column; changing this data isn't
     7                              <2> ; 				reflected immediately on the display
     8                              <2> ;40:62	byte	Active display page number
     9                              <2> ;40:63	word	Base port address for active 6845 CRT controller
    10                              <2> ;				3B4h = mono, 3D4h = color
    11                              <2> ;40:65	byte	6845 CRT mode control register value (port 3x8h)
    12                              <2> ;				EGA/VGA values emulate those of the MDA/CGA
    13                              <2> ;40:66	byte	CGA current color palette mask setting (port 3d9h)
    14                              <2> ;				EGA and VGA values emulate the CGA
    15                              <2> INT10:  ;Video
    16                              <2> 	;CMP AH, 0X00		;SET VIDEO MODE		
    17                              <2> 	;JZ INT10_AH_00	
    18                              <2> 	;CMP AH, 0X02 		;SET CURSOR POSITION
    19                              <2> 	;JZ INT10_AH_02	
    20                              <2> 	;CMP AH, 0X05 		;SELECT ACTIVE DISPLAY PAGE  
    21                              <2> 	;JZ INT10_AH_05	
    22 0000F076 80FC09              <2> 	CMP AH, 0X09 		;WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION
    23 0000F079 7503E9B102          <2> 	JZ INT10_AH_09	
    24                              <2> 	;CMP AH, 0X0B 		;SET PALETTE CGA
    25                              <2> 	;JZ INT10_AH_0B		;
    26 0000F07E 80FC0E              <2> 	CMP AH, 0x0E        ;TELETYPE
    27 0000F081 741D                <2> 	JZ .TELETYPE       
    28                              <2> 	;CMP AH, 0X0F 		;GET CURRENT VIDEO MODE
    29                              <2> 	;JZ INT10_AH_0F		;
    30 0000F083 80FC10              <2> 	CMP AH, 0x10		;Print strings
    31 0000F086 7401                <2> 	JZ .PRINTSTR	
    32                              <2> 
    33 0000F088 CF                  <2> 	IRET			;END
    34                              <2> 	
    35                              <2> 
    36                              <2> 	
    37                              <2> .PRINTSTR:
    38 0000F089 50                  <2>  	PUSH AX
    39 0000F08A 53                  <2> 	PUSH BX
    40 0000F08B 51                  <2> 	PUSH CX
    41 0000F08C 52                  <2> 	PUSH DX
    42 0000F08D 57                  <2> 	PUSH DI
    43 0000F08E 56                  <2> 	PUSH SI
    44 0000F08F 1E                  <2> 	PUSH DS
    45 0000F090 06                  <2> 	PUSH ES
    46                              <2> 
    47 0000F091 89DE                <2> 	mov		SI, BX
    48 0000F093 E8F5E1              <2> 	call	pstr_sram
    49                              <2> 
    50 0000F096 07                  <2>     POP ES
    51 0000F097 1F                  <2> 	POP DS
    52 0000F098 5E                  <2> 	POP SI
    53 0000F099 5F                  <2> 	POP DI
    54 0000F09A 5A                  <2> 	POP DX
    55 0000F09B 59                  <2> 	POP CX
    56 0000F09C 5B                  <2> 	POP BX
    57 0000F09D 58                  <2> 	POP AX
    58 0000F09E FB                  <2> 	STI
    59 0000F09F CF                  <2> 	IRET
    60                              <2> 
    61                              <2>    .TELETYPE: 	;0X0450
    62 0000F0A0 50                  <2>  	PUSH AX
    63 0000F0A1 53                  <2> 	PUSH BX
    64 0000F0A2 51                  <2> 	PUSH CX
    65 0000F0A3 52                  <2> 	PUSH DX
    66 0000F0A4 57                  <2> 	PUSH DI
    67 0000F0A5 56                  <2> 	PUSH SI
    68 0000F0A6 1E                  <2> 	PUSH DS
    69 0000F0A7 06                  <2> 	PUSH ES
    70                              <2> 
    71 0000F0A8 89DE                <2> 	mov		SI, BX
    72 0000F0AA E8F1E1              <2> 	call	cout
    73                              <2> 
    74 0000F0AD 07                  <2>     POP ES
    75 0000F0AE 1F                  <2> 	POP DS
    76 0000F0AF 5E                  <2> 	POP SI
    77 0000F0B0 5F                  <2> 	POP DI
    78 0000F0B1 5A                  <2> 	POP DX
    79 0000F0B2 59                  <2> 	POP CX
    80 0000F0B3 5B                  <2> 	POP BX
    81 0000F0B4 58                  <2> 	POP AX
    82                              <2> 	;STI
    83 0000F0B5 CF                  <2> 	IRET
    84                              <2> 
    85 0000F0B6 50                  <2>  	PUSH AX
    86 0000F0B7 53                  <2> 	PUSH BX
    87 0000F0B8 51                  <2> 	PUSH CX
    88 0000F0B9 52                  <2> 	PUSH DX
    89 0000F0BA 57                  <2> 	PUSH DI
    90 0000F0BB 56                  <2> 	PUSH SI
    91 0000F0BC 1E                  <2> 	PUSH DS
    92 0000F0BD 06                  <2> 	PUSH ES
    93 0000F0BE 50                  <2> 	PUSH AX
    94 0000F0BF B84000              <2> 	MOV AX, 0X0040
    95 0000F0C2 8ED8                <2> 	MOV DS, AX					;Set data segment
    96 0000F0C4 B400                <2> 	MOV AH, 0X00				;ah=0
    97 0000F0C6 A05100              <2> 	MOV AL, BYTE [0X51]			;Current Row
    98 0000F0C9 8B0E4A00            <2> 	MOV CX, WORD [0x04A] 		;number of cols per row
    99 0000F0CD 01C9                <2> 	ADD CX, CX					;Double col for hidden char data
   100 0000F0CF F6E1                <2> 	MUL CL						;mul Current row * cols
   101 0000F0D1 B700                <2> 	MOV BH, 0X00				;BH=0
   102 0000F0D3 8A1E5000            <2> 	MOV BL, BYTE [0X50]			;Set current col
   103 0000F0D7 01DB                <2> 	ADD BX, BX					;Double col for hidden char data
   104 0000F0D9 01C3                <2> 	ADD BX, AX					;Add in row
   105 0000F0DB B800B8              <2> 	MOV AX, 0XB800				;
   106 0000F0DE 8ED8                <2> 	MOV DS, AX					;Set video segment
   107 0000F0E0 58                  <2> 	POP AX						;restore char	
   108 0000F0E1 3C0D                <2> 	CMP AL, 0X0D				;Check for enter
   109 0000F0E3 7503E99200          <2> 	JZ .ENTER					;return carrage
   110 0000F0E8 3C0A                <2> 	CMP AL, 0X0A				;Check for line feed
   111 0000F0EA 7503E99900          <2> 	JZ .LINE_FEED				;line feed
   112 0000F0EF 3C08                <2> 	CMP AL, 0X08				;check for back space
   113 0000F0F1 7503E9A700          <2> 	JZ .BACKSPACE
   114 0000F0F6 8807                <2> 	MOV [BX], AL				;Char out
   115 0000F0F8 EB00                <2> 	JMP .MOVE_CURSOR_FORWARD
   116                              <2> 
   117                              <2>  .MOVE_CURSOR_FORWARD:
   118 0000F0FA B84000              <2> 	MOV AX, 0X0040				;Check col
   119 0000F0FD 8ED8                <2> 	MOV DS, AX					;Set data segment	
   120 0000F0FF BB5000              <2> 	MOV BX, 0X0050				;Col
   121 0000F102 B400                <2> 	MOV AH, 0X00				;AH=0
   122 0000F104 8A07                <2> 	MOV AL, BYTE [BX]			;get current col
   123 0000F106 FEC0                <2> 	INC AL						;inc col
   124 0000F108 3B064A00            <2> 	CMP AX, WORD [0x04A] 		;number of cols per row
   125 0000F10C 7265                <2> 	JB .NOT_END_OF_COL
   126                              <2>   .END_OF_COL:	
   127 0000F10E B84000              <2>   	MOV AX, 0X0040				;Check col
   128 0000F111 8ED8                <2> 	MOV DS, AX					;Set data segment	
   129 0000F113 BB5000              <2>   	MOV BX, 0X0050				;
   130 0000F116 B000                <2> 	MOV AL, 0X00				;
   131 0000F118 8807                <2> 	MOV BYTE [BX], AL			;Set col to 0
   132 0000F11A BB5100              <2> 	MOV BX, 0X0051				;Row
   133 0000F11D B400                <2> 	MOV AH, 0X00				;AH=0
   134 0000F11F 8A07                <2> 	MOV AL, BYTE [BX]			;get current ROW
   135 0000F121 FEC0                <2> 	INC AL						;inc row
   136 0000F123 83F819              <2> 	CMP AX, 0X19				;cmp to 25
   137 0000F126 7244                <2> 	JB .NOT_END_OF_ROWS
   138                              <2>   .SCROLL_UP:	
   139 0000F128 FC                  <2> 	CLD							;SCROLL UP	
   140 0000F129 B84000              <2> 	MOV AX, 0X0040
   141 0000F12C 8ED8                <2> 	MOV DS, AX
   142 0000F12E 803E490000          <2> 	CMP BYTE [0X49], 0X00		;IF MODE 0
   143 0000F133 741F                <2> 	JZ .SCROLL_40
   144 0000F135 803E490001          <2> 	CMP BYTE [0X49], 0X01		;IF MODE 1
   145 0000F13A 7418                <2> 	JZ .SCROLL_40				
   146                              <2> .SCROLL_80:						;MODE 2 AND 3			
   147 0000F13C B800B8              <2> 	MOV AX, 0XB800
   148 0000F13F 8EC0                <2> 	MOV ES, AX
   149 0000F141 BF0000              <2> 	MOV DI, 0X0000
   150 0000F144 B800B8              <2> 	MOV AX, 0XB800
   151 0000F147 8ED8                <2> 	MOV DS, AX
   152 0000F149 BEA000              <2> 	MOV SI, 0X00A0			;NEXT LINE
   153 0000F14C B9A00F              <2> 	MOV CX, 4000			;TIMES
   154 0000F14F F3A4                <2> 	REP MOVSB
   155 0000F151 E99900              <2> 	JMP .END_INT10
   156                              <2> .SCROLL_40:					;MODE 0 AND 1
   157 0000F154 B800B8              <2> 	MOV AX, 0XB800
   158 0000F157 8EC0                <2> 	MOV ES, AX
   159 0000F159 BF0000              <2> 	MOV DI, 0X0000
   160 0000F15C B800B8              <2> 	MOV AX, 0XB800
   161 0000F15F 8ED8                <2> 	MOV DS, AX
   162 0000F161 BE5000              <2> 	MOV SI, 0X0050			;NEXT LINE
   163 0000F164 B9D007              <2> 	MOV CX, 2000			;TIMES
   164 0000F167 F3A4                <2> 	REP MOVSB	
   165 0000F169 E98100              <2> 	JMP .END_INT10
   166                              <2> 	
   167                              <2>  .NOT_END_OF_ROWS:
   168 0000F16C BB5100              <2> 	MOV BX, 0X0051				;ROW
   169 0000F16F 8807                <2> 	MOV BYTE [BX], AL			;STORE AL=ROW
   170 0000F171 EB7A                <2> 	JMP .END_INT10				;END
   171                              <2> 
   172                              <2> .NOT_END_OF_COL:
   173 0000F173 BB5000              <2> 	MOV BX, 0X0050				;Col
   174 0000F176 8807                <2> 	MOV BYTE [BX], AL			;STORE AL=COL
   175 0000F178 EB73                <2> 	JMP .END_INT10				;END	
   176                              <2> 
   177                              <2>   .ENTER:
   178 0000F17A B84000              <2>   	MOV AX, 0X0040				;Check col
   179 0000F17D 8ED8                <2> 	MOV DS, AX					;Set data segment	
   180 0000F17F BB5000              <2>   	MOV BX, 0X0050				;
   181 0000F182 B000                <2> 	MOV AL, 0X00				;
   182 0000F184 8807                <2> 	MOV BYTE [BX], AL			;Set col to 0
   183 0000F186 EB65                <2> 	JMP .END_INT10	
   184                              <2> 	
   185                              <2>   .LINE_FEED:
   186 0000F188 B84000              <2>   	MOV AX, 0X0040				;Check col
   187 0000F18B 8ED8                <2> 	MOV DS, AX					;Set data segment	
   188 0000F18D BB5100              <2> 	MOV BX, 0X0051				;Row
   189 0000F190 B400                <2> 	MOV AH, 0X00				;AH=0
   190 0000F192 8A07                <2> 	MOV AL, BYTE [BX]			;get current ROW
   191 0000F194 FEC0                <2> 	INC AL						;inc row
   192 0000F196 83F819              <2> 	CMP AX, 0X19				;cmp to 25
   193 0000F199 72D1                <2> 	JB .NOT_END_OF_ROWS			;STORE AL IN ROW AND END
   194 0000F19B EB8B                <2> 	JMP .SCROLL_UP				;SCROLL UP
   195                              <2> 	
   196                              <2>   .BACKSPACE:	
   197 0000F19D 83EB02              <2>     SUB BX, 0X0002				;GO BACK A SPACE IN RAM
   198 0000F1A0 C60700              <2>     MOV BYTE [BX], 0X00			;Clear char
   199 0000F1A3 B84000              <2>  	MOV AX, 0X0040				;Check col
   200 0000F1A6 8ED8                <2> 	MOV DS, AX					;Set data segment	
   201 0000F1A8 BB5000              <2> 	MOV BX, 0X0050				;Col
   202 0000F1AB B400                <2> 	MOV AH, 0X00				;AH=0
   203 0000F1AD 8A07                <2> 	MOV AL, BYTE [BX]			;get current col
   204 0000F1AF FEC8                <2> 	DEC AL						;
   205 0000F1B1 3B064A00            <2> 	CMP AX, WORD [0x04A] 		;number of cols per row
   206 0000F1B5 722F                <2> 	JB .NOT_BEGIN_OF_COL
   207                              <2>   .BEGIN_OF_COL:	
   208 0000F1B7 B84000              <2>   	MOV AX, 0X0040				;Check col
   209 0000F1BA 8ED8                <2> 	MOV DS, AX					;Set data segment	
   210 0000F1BC BB5000              <2>   	MOV BX, 0X0050				;
   211 0000F1BF B04F                <2> 	MOV AL, 0X4F				;
   212 0000F1C1 8807                <2> 	MOV BYTE [BX], AL			;Set col to 49
   213 0000F1C3 BB5100              <2> 	MOV BX, 0X0051				;Row
   214 0000F1C6 B400                <2> 	MOV AH, 0X00				;AH=0
   215 0000F1C8 8A07                <2> 	MOV AL, BYTE [BX]			;get current ROW
   216 0000F1CA FEC8                <2> 	DEC AL						;dec row
   217 0000F1CC 83F819              <2> 	CMP AX, 0X19				;cmp to 25
   218 0000F1CF 729B                <2> 	JB .NOT_END_OF_ROWS
   219                              <2>   .BEGIN_OF_ROW:	
   220 0000F1D1 BB5000              <2>   	MOV BX, 0X0050				;col
   221 0000F1D4 C60700              <2> 	MOV BYTE [BX], 0X00
   222 0000F1D7 BB5100              <2> 	MOV BX, 0X0051				;ROW
   223 0000F1DA C60700              <2> 	MOV BYTE [BX], 0X00
   224 0000F1DD EB0E                <2> 	JMP .END_INT10
   225                              <2> 	
   226                              <2>  .NOT_BEGIN_OF_ROW:
   227 0000F1DF BB5100              <2> 	MOV BX, 0X0051				;ROW
   228 0000F1E2 8807                <2> 	MOV BYTE [BX], AL
   229 0000F1E4 EB07                <2> 	JMP .END_INT10
   230                              <2> 
   231                              <2> .NOT_BEGIN_OF_COL:
   232 0000F1E6 BB5000              <2> 	MOV BX, 0X0050				;Col
   233 0000F1E9 8807                <2> 	MOV BYTE [BX], AL
   234 0000F1EB EB00                <2> 	JMP .END_INT10 
   235                              <2>   
   236                              <2>    .END_INT10:
   237 0000F1ED 07                  <2>     POP ES
   238 0000F1EE 1F                  <2> 	POP DS
   239 0000F1EF 5E                  <2> 	POP SI
   240 0000F1F0 5F                  <2> 	POP DI
   241 0000F1F1 5A                  <2> 	POP DX
   242 0000F1F2 59                  <2> 	POP CX
   243 0000F1F3 5B                  <2> 	POP BX
   244 0000F1F4 58                  <2> 	POP AX
   245                              <2> 	;STI
   246 0000F1F5 CF                  <2> 	IRET
   247                              <2> 	
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   249                              <2> ;SET VIDEO MODE
   250                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   251                              <2> INT10_AH_00:				
   252 0000F1F6 1E                  <2> 	PUSH DS					;STORE DS
   253 0000F1F7 53                  <2> 	PUSH BX					;STORE BX
   254 0000F1F8 51                  <2> 	PUSH CX					;STORE CX
   255 0000F1F9 50                  <2> 	PUSH AX					;STORE AX
   256 0000F1FA 50                  <2> 	PUSH AX					;STORE AX
   257                              <2> 	
   258 0000F1FB B84000              <2> 	MOV AX, 0x0040			;BIOS DATA AREA 0X400
   259 0000F1FE 8ED8                <2> 	MOV DS, AX				;SET DS TO BIOS DATA AREA
   260 0000F200 58                  <2> 	POP AX					;RESTORE AX
   261                              <2> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;
   262 0000F201 2407                <2> 	AND AL, 0X07			;JUST FOR NOW LIMITED MODES AVAILABLE 
   263                              <2> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   264 0000F203 A24900              <2> 	MOV [0X49], AL			;40:49 SET VIDEO MODE
   265 0000F206 3C00                <2> 	CMP AL, 0X00			;IF MODE 0
   266 0000F208 7410                <2> 	JZ .CLEAR_SCREEN_MODE0	;CLEARS SCREEN
   267 0000F20A 3C01                <2> 	CMP AL, 0X01			;IF MODE 1
   268 0000F20C 740C                <2> 	JZ .CLEAR_SCREEN_MODE0	;CLEARS SCREEN
   269 0000F20E 3C02                <2> 	CMP AL, 0X02			;IF MODE 2
   270 0000F210 7418                <2> 	JZ .SET_MODE2
   271                              <2> 
   272 0000F212 3C03                <2> 	CMP AL, 0X03			;IF MODE 3
   273 0000F214 740C                <2> 	JZ .CLEAR_SCREEN_MODE2	;CLEARS SCREEN
   274 0000F216 3C04                <2> 	CMP AL, 0X04			;IF MODE 4
   275 0000F218 7457                <2> 	JZ .SET_MODE4
   276                              <2> 
   277                              <2> 	
   278                              <2>  .CLEAR_SCREEN_MODE0:	
   279 0000F21A C7064A002800        <2> 	MOV WORD [0X004A], 0X0028	;SET COL COUNT 40
   280 0000F220 EB38                <2> 	JMP .CLEAR_SCREEN_TEXT_MODE
   281                              <2>  .CLEAR_SCREEN_MODE2:
   282 0000F222 C7064A005000        <2> 	MOV WORD [0X004A], 0X0050	;SET COL COUNT 80
   283 0000F228 EB30                <2> 	JMP .CLEAR_SCREEN_TEXT_MODE
   284                              <2> 	
   285                              <2>  .SET_MODE2:
   286 0000F22A C7064A005000        <2> 	MOV WORD [0X004A], 0X0050	;SET COL COUNT 80
   287                              <2> 	
   288 0000F230 8CC8                <2> 	MOV AX, CS
   289 0000F232 8ED8                <2> 	MOV DS, AX
   290                              <2> 
   291 0000F234 B400                <2> 	MOV AH, 0X00
   292 0000F236 B91000              <2> 	MOV CX, 0X0010
   293 0000F239 BB[CDF2]            <2> 	MOV BX, .CGA_TEXT_80X25
   294                              <2> 
   295 0000F23C B000                <2> 	MOV AL, 0X00
   296 0000F23E BAD803              <2> 	MOV DX, 0X03D8
   297 0000F241 EE                  <2> 	OUT DX, AL
   298                              <2> 
   299                              <2>   .CRT_LOOP_MODE2:
   300 0000F242 8A07                <2> 	MOV AL, [BX]
   301 0000F244 E8B600              <2> 	CALL .WRITE_CGA_REG
   302 0000F247 FEC4                <2> 	INC AH
   303 0000F249 43                  <2> 	INC BX
   304 0000F24A E2F6                <2> 	LOOP .CRT_LOOP_MODE2
   305                              <2> 
   306 0000F24C B02D                <2> 	MOV AL, 0X2D
   307 0000F24E BAD803              <2> 	MOV DX, 0X03D8			;MODE CONTROL REG
   308 0000F251 EE                  <2> 	OUT DX, AL
   309                              <2> 	
   310 0000F252 B030                <2> 	MOV AL, 0X30
   311 0000F254 BAD903              <2> 	MOV DX, 0X03D9			;COLOR SELECT REG
   312 0000F257 EE                  <2> 	OUT DX, AL	
   313                              <2> 	
   314 0000F258 EB00                <2> 	JMP .CLEAR_SCREEN_TEXT_MODE
   315                              <2> 
   316                              <2>  .CLEAR_SCREEN_TEXT_MODE:
   317 0000F25A B800B8              <2> 	MOV AX, 0XB800				;VIDEO MEM
   318 0000F25D 8ED8                <2> 	MOV DS, AX					;SET DS
   319 0000F25F BB0000              <2> 	MOV BX, 0X0000				;BX = 0
   320 0000F262 B92008              <2> 	MOV CX, 2080 				;TIMES TO LOOP, YES NOT HEX
   321 0000F265 B80007              <2> 	MOV AX, 0X0700				;0 B/W
   322                              <2>   .LOOP_CLS_MODE0:				;LOOP TO CLEAR SCREEN
   323 0000F268 8907                <2> 	MOV WORD [BX], AX			;WORD [BX] = AX
   324 0000F26A 83C302              <2> 	ADD BX, 0X0002				;INC BX X2
   325 0000F26D E2F9                <2> 	LOOP .LOOP_CLS_MODE0		;LOOP TIL DONE	
   326 0000F26F EB47                <2> 	JMP .END					;END
   327                              <2> 
   328                              <2> .SET_MODE4:
   329 0000F271 C7064A002800        <2> 	MOV WORD [0X004A], 0X0028	;SET COL COUNT 40
   330                              <2> 	
   331 0000F277 8CC8                <2> 	MOV AX, CS
   332 0000F279 8ED8                <2> 	MOV DS, AX
   333                              <2> 
   334 0000F27B B400                <2> 	MOV AH, 0X00
   335 0000F27D B91000              <2> 	MOV CX, 0X0010
   336 0000F280 BB[DDF2]            <2> 	MOV BX, .CGA_GRAPHICS
   337                              <2> 
   338 0000F283 B000                <2> 	MOV AL, 0X00
   339 0000F285 BAD803              <2> 	MOV DX, 0X03D8
   340 0000F288 EE                  <2> 	OUT DX, AL
   341                              <2> 
   342                              <2>   .CRT_LOOP_MODE4:
   343 0000F289 8A07                <2> 	MOV AL, [BX]
   344 0000F28B E86F00              <2> 	CALL .WRITE_CGA_REG
   345 0000F28E FEC4                <2> 	INC AH
   346 0000F290 43                  <2> 	INC BX
   347 0000F291 E2F6                <2> 	LOOP .CRT_LOOP_MODE4
   348                              <2> 
   349 0000F293 B02E                <2> 	MOV AL, 0X2E
   350 0000F295 BAD803              <2> 	MOV DX, 0X03D8
   351 0000F298 EE                  <2> 	OUT DX, AL
   352                              <2> 	
   353 0000F299 B030                <2> 	MOV AL, 0X30
   354 0000F29B BAD903              <2> 	MOV DX, 0X03D9			;COLOR SELECT REG
   355 0000F29E EE                  <2> 	OUT DX, AL	
   356                              <2> 	
   357                              <2> 	
   358 0000F29F EB00                <2> 	JMP .CLEAR_SCREEN_MODE4
   359                              <2> 	
   360                              <2>   .CLEAR_SCREEN_MODE4:
   361 0000F2A1 B800B8              <2> 	MOV AX, 0XB800				;VIDEO MEM
   362 0000F2A4 8ED8                <2> 	MOV DS, AX					;SET DS
   363 0000F2A6 BB0000              <2> 	MOV BX, 0X0000				;BX = 0
   364 0000F2A9 B90020              <2> 	MOV CX, 0X2000				;TIMES TO LOOP
   365 0000F2AC B80000              <2> 	MOV AX, 0X0000				;CLEAR SCREEN TO NOTHING 
   366                              <2>   .LOOP_CLS_MODE4:				;LOOP TO CLEAR SCREEN
   367 0000F2AF 8907                <2> 	MOV WORD [BX], AX			;WORD [BX] = AX
   368 0000F2B1 83C302              <2> 	ADD BX, 0X0002				;INC BX X2
   369 0000F2B4 E2F9                <2> 	LOOP .LOOP_CLS_MODE4		;LOOP TIL DONE	
   370 0000F2B6 EB00                <2> 	JMP .END					;END
   371                              <2> 
   372                              <2>   .END:
   373 0000F2B8 58                  <2>  	POP AX			;RESTORE AX
   374 0000F2B9 59                  <2>  	POP CX			;RESTORE CX
   375 0000F2BA 5B                  <2> 	POP BX			;RESTORE BX
   376 0000F2BB 1F                  <2> 	POP DS			;RESTORE DS
   377 0000F2BC CF                  <2> 	IRET
   378                              <2> 
   379                              <2> 
   380                              <2> ; CGA TEXT 40x25 MODE
   381 0000F2BD 38282D0A1F06191C    <2> DB 0X38, 0X28, 0X2D, 0X0A, 0X1F, 0X06, 0X19, 0X1C
   382 0000F2C5 0207060700000000    <2> DB 0X02, 0X07, 0X06, 0X07, 0X00, 0X00, 0X00, 0X00
   383                              <2> 
   384                              <2> ; CGA TEXT 80x25 MODE
   385                              <2> .CGA_TEXT_80X25:
   386 0000F2CD 71505A0A1F06191C    <2> DB 0X71, 0X50, 0X5A, 0X0A, 0X1F, 0X06, 0X19, 0X1C
   387 0000F2D5 0207060700000000    <2> DB 0X02, 0X07, 0X06, 0X07, 0X00, 0X00, 0X00, 0X00
   388                              <2> 
   389                              <2> ; CGA GRAPHICS MODE
   390                              <2> .CGA_GRAPHICS:
   391 0000F2DD 38282D0A7F066470    <2> DB 0X38, 0X28, 0X2D, 0X0A, 0X7F, 0X06, 0X64, 0X70
   392 0000F2E5 0201060700000000    <2> DB 0X02, 0X01, 0X06, 0X07, 0X00, 0X00, 0X00, 0X00
   393                              <2> 
   394                              <2> ; MDA TEXT 80x25 MODE
   395 0000F2ED 6150520F19061919    <2> DB 0X61, 0X50, 0X52, 0X0F, 0X19, 0X06, 0X19, 0X19
   396 0000F2F5 020D0B0C00000000    <2> DB 0X02, 0X0D, 0X0B, 0X0C, 0X00, 0X00, 0X00, 0X00
   397                              <2> 
   398                              <2> 
   399                              <2> 
   400                              <2> .WRITE_CGA_REG:
   401 0000F2FD 52                  <2> 	PUSH DX	
   402 0000F2FE BAD403              <2> 	MOV DX, 0X03D4	; DX = CRTC INDEX PORT
   403 0000F301 50                  <2> 	PUSH AX
   404 0000F302 88E0                <2> 	MOV AL, AH 		; AH = BYTE, AL = REGISTER NUMBER
   405 0000F304 EE                  <2> 	OUT DX, AL		; write register number
   406 0000F305 42                  <2> 	INC DX			; DX = CRTC data port
   407 0000F306 58                  <2> 	POP AX
   408 0000F307 EE                  <2> 	OUT DX, AL		; WRITE BYTE
   409 0000F308 5A                  <2> 	POP DX
   410 0000F309 C3                  <2> 	RET
   411                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   412                              <2> ;SET CURSOR POSITION
   413                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   414                              <2> INT10_AH_02:
   415 0000F30A 1E                  <2> 	PUSH DS			;STORE DS
   416 0000F30B 53                  <2> 	PUSH BX			;STORE BX
   417 0000F30C 50                  <2> 	PUSH AX			;STORE AX
   418                              <2> 	
   419 0000F30D B84500              <2> 	MOV AX, 0X0045	;BIOS DATA 0X450 CURSOR POSITION BASE PAGE 0
   420 0000F310 8ED8                <2> 	MOV DS, AX		;SET DS TO 0X450
   421 0000F312 B80200              <2> 	MOV AX, 0X02	;TIMES (BH * 2) TO GET THE PAGE OFFSET FROM 0X450
   422 0000F315 F6E7                <2> 	MUL BH			;AL = PAGE OFFSET
   423 0000F317 89C3                <2> 	MOV BX, AX		;BX = AX
   424 0000F319 8817                <2> 	MOV [BX], DL	;STORE COLUMN
   425 0000F31B 43                  <2> 	INC BX			;INC BX
   426 0000F31C 8837                <2> 	MOV [BX], DH	;STORE ROW	
   427                              <2> 
   428 0000F31E 58                  <2> 	POP AX			;RESTORE AX
   429 0000F31F 5B                  <2> 	POP BX			;RESTORE BX
   430 0000F320 1F                  <2> 	POP DS			;RESTORE DS
   431 0000F321 CF                  <2> 	IRET
   432                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   433                              <2> ;SELECT ACTIVE DISPLAY PAGE      
   434                              <2> ;"MAYBE WORKS" DONT KNOW IF IT WANTS A NUMBER 0-7 OR MEM ADDRESS OFFSET
   435                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   436                              <2> INT10_AH_05:
   437 0000F322 1E                  <2> 	PUSH DS			;STORE DS
   438 0000F323 50                  <2> 	PUSH AX			;STORE AX
   439 0000F324 B84000              <2> 	MOV AX, 0X0040	;BIOS DATA 0X44E ACTIVE DISPLAY PAGE 
   440 0000F327 8ED8                <2> 	MOV DS, AX		;SET DS
   441 0000F329 58                  <2> 	POP AX			;RESTORE AX
   442 0000F32A A24E00              <2> 	MOV [0X4E], AL	;SET PAGE NUMBER [0X0040:0X004E] = AL
   443 0000F32D 1F                  <2> 	POP DS			;RESTORE DS
   444 0000F32E CF                  <2> 	IRET
   445                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   446                              <2> ;WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION
   447                              <2> ;AL = ASCII character to write
   448                              <2> ;BH = display page  (or mode 13h, background pixel value)		IGNORED
   449                              <2> ;BL = character attribute (text) foreground color (graphics) 
   450                              <2> ;CX = count of characters to write (CX >= 1)					IGNORED
   451                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   452                              <2> INT10_AH_09:	
   453 0000F32F 1E                  <2> 	PUSH DS			;STORE DS
   454 0000F330 52                  <2> 	PUSH DX			;STORE DX
   455 0000F331 51                  <2> 	PUSH CX			;STORE CX
   456 0000F332 53                  <2> 	PUSH BX			;STORE BX
   457 0000F333 50                  <2> 	PUSH AX			;STORE AX
   458                              <2> 	;PUSH BX			;STORE BX
   459                              <2> 	;PUSH AX			;STORE AX
   460                              <2> 
   461 0000F334 E867DF              <2> 	CALL	cout
   462                              <2> 
   463                              <2> 	;MOV AX, 0X0040
   464                              <2> 	;MOV DS, AX					;Set data segment
   465                              <2> 	;MOV AH, 0X00				;ah=0
   466                              <2> 	;MOV AL, BYTE [0X51]			;Current Row
   467                              <2> 	;MOV CX, WORD [0x04A] 		;number of cols per row
   468                              <2> 	;ADD CX, CX					;Double col for hidden char data
   469                              <2> 	;MUL CL						;mul Current row * cols
   470                              <2> 	;MOV BH, 0X00				;BH=0
   471                              <2> 	;MOV BL, BYTE [0X50]			;Set current col
   472                              <2> 	;ADD BX, BX					;Double col for hidden char data
   473                              <2> 	;ADD BX, AX					;Add in row
   474                              <2> 	;MOV AX, 0XB800				;
   475                              <2> 	;MOV DS, AX					;Set video segment
   476                              <2> 	;POP AX						;RESTORE AX
   477                              <2> 	;POP DX						;RESTORE BX
   478                              <2> 	;MOV AH, DL					;GET ATTRIBUTES	
   479                              <2> 	;MOV [BX], AX				
   480                              <2> 	
   481 0000F337 58                  <2> 	POP AX			;RESTORE AX
   482 0000F338 5B                  <2> 	POP BX			;RESTORE BX
   483 0000F339 59                  <2> 	POP CX			;RESTORE CX
   484 0000F33A 5A                  <2> 	POP DX			;RESTORE DX
   485 0000F33B 1F                  <2> 	POP DS			;RESTORE DS
   486 0000F33C CF                  <2> 	IRET
   487                              <2> 	
   488                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   489                              <2> ;WRITE CHARACTER AT CURSOR POSITION 
   490                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   491                              <2> INT10_AH_0A:
   492 0000F33D CF                  <2> 	IRET
   493                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   494                              <2> ;SET PALETTE 
   495                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   496                              <2> INT10_AH_0B:		;
   497 0000F33E 1E                  <2> 	PUSH DS			;STORE DS
   498 0000F33F 50                  <2> 	PUSH AX			;STORE AX
   499 0000F340 80FF00              <2> 	CMP BH, 0X00 	;= 0	to set background and border color
   500                              <2> 					;= 1	to select 4 color palette
   501 0000F343 7409                <2> 	JZ .END			;ONLY HANDLE BH = 1 FOR NOW
   502 0000F345 B84000              <2> 	MOV AX, 0x0040	;BIOS DATA AREA 0X400
   503 0000F348 8ED8                <2> 	MOV DS, AX		;SET DS TO BIOS DATA AREA
   504 0000F34A 881E6600            <2> 	MOV [0X66], BL	;40:66 color palette
   505                              <2> 	
   506                              <2>   .END:				;END OF INT10_AH_0B
   507 0000F34E 58                  <2> 	POP AX			;RESTORE AX
   508 0000F34F 1F                  <2> 	POP DS			;RESTORE DS
   509 0000F350 CF                  <2> 	IRET
   510                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   511                              <2> ;GET VIDEO MODE
   512                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   513                              <2> INT10_AH_0F:
   514 0000F351 1E                  <2> 	PUSH DS			;STORE DS
   515 0000F352 B84000              <2> 	MOV AX, 0x0040	;BIOS DATA AREA 0X400
   516 0000F355 8ED8                <2> 	MOV DS, AX		;SET DS TO BIOS DATA AREA
   517 0000F357 8A264A00            <2> 	MOV AH, [0X4A]  ;NUMBER OF SCREEN COLUMNS
   518 0000F35B A04900              <2> 	MOV AL, [0X49]	;CURRENT MODE
   519 0000F35E 8A3E4E00            <2> 	MOV BH, [0X4E]	;CURRENT PAGE
   520 0000F362 1F                  <2> 	POP DS			;RESTORE DS
   521 0000F363 CF                  <2> 	IRET
   522                              <2> 
   523                              <2> ;----------------------------------------
   524                              <2> ; CHARACTER GENERATOR GRAPHICS FOR 320X200 AND 640X200 GRAPHICS
   525                              <2> ;----------------------------------------
   526                              <2> 
   527 0000F364 0000000000000000    <2> 	DB	000H,000H,000H,000H,000H,000H,000H,000H ; D_00
   528 0000F36C 7E81A581BD99817E    <2> 	DB	07EH,081H,0A5H,081H,0BDH,099H,081H,07EH ; D_01
   529 0000F374 7EFFDBFFC3E7FF7E    <2> 	DB	07EH,0FFH,0DBH,0FFH,0C3H,0E7H,0FFH,07EH ; D_02
   530 0000F37C 6CFEFEFE7C381000    <2> 	DB	06CH,0FEH,0FEH,0FEH,07CH,038H,010H,000H ; D_03
   531 0000F384 10387CFE7C381008    <2> 	DB	010H,038H,07CH,0FEH,07CH,038H,010H,008H ; D_04
   532 0000F38C 387C38FEFE7C387C    <2> 	DB	038H,07CH,038H,0FEH,0FEH,07CH,038H,07CH ; D_05
   533 0000F394 1010387CFE7C387C    <2> 	DB	010H,010H,038H,07CH,0FEH,07CH,038H,07CH ; D_06
   534 0000F39C 0000183C3C180000    <2> 	DB	000H,000H,018H,03CH,03CH,018H,000H,000H ; D_07
   535 0000F3A4 FFFFE7C3C3E7FFFF    <2> 	DB	0FFH,0FFH,0E7H,0C3H,0C3H,0E7H,0FFH,0FFH ; D_08
   536 0000F3AC 003C664242663C00    <2> 	DB	000H,03CH,066H,042H,042H,066H,03CH,000H ; D_09
   537 0000F3B4 FFC399BDBD99C3FF    <2> 	DB	0FFH,0C3H,099H,0BDH,0BDH,099H,0C3H,0FFH ; D_0A
   538 0000F3BC 0F070F7DCCCCCC78    <2> 	DB	00FH,007H,00FH,07DH,0CCH,0CCH,0CCH,078H ; D_08
   539 0000F3C4 3C6666663C187E18    <2> 	DB	03CH,066H,066H,066H,03CH,018H,07EH,018H ; D_0C
   540 0000F3CC 3F333F303070F0E0    <2> 	DB	03FH,033H,03FH,030H,030H,070H,0F0H,0E0H ; D_0D
   541 0000F3D4 7F637F636367E6C0    <2> 	DB	07FH,063H,07FH,063H,063H,067H,0E6H,0C0H ; D_0E
   542 0000F3DC 995A3CE7E73C5A99    <2> 	DB	099H,05AH,03CH,0E7H,0E7H,03CH,05AH,099H ; D_0F
   543                              <2> 
   544 0000F3E4 80E0F8FEF8E08000    <2> 	DB	080H,0E0H,0F8H,0FEH,0F8H,0E0H,080H,000H ; D_10
   545 0000F3EC 020E3EFE3E0E0200    <2> 	DB	002H,00EH,03EH,0FEH,03EH,00EH,002H,000H ; D_11
   546 0000F3F4 183C7E18187E3C18    <2> 	DB	018H,03CH,07EH,018H,018H,07EH,03CH,018H ; D_12
   547 0000F3FC 6666666666006600    <2> 	DB	066H,066H,066H,066H,066H,000H,066H,000H ; D_13
   548 0000F404 7FDBDB7B1B1B1B00    <2> 	DB	07FH,0DBH,0DBH,07BH,01BH,01BH,01BH,000H ; D_14
   549 0000F40C 3E63386C6C38CC78    <2> 	DB	03EH,063H,038H,06CH,06CH,038H,0CCH,078H ; D_15
   550 0000F414 000000007E7E7E00    <2> 	DB	000H,000H,000H,000H,07EH,07EH,07EH,000H ; D_16
   551 0000F41C 183C7E187E3C18FF    <2> 	DB	018H,03CH,07EH,018H,07EH,03CH,018H,0FFH ; D_17
   552 0000F424 183C7E1818181800    <2> 	DB	018H,03CH,07EH,018H,018H,018H,018H,000H ; D_18
   553 0000F42C 181818187E3C1800    <2> 	DB	018H,018H,018H,018H,07EH,03CH,018H,000H ; D_19
   554 0000F434 00180CFE0C180000    <2> 	DB	000H,018H,00CH,0FEH,00CH,018H,000H,000H ; D_1A
   555 0000F43C 003060FE60300000    <2> 	DB	000H,030H,060H,0FEH,060H,030H,000H,000H ; D_1B
   556 0000F444 0000C0C0C0FE0000    <2> 	DB	000H,000H,0C0H,0C0H,0C0H,0FEH,000H,000H ; D_1C
   557 0000F44C 002466FF66240000    <2> 	DB	000H,024H,066H,0FFH,066H,024H,000H,000H ; D_1D
   558 0000F454 00183C7EFFFF0000    <2> 	DB	000H,018H,03CH,07EH,0FFH,0FFH,000H,000H ; D_1E
   559 0000F45C 00FFFF7E3C180000    <2> 	DB	000H,0FFH,0FFH,07EH,03CH,018H,000H,000H ; D_1F
   560                              <2> 
   561 0000F464 0000000000000000    <2> 	DB	000H,000H,000H,000H,000H,000H,000H,000H ; SP D_20
   562 0000F46C 3078783030003000    <2> 	DB	030H,078H,078H,030H,030H,000H,030H,000H ; ! D_21
   563 0000F474 6C6C6C0000000000    <2> 	DB	06CH,06CH,06CH,000H,000H,000H,000H,000H ; " D_22
   564 0000F47C 6C6CFE6CFE6C6C00    <2> 	DB	06CH,06CH,0FEH,06CH,0FEH,06CH,06CH,000H ; # D_23
   565 0000F484 307CC0780CF83000    <2> 	DB	030H,07CH,0C0H,078H,00CH,0F8H,030H,000H ; $ D_24
   566 0000F48C 00C6CC183066C600    <2> 	DB	000H,0C6H,0CCH,018H,030H,066H,0C6H,000H ; PER CENT D_25
   567 0000F494 386C3876DCCC7600    <2> 	DB	038H,06CH,038H,076H,0DCH,0CCH,076H,000H ; & D_26
   568 0000F49C 6060C00000000000    <2> 	DB	060H,060H,0C0H,000H,000H,000H,000H,000H ; ' D_27
   569 0000F4A4 1830606060301800    <2> 	DB	018H,030H,060H,060H,060H,030H,018H,000H ; ( D_28
   570 0000F4AC 6030181818306000    <2> 	DB	060H,030H,018H,018H,018H,030H,060H,000H ; ) D_29
   571 0000F4B4 00663CFF3C660000    <2> 	DB	000H,066H,03CH,0FFH,03CH,066H,000H,000H ; * D_2A
   572 0000F4BC 003030FC30300000    <2> 	DB	000H,030H,030H,0FCH,030H,030H,000H,000H ; + D_2B
   573 0000F4C4 0000000000303060    <2> 	DB	000H,000H,000H,000H,000H,030H,030H,060H ; , D_2C
   574 0000F4CC 000000FC00000000    <2> 	DB	000H,000H,000H,0FCH,000H,000H,000H,000H ; - D_2D
   575 0000F4D4 0000000000303000    <2> 	DB	000H,000H,000H,000H,000H,030H,030H,000H ; . D_2E
   576 0000F4DC 060C183060C08000    <2> 	DB	006H,00CH,018H,030H,060H,0C0H,080H,000H ; / D_2F
   577                              <2> 
   578 0000F4E4 7CC6CEDEF6E67C00    <2> 	DB	07CH,0C6H,0CEH,0DEH,0F6H,0E6H,07CH,000H ; 0 D_30
   579 0000F4EC 307030303030FC00    <2> 	DB	030H,070H,030H,030H,030H,030H,0FCH,000H ; 1 D_31
   580 0000F4F4 78CC0C3860CCFC00    <2> 	DB	078H,0CCH,00CH,038H,060H,0CCH,0FCH,000H ; 2 D_32
   581 0000F4FC 78CC0C380CCC7800    <2> 	DB	078H,0CCH,00CH,038H,00CH,0CCH,078H,000H ; 3 D_33
   582 0000F504 1C3C6CCCFE0C1E00    <2> 	DB	01CH,03CH,06CH,0CCH,0FEH,00CH,01EH,000H ; 4 D_34
   583 0000F50C FCC0F80C0CCC7800    <2> 	DB	0FCH,0C0H,0F8H,00CH,00CH,0CCH,078H,000H ; 5 D_35
   584 0000F514 3860C0F8CCCC7800    <2> 	DB	038H,060H,0C0H,0F8H,0CCH,0CCH,078H,000H ; 6 D_36
   585 0000F51C FCCC0C1830303000    <2> 	DB	0FCH,0CCH,00CH,018H,030H,030H,030H,000H ; 7 D_37
   586 0000F524 78CCCC78CCCC7800    <2> 	DB	078H,0CCH,0CCH,078H,0CCH,0CCH,078H,000H ; 8 D_38
   587 0000F52C 78CCCC7C0C187000    <2> 	DB	078H,0CCH,0CCH,07CH,00CH,018H,070H,000H ; 9 D_39
   588 0000F534 0030300000303000    <2> 	DB	000H,030H,030H,000H,000H,030H,030H,000H ; : D_3A
   589 0000F53C 0030300000303060    <2> 	DB	000H,030H,030H,000H,000H,030H,030H,060H ; ; D_3B
   590 0000F544 183060C060301800    <2> 	DB	018H,030H,060H,0C0H,060H,030H,018H,000H ; < D_3C
   591 0000F54C 0000FC0000FC0000    <2> 	DB	000H,000H,0FCH,000H,000H,0FCH,000H,000H ; = D_3D
   592 0000F554 6030180C18306000    <2> 	DB	060H,030H,018H,00CH,018H,030H,060H,000H ; > D_3E
   593 0000F55C 78CC0C1830003000    <2> 	DB	078H,0CCH,00CH,018H,030H,000H,030H,000H ; ? D_3F
   594                              <2> 
   595 0000F564 7CC6DEDEDEC07800    <2> 	DB	07CH,0C6H,0DEH,0DEH,0DEH,0C0H,078H,000H ; @ D_40
   596 0000F56C 3078CCCCFCCCCC00    <2> 	DB	030H,078H,0CCH,0CCH,0FCH,0CCH,0CCH,000H ; A D_41
   597 0000F574 FC66667C6666FC00    <2> 	DB	0FCH,066H,066H,07CH,066H,066H,0FCH,000H ; B D_42
   598 0000F57C 3C66C0C0C0663C00    <2> 	DB	03CH,066H,0C0H,0C0H,0C0H,066H,03CH,000H ; C D_43
   599 0000F584 F86C6666666CF800    <2> 	DB	0F8H,06CH,066H,066H,066H,06CH,0F8H,000H ; D D_44
   600 0000F58C FE6268786862FE00    <2> 	DB	0FEH,062H,068H,078H,068H,062H,0FEH,000H ; E D_45
   601 0000F594 FE6268786860F000    <2> 	DB	0FEH,062H,068H,078H,068H,060H,0F0H,000H ; F D_46
   602 0000F59C 3C66C0C0CE663E00    <2> 	DB	03CH,066H,0C0H,0C0H,0CEH,066H,03EH,000H ; G D_47
   603 0000F5A4 CCCCCCFCCCCCCC00    <2> 	DB	0CCH,0CCH,0CCH,0FCH,0CCH,0CCH,0CCH,000H ; H D_48
   604 0000F5AC 7830303030307800    <2> 	DB	078H,030H,030H,030H,030H,030H,078H,000H ; I D_49
   605 0000F5B4 1E0C0C0CCCCC7800    <2> 	DB	01EH,00CH,00CH,00CH,0CCH,0CCH,078H,000H ; J D_4A
   606 0000F5BC E6666C786C66E600    <2> 	DB	0E6H,066H,06CH,078H,06CH,066H,0E6H,000H ; K D_4B
   607 0000F5C4 F06060606266FE00    <2> 	DB	0F0H,060H,060H,060H,062H,066H,0FEH,000H ; L D_4C
   608 0000F5CC C6EEFEFED6C6C600    <2> 	DB	0C6H,0EEH,0FEH,0FEH,0D6H,0C6H,0C6H,000H ; M D_4C
   609 0000F5D4 C6E6F6DECEC6C600    <2> 	DB	0C6H,0E6H,0F6H,0DEH,0CEH,0C6H,0C6H,000H ; N D_4E
   610 0000F5DC 386CC6C6C66C3800    <2> 	DB	038H,06CH,0C6H,0C6H,0C6H,06CH,038H,000H ; O D_4F
   611                              <2> 
   612 0000F5E4 FC66667C6060F000    <2> 	DB	0FCH,066H,066H,07CH,060H,060H,0F0H,000H ; P D_50
   613 0000F5EC 78CCCCCCDC781C00    <2> 	DB	078H,0CCH,0CCH,0CCH,0DCH,078H,01CH,000H ; Q D_51
   614 0000F5F4 FC66667C6C66E600    <2> 	DB	0FCH,066H,066H,07CH,06CH,066H,0E6H,000H ; R D_52
   615 0000F5FC 78CCE0701CCC7800    <2> 	DB	078H,0CCH,0E0H,070H,01CH,0CCH,078H,000H ; S D_53
   616 0000F604 FCB4303030307800    <2> 	DB	0FCH,0B4H,030H,030H,030H,030H,078H,000H ; T D_54
   617 0000F60C CCCCCCCCCCCCFC00    <2> 	DB	0CCH,0CCH,0CCH,0CCH,0CCH,0CCH,0FCH,000H ; U D_55
   618 0000F614 CCCCCCCCCC783000    <2> 	DB	0CCH,0CCH,0CCH,0CCH,0CCH,078H,030H,000H ; V D_56
   619 0000F61C C6C6C6D6FEEEC600    <2> 	DB	0C6H,0C6H,0C6H,0D6H,0FEH,0EEH,0C6H,000H ; W D_57
   620 0000F624 C6C66C38386CC600    <2> 	DB	0C6H,0C6H,06CH,038H,038H,06CH,0C6H,000H ; X D_58
   621 0000F62C CCCCCC7830307800    <2> 	DB	0CCH,0CCH,0CCH,078H,030H,030H,078H,000H ; Y D_59
   622 0000F634 FEC68C183266FE00    <2> 	DB	0FEH,0C6H,08CH,018H,032H,066H,0FEH,000H ; Z D_5A
   623 0000F63C 7860606060607800    <2> 	DB	078H,060H,060H,060H,060H,060H,078H,000H ; [ D_5B
   624 0000F644 C06030180C060200    <2> 	DB	0C0H,060H,030H,018H,00CH,006H,002H,000H ; BACKSLASH D_5C
   625 0000F64C 7818181818187800    <2> 	DB	078H,018H,018H,018H,018H,018H,078H,000H ; ] D_5D
   626 0000F654 10386CC600000000    <2> 	DB	010H,038H,06CH,0C6H,000H,000H,000H,000H ; CIRCUMFLEX D_5E
   627 0000F65C 00000000000000FF    <2> 	DB	000H,000H,000H,000H,000H,000H,000H,0FFH ; _ D_5F
   628                              <2> 
   629 0000F664 3030180000000000    <2> 	DB	030H,030H,018H,000H,000H,000H,000H,000H ;   D_60
   630 0000F66C 0000780C7CCC7600    <2> 	DB	000H,000H,078H,00CH,07CH,0CCH,076H,000H ; LOWER CASE A D_61
   631 0000F674 E060607C6666DC00    <2> 	DB	0E0H,060H,060H,07CH,066H,066H,0DCH,000H ; L.C. B D_62
   632 0000F67C 000078CCC0CC7800    <2> 	DB	000H,000H,078H,0CCH,0C0H,0CCH,078H,000H ; L.C. C D_63
   633 0000F684 1C0C0C7CCCCC7600    <2> 	DB	01CH,00CH,00CH,07CH,0CCH,0CCH,076H,000H ; L.C. D D_64
   634 0000F68C 000078CCFCC07800    <2> 	DB	000H,000H,078H,0CCH,0FCH,0C0H,078H,000H ; L.C. E D_65
   635 0000F694 386C60F06060F000    <2> 	DB	038H,06CH,060H,0F0H,060H,060H,0F0H,000H ; L.C. F D_66
   636 0000F69C 000076CCCC7C0CF8    <2> 	DB	000H,000H,076H,0CCH,0CCH,07CH,00CH,0F8H ; L.C. G D_67
   637 0000F6A4 E0606C766666E600    <2> 	DB	0E0H,060H,06CH,076H,066H,066H,0E6H,000H ; L.C. H D_68
   638 0000F6AC 3000703030307800    <2> 	DB	030H,000H,070H,030H,030H,030H,078H,000H ; L.C. I D_69
   639 0000F6B4 0C000C0C0CCCCC78    <2> 	DB	00CH,000H,00CH,00CH,00CH,0CCH,0CCH,078H ; L.C. J D_6A
   640 0000F6BC E060666C786CE600    <2> 	DB	0E0H,060H,066H,06CH,078H,06CH,0E6H,000H ; L.C. K D_6B
   641 0000F6C4 7030303030307800    <2> 	DB	070H,030H,030H,030H,030H,030H,078H,000H ; L.C. L D_6C
   642 0000F6CC 0000CCFEFED6C600    <2> 	DB	000H,000H,0CCH,0FEH,0FEH,0D6H,0C6H,000H ; L.C. M D_6D
   643 0000F6D4 0000F8CCCCCCCC00    <2> 	DB	000H,000H,0F8H,0CCH,0CCH,0CCH,0CCH,000H ; L.C. N D_6E
   644 0000F6DC 000078CCCCCC7800    <2> 	DB	000H,000H,078H,0CCH,0CCH,0CCH,078H,000H ; L.C. O D_6F
   645                              <2> 
   646 0000F6E4 0000DC66667C60F0    <2> 	DB	000H,000H,0DCH,066H,066H,07CH,060H,0F0H ; L.C. P D_70
   647 0000F6EC 000076CCCC7C0C1E    <2> 	DB	000H,000H,076H,0CCH,0CCH,07CH,00CH,01EH ; L.C. Q D_71
   648 0000F6F4 0000DC766660F000    <2> 	DB	000H,000H,0DCH,076H,066H,060H,0F0H,000H ; L.C. R D_72
   649 0000F6FC 00007CC0780CF800    <2> 	DB	000H,000H,07CH,0C0H,078H,00CH,0F8H,000H ; L.C. S D_73
   650 0000F704 10307C3030341800    <2> 	DB	010H,030H,07CH,030H,030H,034H,018H,000H ; L.C. T D_74
   651 0000F70C 0000CCCCCCCC7600    <2> 	DB	000H,000H,0CCH,0CCH,0CCH,0CCH,076H,000H ; L.C. U D_75
   652 0000F714 0000CCCCCC783000    <2> 	DB	000H,000H,0CCH,0CCH,0CCH,078H,030H,000H ; L.C. V D_76
   653 0000F71C 0000C6D6FEFE6C00    <2> 	DB	000H,000H,0C6H,0D6H,0FEH,0FEH,06CH,000H ; L.C. W D_77
   654 0000F724 0000C66C386CC600    <2> 	DB	000H,000H,0C6H,06CH,038H,06CH,0C6H,000H ; L.C. X D_78
   655 0000F72C 0000CCCCCC7C0CF8    <2> 	DB	000H,000H,0CCH,0CCH,0CCH,07CH,00CH,0F8H ; L.C. Y D_79
   656 0000F734 0000FC983064FC00    <2> 	DB	000H,000H,0FCH,098H,030H,064H,0FCH,000H ; L.C. Z D_7A
   657 0000F73C 1C3030E030301C00    <2> 	DB	01CH,030H,030H,0E0H,030H,030H,01CH,000H ;   D_7B
   658 0000F744 1818180018181800    <2> 	DB	018H,018H,018H,000H,018H,018H,018H,000H ;   D_7C
   659 0000F74C E030301C3030E000    <2> 	DB	0E0H,030H,030H,01CH,030H,030H,0E0H,000H ;   D_7D
   660 0000F754 76DC000000000000    <2> 	DB	076H,0DCH,000H,000H,000H,000H,000H,000H ;   D_7E
   661 0000F75C 0010386CC6C6FE00    <2> 	DB	000H,010H,038H,06CH,0C6H,0C6H,0FEH,000H ; DELTA D_7F
   662                              <2> 
   250                              <1> 
   251                              <1> INT11: ;Equipment Check	
   252 0000F764 1E                  <1> 	PUSH DS			;STORE DS
   253 0000F765 53                  <1> 	PUSH BX			;STORE BX
   254 0000F766 B84000              <1> 	MOV AX, 0X0040			;BIOS DATA AREA
   255 0000F769 8ED8                <1> 	MOV DS, AX			;SET DATA SEGMENT
   256 0000F76B BB1000              <1> 	MOV BX, 0X0010			;OFFSET 0X10 EQUIPMENT LIST
   257 0000F76E 8B07                <1> 	MOV AX, WORD [BX]			;STORE EQUPMENT LIST AX
   258 0000F770 5B                  <1> 	POP BX			;RESTORE BX
   259 0000F771 1F                  <1> 	POP DS			;RESTORE DS
   260 0000F772 CF                  <1> 	IRET			;RETRUN
   261                              <1> INT12: ;Memory	
   262 0000F773 1E                  <1> 	PUSH DS			;STORE DS
   263 0000F774 53                  <1> 	PUSH BX			;STORE BX
   264 0000F775 B84000              <1> 	MOV AX, 0X0040			;BIOS DATA AREA
   265 0000F778 8ED8                <1> 	MOV DS, AX			;SET DATA SEGMENT
   266 0000F77A BB1300              <1> 	MOV BX, 0X0013			;OFFSET 0X13 FOR MEMORY SIZE
   267 0000F77D 8B07                <1> 	MOV AX, WORD [BX]			;STORE MEMORY SIZE AX
   268 0000F77F 5B                  <1> 	POP BX			;RESTORE BX
   269 0000F780 1F                  <1> 	POP DS			;RESTORE DS
   270 0000F781 CF                  <1> 	IRET			;RETRUN
   271                              <1> 
   272                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   273                              <1> ;INT 0X13
   274                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   275                              <1> ;;%INCLUDE "code/asm/int13.asm"
   276                              <1> 
   277                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   278                              <1> ;INT14: ;Communications
   279                              <1> ;	IRET
   280                              <1> ;%INCLUDE "code/serial2.inc"
   281                              <1> INT14:
   282 0000F782 CF                  <1> 	iret
   283                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   284                              <1> 
   285                              <1> INT15: ;Cassette
   286 0000F783 B000                <1> 	MOV AL, 0X00			;AL = 0X00
   287 0000F785 B486                <1> 	MOV AH, 0X86			;NO CASSETTE PRESENT
   288 0000F787 F9                  <1> 	STC			;NOT BIOS SUPPORTED
   289                              <1> 				;THIS IS HOW I RETURN THE CARRY FLAG
   290 0000F788 50                  <1> 	PUSH AX			;STORE AX
   291 0000F789 9C                  <1> 	PUSHF			;STORE FLAGS
   292 0000F78A 58                  <1> 	POP AX			;GET AX = FLAGS
   293 0000F78B 55                  <1> 	PUSH BP			;STORE BP
   294 0000F78C 89E5                <1> 	MOV BP, SP              ;Copy SP to BP for use as index
   295 0000F78E 83C508              <1> 	ADD BP, 0X08			;offset 8
   296 0000F791 836600FE            <1> 	AND WORD [BP], 0XFFFE			;CLEAR CF = ZER0
   297 0000F795 83E001              <1> 	AND AX, 0X0001			;ONLY CF 
   298 0000F798 094600              <1> 	OR	WORD [BP], AX		;SET CF AX
   299 0000F79B 5D                  <1> 	POP BP               			;RESTORE BASE POINTER
   300 0000F79C 58                  <1> 	POP AX			;RESTORE AX	
   301 0000F79D CF                  <1> 	IRET			;RETRUN	
   302                              <1> 	
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ;INT 0X16
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> %INCLUDE "code/asm/int16.asm"
     1                              <2> INT16: ;Keyboard
     2                              <2> 
     3 0000F79E 80FC00              <2> 	CMP AH, 0X00			;Check ah 
     4 0000F7A1 740C                <2> 	JZ .WAIT_FOR_KEY			;ah=0
     5 0000F7A3 80FC01              <2> 	CMP AH, 0X01					
     6 0000F7A6 7438                <2> 	JZ .CHECK_ZERO_FLAG			;ah=1
     7 0000F7A8 80FC02              <2> 	CMP AH, 0X02					
     8 0000F7AB 745D                <2> 	JZ .GET_SHIFT_FLAGS			;ah=2
     9 0000F7AD FB                  <2> 	STI
    10 0000F7AE CF                  <2> 	IRET
    11                              <2> 
    12                              <2>   .WAIT_FOR_KEY:
    13 0000F7AF 53                  <2> 	PUSH BX
    14 0000F7B0 1E                  <2> 	PUSH DS
    15                              <2>   .WAIT_FOR_KEY_LOOP:
    16 0000F7B1 FB                  <2> 	STI
    17 0000F7B2 B84000              <2> 	MOV AX, 0X0040
    18 0000F7B5 8ED8                <2> 	MOV DS, AX
    19 0000F7B7 FA                  <2> 	CLI
    20 0000F7B8 8B1E1A00            <2> 	MOV BX, [0X001A]			;Tail
    21 0000F7BC 3B1E1C00            <2> 	CMP BX, [0X001C]			;Head
    22 0000F7C0 74EF                <2> 	JZ .WAIT_FOR_KEY_LOOP
    23 0000F7C2 8B07                <2> 	MOV AX, [BX]				;GET SCAN CODE / CHAR CODE 
    24 0000F7C4 83C302              <2> 	ADD BX, 0X0002			   	;Mov bx forward through buffer
    25 0000F7C7 3B1E8200            <2> 	CMP BX, [0X0082]			;Check to see if at the end
    26 0000F7CB 7204                <2> 	JB .NOT_END_OF_BUFFER		;Jump over next step if not at the end
    27 0000F7CD 8B1E8000            <2> 	MOV BX, [0X0080]			;Set bx back to begining 
    28                              <2> 	.NOT_END_OF_BUFFER:
    29 0000F7D1 891E1A00            <2> 	MOV [0X001A], BX	
    30 0000F7D5 1F                  <2> 	POP DS
    31 0000F7D6 5B                  <2> 	POP BX
    32 0000F7D7 3CE0                <2> 	CMP AL, 0XE0
    33 0000F7D9 7402                <2> 	JZ .AL_0
    34 0000F7DB FB                  <2> 	STI
    35 0000F7DC CF                  <2> 	IRET
    36                              <2> 	
    37                              <2>   .AL_0:
    38 0000F7DD B000                <2> 	MOV AL, 0x00
    39 0000F7DF CF                  <2> 	IRET
    40                              <2> 
    41                              <2>   .CHECK_ZERO_FLAG:	
    42 0000F7E0 53                  <2>   	PUSH BX				
    43 0000F7E1 1E                  <2> 	PUSH DS
    44 0000F7E2 B84000              <2> 	MOV AX, 0X0040
    45 0000F7E5 8ED8                <2> 	MOV DS, AX
    46                              <2> 
    47 0000F7E7 8B1E1A00            <2> 	MOV BX, [0X001A]			;Tail
    48 0000F7EB 3B1E1C00            <2> 	CMP BX, [0X001C]			;Head
    49 0000F7EF 8B07                <2> 	MOV AX, [BX]
    50 0000F7F1 1F                  <2> 	POP DS
    51 0000F7F2 5B                  <2> 	POP BX
    52                              <2> 	
    53 0000F7F3 50                  <2> 	PUSH AX					;STORE AX
    54 0000F7F4 9C                  <2> 	PUSHF					;STORE FLAGES
    55 0000F7F5 58                  <2> 	POP AX					;AX = FLAGS
    56 0000F7F6 55                  <2>     PUSH BP					;STORE BP
    57 0000F7F7 89E5                <2> 	MOV BP, SP             	;Copy SP to BP for use as index
    58 0000F7F9 83C508              <2> 	ADD BP, 0X08			;offset 8
    59 0000F7FC 836600BF            <2> 	AND WORD [BP], 0XFFBF	;CLEAR ZF
    60 0000F800 83E040              <2> 	AND AX, 0X0040			;ONLY ZF
    61 0000F803 094600              <2> 	OR	WORD [BP], AX		;SET ZF
    62 0000F806 5D                  <2> 	POP BP               	;RESTORE BASE POINTER
    63 0000F807 58                  <2> 	POP AX					;RESTORE AX
    64 0000F808 FB                  <2> 	STI
    65 0000F809 CF                  <2> 	IRET
    66                              <2> 	
    67                              <2>   .GET_SHIFT_FLAGS:	  
    68 0000F80A B80000              <2> 	MOV AX, 0X0000			;FOR NOW RETURNS NOTHING. 
    69 0000F80D FB                  <2> 	STI
    70 0000F80E CF                  <2> 	IRET
   307                              <1> 	
   308                              <1> INT17: ;Printer	
   309 0000F80F CF                  <1> 	IRET
   310                              <1> 
   311                              <1> INT18: ;Resident Basic
   312 0000F810 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   313 0000F812 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   314 0000F814 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   315 0000F816 B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   316 0000F818 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   317 0000F81A B038                <1> 	MOV AL, '8'		;SET AL TO CHAR
   318 0000F81C CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   319                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   320 0000F81E CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   321                              <1> 
   322                              <1> INT19: ;Bootstrap
   323 0000F81F EA0000FFFF          <1> 	JMP 0XFFFF:0X0000			;JUMPS TO BOOT CODE
   324                              <1> 
   325                              <1> INT1A: ;Time of Day
   326 0000F824 1E                  <1> 	PUSH DS
   327 0000F825 53                  <1>   	PUSH BX
   328 0000F826 B84000              <1> 	MOV AX, 0X0040			;BIOS DATA AREA
   329 0000F829 8ED8                <1> 	MOV DS, AX			;SET DS
   330 0000F82B BB6C00              <1> 	MOV BX, 0X006C			;NUMBER OF CLICKS
   331 0000F82E 8B17                <1> 	MOV DX, WORD [BX]			;SET DX CLICKS
   332 0000F830 83C302              <1> 	ADD BX, 0X0002
   333 0000F833 8B0F                <1> 	MOV CX, WORD [BX]			;0X006E
   334 0000F835 83E10F              <1> 	AND CX, 0x000F
   335 0000F838 B80000              <1> 	MOV AX, 0X0000			;
   336 0000F83B 5B                  <1> 	POP BX
   337 0000F83C 1F                  <1> 	POP DS
   338 0000F83D CF                  <1> 	IRET
   339                              <1> 
   340                              <1> INT1B: ;Keyboard Break
   341 0000F83E B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   342 0000F840 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   343 0000F842 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   344 0000F844 B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   345 0000F846 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   346 0000F848 B042                <1> 	MOV AL, 'B'		;SET AL TO CHAR
   347 0000F84A CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   348                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   349 0000F84C CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   350                              <1> 
   351                              <1> INT1C: ;Timer Tick
   352 0000F84D CF                  <1> 	IRET			;RETURN FROM INTERRUPT
   353                              <1> 
   354                              <1> INT1D: ;Video Initialization 
   355 0000F84E B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   356 0000F850 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   357 0000F852 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   358 0000F854 B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   359 0000F856 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   360 0000F858 B044                <1> 	MOV AL, 'D'		;SET AL TO CHAR
   361 0000F85A CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   362                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   363 0000F85C CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   364                              <1> 
   365                              <1> INT1E: ;Diskette Parameters
   366 0000F85D B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   367 0000F85F B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   368 0000F861 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   369 0000F863 B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   370 0000F865 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   371 0000F867 B045                <1> 	MOV AL, 'E'		;SET AL TO CHAR
   372 0000F869 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   373                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   374 0000F86B CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   375                              <1> 
   376                              <1> INT1F: ;Video Graphics Characters
   377 0000F86C B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   378 0000F86E B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   379 0000F870 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   380 0000F872 B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   381 0000F874 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   382 0000F876 B046                <1> 	MOV AL, 'F'		;SET AL TO CHAR
   383 0000F878 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   384                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   385 0000F87A CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   386                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   387                              <1> ;EXTRA FUNCTIONS
   388                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   389                              <1> %INCLUDE "code/asm/functions.asm"
     1                              <2> ;EXTRA FUNCTIONS
     2                              <2> DUMP_REGISTERS:	
     3 0000F87B 50                  <2> 	PUSH AX
     4 0000F87C 52                  <2> 	PUSH DX
     5 0000F87D 51                  <2> 	PUSH CX
     6 0000F87E 53                  <2> 	PUSH BX
     7 0000F87F 50                  <2> 	PUSH AX	
     8                              <2> 	
     9 0000F880 B40E                <2> 	MOV AH, 0X0E
    10 0000F882 B020                <2> 	MOV AL, ' '
    11 0000F884 CD10                <2> 	INT 0X10
    12 0000F886 B041                <2> 	MOV AL, 'A'
    13 0000F888 CD10                <2> 	INT 0X10
    14 0000F88A B058                <2> 	MOV AL, 'X'	
    15 0000F88C CD10                <2> 	INT 0X10
    16 0000F88E B03D                <2> 	MOV AL, '='
    17 0000F890 CD10                <2> 	INT 0X10	
    18 0000F892 58                  <2> 	POP AX
    19 0000F893 50                  <2> 	PUSH AX
    20 0000F894 88E0                <2> 	MOV AL, AH
    21 0000F896 E86700              <2> 	CALL WRITE_AL_INT10_E
    22 0000F899 58                  <2> 	POP AX
    23 0000F89A E86300              <2> 	CALL WRITE_AL_INT10_E
    24                              <2> 	
    25 0000F89D B40E                <2> 	MOV AH, 0X0E
    26 0000F89F B020                <2> 	MOV AL, ' '
    27 0000F8A1 CD10                <2> 	INT 0X10
    28 0000F8A3 B042                <2> 	MOV AL, 'B'
    29 0000F8A5 CD10                <2> 	INT 0X10
    30 0000F8A7 B058                <2> 	MOV AL, 'X'	
    31 0000F8A9 CD10                <2> 	INT 0X10
    32 0000F8AB B03D                <2> 	MOV AL, '='
    33 0000F8AD CD10                <2> 	INT 0X10	
    34 0000F8AF 58                  <2> 	POP AX
    35 0000F8B0 50                  <2> 	PUSH AX
    36 0000F8B1 88E0                <2> 	MOV AL, AH
    37 0000F8B3 E84A00              <2> 	CALL WRITE_AL_INT10_E
    38 0000F8B6 58                  <2> 	POP AX
    39 0000F8B7 E84600              <2> 	CALL WRITE_AL_INT10_E
    40                              <2> 	
    41 0000F8BA B40E                <2> 	MOV AH, 0X0E
    42 0000F8BC B020                <2> 	MOV AL, ' '
    43 0000F8BE CD10                <2> 	INT 0X10
    44 0000F8C0 B043                <2> 	MOV AL, 'C'
    45 0000F8C2 CD10                <2> 	INT 0X10
    46 0000F8C4 B058                <2> 	MOV AL, 'X'	
    47 0000F8C6 CD10                <2> 	INT 0X10
    48 0000F8C8 B03D                <2> 	MOV AL, '='
    49 0000F8CA CD10                <2> 	INT 0X10	
    50 0000F8CC 58                  <2> 	POP AX
    51 0000F8CD 50                  <2> 	PUSH AX
    52 0000F8CE 88E0                <2> 	MOV AL, AH
    53 0000F8D0 E82D00              <2> 	CALL WRITE_AL_INT10_E
    54 0000F8D3 58                  <2> 	POP AX
    55 0000F8D4 E82900              <2> 	CALL WRITE_AL_INT10_E
    56                              <2> 	
    57 0000F8D7 B40E                <2> 	MOV AH, 0X0E
    58 0000F8D9 B020                <2> 	MOV AL, ' '
    59 0000F8DB CD10                <2> 	INT 0X10
    60 0000F8DD B044                <2> 	MOV AL, 'D'
    61 0000F8DF CD10                <2> 	INT 0X10
    62 0000F8E1 B058                <2> 	MOV AL, 'X'	
    63 0000F8E3 CD10                <2> 	INT 0X10
    64 0000F8E5 B03D                <2> 	MOV AL, '='
    65 0000F8E7 CD10                <2> 	INT 0X10	
    66 0000F8E9 58                  <2> 	POP AX
    67 0000F8EA 50                  <2> 	PUSH AX
    68 0000F8EB 88E0                <2> 	MOV AL, AH
    69 0000F8ED E81000              <2> 	CALL WRITE_AL_INT10_E
    70 0000F8F0 58                  <2> 	POP AX
    71 0000F8F1 E80C00              <2> 	CALL WRITE_AL_INT10_E
    72                              <2> 	
    73 0000F8F4 B40E                <2> 	MOV AH, 0X0E
    74 0000F8F6 B00D                <2> 	MOV AL, 0X0D
    75 0000F8F8 CD10                <2> 	INT 0X10
    76 0000F8FA B00A                <2> 	MOV AL, 0X0A
    77 0000F8FC CD10                <2> 	INT 0X10	
    78 0000F8FE 58                  <2> 	POP AX
    79 0000F8FF C3                  <2> 	RET
    80                              <2> ;;;;;;;;;;;;;;;;;;;;;;;
    81                              <2> ;WRITE TO SCREEN;;;;;;;
    82                              <2> ;;;;;;;;;;;;;;;;;;;;;;;
    83                              <2> WRITE_AL_INT10_E:
    84                              <2> 
    85 0000F900 50                  <2> 	PUSH AX
    86 0000F901 53                  <2> 	PUSH BX
    87 0000F902 51                  <2> 	PUSH CX
    88 0000F903 52                  <2> 	PUSH DX
    89                              <2> 
    90 0000F904 88C3                <2> 	MOV BL, AL
    91                              <2> 
    92 0000F906 88C6                <2> 	MOV DH, AL
    93 0000F908 B104                <2> 	MOV CL, 0X04
    94 0000F90A D2EE                <2> 	SHR DH, CL
    95                              <2> 
    96 0000F90C 88F0                <2> 	MOV AL, DH
    97 0000F90E 240F                <2> 	AND AL, 0X0F
    98 0000F910 3C09                <2> 	CMP AL, 0X09
    99 0000F912 7704                <2> 	JA LETTER_HIGH
   100                              <2> 
   101 0000F914 0430                <2> 	ADD AL, 0X30
   102 0000F916 EB02                <2> 	JMP PRINT_VALUE_HIGH
   103                              <2> 
   104                              <2> 	LETTER_HIGH:
   105 0000F918 0437                <2> 	ADD AL, 0X37
   106                              <2> 
   107                              <2> 	PRINT_VALUE_HIGH:
   108 0000F91A B40E                <2> 	MOV AH, 0X0E
   109 0000F91C CD10                <2> 	INT 0X10
   110                              <2> 
   111 0000F91E 88D8                <2> 	MOV AL, BL
   112 0000F920 240F                <2> 	AND AL, 0X0F
   113 0000F922 3C09                <2> 	CMP AL, 0X09
   114 0000F924 7704                <2> 	JA LETTER_LOW
   115                              <2> 
   116 0000F926 0430                <2> 	ADD AL, 0X30
   117 0000F928 EB02                <2> 	JMP PRINT_VALUE_LOW
   118                              <2> 
   119                              <2> 	LETTER_LOW:
   120 0000F92A 0437                <2> 	ADD AL, 0X37
   121                              <2> 
   122                              <2> 	PRINT_VALUE_LOW:
   123 0000F92C B40E                <2> 	MOV AH, 0X0E
   124 0000F92E CD10                <2> 	INT 0X10
   125                              <2> 
   126 0000F930 5A                  <2> 	POP DX
   127 0000F931 59                  <2> 	POP CX
   128 0000F932 5B                  <2> 	POP BX
   129 0000F933 58                  <2> 	POP AX
   130                              <2> 
   131 0000F934 C3                  <2> 	RET
   132                              <2> 
   133                              <2> WAIT_1:
   134 0000F935 51                  <2> 	PUSH CX
   135 0000F936 B9FFFF              <2> 	MOV CX, 0XFFFF
   136                              <2>   .LOOP1:
   137 0000F939 E2FE                <2> 	LOOP .LOOP1
   138 0000F93B 59                  <2> 	POP CX
   139 0000F93C C3                  <2> 	RET
   140                              <2> 
   141                              <2> WAIT_2:
   142 0000F93D 51                  <2> 	PUSH CX
   143 0000F93E B9FFFF              <2> 	MOV CX, 0xFFFF		; 65536 runs = ~300k cycles = 40ms
   144 0000F941 E2FE                <2> DELAY: LOOP DELAY
   145 0000F943 B9FFFF              <2> 	MOV CX, 0xFFFF		; 65536 runs = ~300k cycles = 40ms
   146 0000F946 E2FE                <2> DELAY2: LOOP DELAY2
   147 0000F948 59                  <2> 	POP CX
   148 0000F949 C3                  <2> 	RET
   149                              <2> 
   150                              <2> WAIT_8:
   151 0000F94A 51                  <2> 	PUSH CX
   152 0000F94B B90800              <2> 	MOV CX, 8
   153                              <2>   .LOOP1:
   154 0000F94E 51                  <2> 	PUSH CX
   155 0000F94F B9FFFF              <2> 	MOV CX, 0XFFFF
   156                              <2>   .LOOP2:
   157 0000F952 E2FE                <2> 	LOOP .LOOP2
   158 0000F954 59                  <2> 	POP CX
   159 0000F955 E2F7                <2> 	LOOP .LOOP1
   160 0000F957 59                  <2> 	POP CX
   161 0000F958 C3                  <2> 	RET
   162                              <2> 	
   163                              <2> WAIT_16:
   164 0000F959 51                  <2> 	PUSH CX
   165 0000F95A B91000              <2> 	MOV CX, 16
   166                              <2>   .LOOP1:
   167 0000F95D 51                  <2> 	PUSH CX
   168 0000F95E B9FFFF              <2> 	MOV CX, 0XFFFF
   169                              <2>   .LOOP2:
   170 0000F961 E2FE                <2> 	LOOP .LOOP2
   171 0000F963 59                  <2> 	POP CX
   172 0000F964 E2F7                <2> 	LOOP .LOOP1
   173 0000F966 59                  <2> 	POP CX
   174 0000F967 C3                  <2> 	RET
   175                              <2> 	
   176                              <2> WAIT_32:
   177 0000F968 51                  <2> 	PUSH CX
   178 0000F969 B92000              <2> 	MOV CX, 32
   179                              <2>   .LOOP1:
   180 0000F96C 51                  <2> 	PUSH CX
   181 0000F96D B9FFFF              <2> 	MOV CX, 0XFFFF
   182                              <2>   .LOOP2:
   183 0000F970 E2FE                <2> 	LOOP .LOOP2
   184 0000F972 59                  <2> 	POP CX
   185 0000F973 E2F7                <2> 	LOOP .LOOP1
   186 0000F975 59                  <2> 	POP CX
   187 0000F976 C3                  <2> 	RET
   188                              <2> 
   189                              <2> WAIT_64:
   190 0000F977 51                  <2> 	PUSH CX
   191 0000F978 B94000              <2> 	MOV CX, 64
   192                              <2>   .LOOP1:
   193 0000F97B 51                  <2> 	PUSH CX
   194 0000F97C B9FFFF              <2> 	MOV CX, 0XFFFF
   195                              <2>   .LOOP2:
   196 0000F97F E2FE                <2> 	LOOP .LOOP2
   197 0000F981 59                  <2> 	POP CX
   198 0000F982 E2F7                <2> 	LOOP .LOOP1
   199 0000F984 59                  <2> 	POP CX
   200 0000F985 C3                  <2> 	RET
   201                              <2> 
   202                              <2> WAIT_128:
   203 0000F986 51                  <2> 	PUSH CX
   204 0000F987 B98000              <2> 	MOV CX, 128
   205                              <2>   .LOOP1:
   206 0000F98A 51                  <2> 	PUSH CX
   207 0000F98B B9FFFF              <2> 	MOV CX, 0XFFFF
   208                              <2>   .LOOP2:
   209 0000F98E E2FE                <2> 	LOOP .LOOP2
   210 0000F990 59                  <2> 	POP CX
   211 0000F991 E2F7                <2> 	LOOP .LOOP1
   212 0000F993 59                  <2> 	POP CX
   213 0000F994 C3                  <2> 	RET
   214                              <2> 	
   215                              <2> 	
   216                              <2> WAIT_512:
   217 0000F995 51                  <2> 	PUSH CX
   218 0000F996 B90002              <2> 	MOV CX, 512
   219                              <2>   .LOOP1:
   220 0000F999 51                  <2> 	PUSH CX
   221 0000F99A B9FFFF              <2> 	MOV CX, 0XFFFF
   222                              <2>   .LOOP2:
   223 0000F99D E2FE                <2> 	LOOP .LOOP2
   224 0000F99F 59                  <2> 	POP CX
   225 0000F9A0 E2F7                <2> 	LOOP .LOOP1
   226 0000F9A2 59                  <2> 	POP CX
   227 0000F9A3 C3                  <2> 	RET
   228                              <2> 
   229 0000F9A4 0D0A43707520203830- <2> str_8088        db      0Dh, 0Ah,"Cpu  8088 detected sem  FPU",0Dh, 0Ah,0
   229 0000F9AD 383820646574656374- <2>
   229 0000F9B6 65642073656D202046- <2>
   229 0000F9BF 50550D0A00          <2>
   230 0000F9C4 0D0A437075204E6563- <2> str_v20         db      0Dh, 0Ah,"Cpu Nec V20 detected sem FPU",0Dh, 0Ah,0
   230 0000F9CD 205632302064657465- <2>
   230 0000F9D6 637465642073656D20- <2>
   230 0000F9DF 4650550D0A00        <2>
   231                              <2> cpu_check:
   232 0000F9E5 30C0                <2> 	xor	al, al				; Clean out al to set ZF
   233 0000F9E7 B040                <2> 	mov	al, 40h				; mul on V20 does not affect the zero flag
   234 0000F9E9 F6E0                <2> 	mul	al				;   but on an 8088 the zero flag is used
   235 0000F9EB 7407                <2> 	jz	.have_v20			; Was zero flag set?
   236 0000F9ED BE[A4F9]            <2> 	mov	si,  str_8088		;   No, so we have an 8088 CPU
   237 0000F9F0 E88AD8              <2>         call    pstr
   238 0000F9F3 C3                  <2> 	ret
   239                              <2> .have_v20:
   240 0000F9F4 BE[C4F9]            <2> 	mov	si,  str_v20		;   Otherwise we have a V20 CPU
   241 0000F9F7 E883D8              <2>         call    pstr
   242 0000F9FA C3                  <2> 	ret
   243                              <2> 
   244                              <2> BOOT_DRIVE:		
   245 0000F9FB B8C007              <2> 	MOV AX, 0X07C0 	;0X07C0:0X0000
   246 0000F9FE 8EC0                <2> 	MOV ES, AX		;ES:BX = ADDRESS BUFFER
   247 0000FA00 B80102              <2> 	MOV AX, 0X0201	;READ ONE SECTOR
   248 0000FA03 BB0000              <2> 	MOV BX, 0X0000	;ES:BX = ADDRESS BUFFER
   249 0000FA06 B90100              <2> 	MOV CX, 0X0001	;1 SECTOR
   250 0000FA09 BA8100              <2> 	MOV DX, 0X0081	;DRIVE TO BOOT UP 0=A, 80=C
   251 0000FA0C CD13                <2> 	INT 0X13		;INT 13
   252 0000FA0E B8C007              <2> 	MOV AX, 0X07C0	;SEGMENT
   253 0000FA11 8ED8                <2> 	MOV DS, AX		;SET DS
   254 0000FA13 8EC0                <2> 	MOV ES, AX		;SET ES
   255 0000FA15 B80000              <2> 	MOV AX, 0X0000	;ZERO AX
   256 0000FA18 BB0000              <2> 	MOV BX, 0X0000	;ZERO BX
   257 0000FA1B B90000              <2> 	MOV CX, 0X0000	;ZERO CX
   258 0000FA1E BA0000              <2> 	MOV DX, 0X0000	;ZERO DX
   259                              <2> jump01:	
   260 0000FA21 EA007C0000          <2> 	JMP (0x0000):0x7C00	;JMP FAR 0X07C0:0X0000	
   390                              <1> 
   280                                  
   281 0000FA26 FF<rep 5CAh>                    setloc	0FFF0h			; Power-On Entry Point, macro fills space from last line with FF
   281          ******************       warning: Inserting 1482 bytes [-w+user]
   282                                  start:
   283 0000FFF0 EA[00D0]00F0                    jmp     0F000h:reset
   284 0000FFF5 FF<rep Ah>                      setloc	0FFFFh			; Pad remainder of ROM
   284          ******************       warning: Inserting 10 bytes [-w+user]
   285 0000FFFF 86                      	      db	086h            
