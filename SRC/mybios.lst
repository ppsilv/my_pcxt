     1                                  cpu	8086
     2                                  
     3                                  %include "macros.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; macro.inc - Defines macros
     3                              <1> ;       setloc
     4                              <1> ;-------------------------------------------------------------------------
     5                              <1> ;
     6                              <1> ; Compiles with NASM 2.07, might work with other versions
     7                              <1> ;
     8                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
     9                              <1> ; Provided for hobbyist use on the Xi 8088 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;=========================================================================
    25                              <1> 
    26                              <1> ;=========================================================================
    27                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    28                              <1> ;-------------------------------------------------------------------------
    29                              <1> %imacro setloc  1.nolist
    30                              <1> %assign pad_bytes (%1-($-$$)-START)
    31                              <1> %if pad_bytes < 0
    32                              <1> %assign over_bytes -pad_bytes
    33                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
    34                              <1> %endif
    35                              <1> %if pad_bytes > 0
    36                              <1> %warning Inserting pad_bytes bytes
    37                              <1>  times  pad_bytes db 0FFh
    38                              <1> %endif
    39                              <1> %endm
    40                              <1> 
    41                              <1> %macro pic_eoi_cmd 0
    42                              <1>         push ax
    43                              <1>         ;mov al, byte es:[mem_led_reg]
    44                              <1>         ;inc al
    45                              <1>         ;mov byte es:[mem_led_reg],al
    46                              <1>         ;out 0x80, al 
    47                              <1>         mov al, 0b00100000
    48                              <1>         out PIC_REG_0, al
    49                              <1>         pop ax
    50                              <1> %endmacro
     4                                  %include "vars.inc"
     1                              <1> flagMemOk		    equ		0401h ;This location has 0 if memory block ok other wise has 1
     2                              <1> 
     3                              <1> mem_led_reg         equ     0x0501  ;Led status register
     4                              <1> mem_timeout01       equ     0x0502  ;Timer timeout value Ex.: 5 seconds
     5                              <1> mem_timer01         equ     0x0503  ;dw Timer atual value plus timeout Ex 1000 + 5 seconds 
     6                              <1> 
     7                              <1> inline_buffer       equ     0x050F  ;buffer 128 bytes
     8                              <1> buff_read           equ     0x050F  ;buffer 128 bytes
     9                              <1> buff_write          equ     0x058F  ;buffer 128 bytes
    10                              <1> abc                 equ     0x060F  ;dd 9ABCDEF0h
    11                              <1> def                 equ     0x0614  ;dd 12345678h
    12                              <1> ghi                 equ     0x0618  ;dw ?
    13                              <1> sys_tick_count      equ     0x006C  ;dw system tick
    14                              <1> bcs                 equ     0x061E  ;db byte check sum
    15                              <1> bcs_error           equ     0x061F    ; byte check sum = 1 error
    16 00000000 0200                <1> user_ds     dw 2
    17 00000002 0200                <1> user_es     dw 2
    18 00000004 0200                <1> user_ss     dw 2
    19 00000006 0200                <1> user_sp     dw 2
    20                              <1> 
    21                              <1> bs                  equ     8
     5                                  
     6                                  %define	START		0x0000		
     7                                  %define DATE		'22/11/24'
     8                                  %define MODEL_BYTE	0FEh		; IBM PC/XT
     9                                  %define VERSION		'1.0.00'	; BIOS version
    10                                  
    11                                  org	START		
    12                                  
    13                                  
    14 00000008 0D0A58542038303838-     welcome		db	cr,lf,"XT 8088 BIOS, Version "
    14 00000011 2042494F532C205665-
    14 0000001A 7273696F6E20       
    15 00000020 0D0A312E302E3030        			db	cr,lf,VERSION
    16 00000028 0D0A2E20                			db	cr,lf,". "
    17 0000002C 0D0A5061756C6F2053-     			db	cr,lf,"Paulo Silva(pgordao) - Copyright (C) 2024"
    17 00000035 696C76612870676F72-
    17 0000003E 64616F29202D20436F-
    17 00000047 707972696768742028-
    17 00000050 43292032303234     
    18 00000057 0D0A43505520383038-     			db	cr,lf,"CPU 8088-2   board: 8088BOAD2447-RA  "
    18 00000060 382D32202020626F61-
    18 00000069 72643A203830383842-
    18 00000072 4F4144323434372D52-
    18 0000007B 412020             
    19 0000007E 0D0A38303838204D6F-     			db	cr,lf,"8088 MonitorV0 V ",VERSION ," 2447A 512 Sram Rom at29C512"
    19 00000087 6E69746F7256302056-
    19 00000090 20312E302E30302032-
    19 00000099 343437412035313220-
    19 000000A2 5372616D20526F6D20-
    19 000000AB 6174323943353132   
    20 000000B3 0D0A4120746F74616C-     			db  cr,lf,"A total of 64k minimum are ok..", eos
    20 000000BC 206F662036346B206D-
    20 000000C5 696E696D756D206172-
    20 000000CE 65206F6B2E2E00     
    21                                  
    22 000000D5 0D0A3D3D3D3D3D3D3D-     help_msg	db cr,lf,"=========================="
    22 000000DE 3D3D3D3D3D3D3D3D3D-
    22 000000E7 3D3D3D3D3D3D3D3D3D-
    22 000000F0 3D                 
    23 000000F1 0D0A636D6420202064-     			db cr,lf,"cmd   description"
    23 000000FA 65736372697074696F-
    23 00000103 6E                 
    24 00000104 0D0A20642020202064-     			db cr,lf," d    dump memory using ES"
    24 0000010D 756D70206D656D6F72-
    24 00000116 79207573696E672045-
    24 0000011F 53                 
    25 00000120 0D0A20652020202065-     			db cr,lf," e    edit memory "
    25 00000129 646974206D656D6F72-
    25 00000132 7920               
    26 00000134 0D0A20662020202066-     			db cr,lf," f    fill memory "
    26 0000013D 696C6C206D656D6F72-
    26 00000146 7920               
    27 00000148 0D0A206C202020206C-     			db cr,lf," l    load intel hex file"
    27 00000151 6F616420696E74656C-
    27 0000015A 206865782066696C65 
    28 00000163 0D0A20772020202077-     			db cr,lf," w    write 16-bit data to onchip peripherals"
    28 0000016C 726974652031362D62-
    28 00000175 697420646174612074-
    28 0000017E 6F206F6E6368697020-
    28 00000187 706572697068657261-
    28 00000190 6C73               
    29 00000192 0D0A206F202020206F-     			db cr,lf," o    output byte to output port"
    29 0000019B 757470757420627974-
    29 000001A4 6520746F206F757470-
    29 000001AD 757420706F7274     
    30 000001B4 0D0A20692020202069-     			db cr,lf," i    input byte from input port"
    30 000001BD 6E7075742062797465-
    30 000001C6 2066726F6D20696E70-
    30 000001CF 757420706F7274     
    31 000001D6 0D0A20732020202072-     			db cr,lf," s    read sector 1"
    31 000001DF 65616420736563746F-
    31 000001E8 722031             
    32 000001EB 0D0A20742020202073-     			db cr,lf," t    show systick"
    32 000001F4 686F77207379737469-
    32 000001FD 636B               
    33 000001FF 0D0A20682020202066-     			db cr,lf," h    for this help", cr, lf, eos
    33 00000208 6F7220746869732068-
    33 00000211 656C700D0A00       
    34                                  
    35 00000217 FF<rep CDE9h>           setloc	0D000h
    35          ******************       warning: Inserting 52713 bytes [-w+user]
    36                                  reset:
    37 0000D000 FA                                  cli
    38 0000D001 B84000                      		mov ax,0x40
    39 0000D004 8ED8                        		mov ds,ax
    40 0000D006 C70672000000            			mov word [0x72],0x0
    41 0000D00C 31C0                        		xor ax,ax
    42 0000D00E 7248                        		jc l0xb3
    43 0000D010 7046                        		jo l0xb3
    44 0000D012 7844                        		js l0xb3
    45 0000D014 7542                        		jnz l0xb3
    46 0000D016 7B40                        		jpo l0xb3
    47 0000D018 83C001                      		add ax,0x1
    48 0000D01B 743B                        		jz l0xb3
    49 0000D01D 7A39                        		jpe l0xb3
    50 0000D01F 2D0280                      		sub ax,0x8002
    51 0000D022 7834                        		js l0xb3
    52 0000D024 40                          		inc ax
    53 0000D025 7131                        		jno l0xb3
    54 0000D027 D1E0                        		shl ax,1
    55 0000D029 732D                        		jnc l0xb3
    56 0000D02B 752B                        		jnz l0xb3
    57 0000D02D D1E0                        		shl ax,1
    58 0000D02F 7227                        		jc l0xb3   
    59 0000D031 BB5555                      		mov bx,0x5555
    60 0000D034 89DD                    l0x8f:    	mov bp,bx
    61 0000D036 89E9                        		mov cx,bp
    62 0000D038 89CC                        		mov sp,cx
    63 0000D03A 89E2                        		mov dx,sp
    64 0000D03C 8ED2                        		mov ss,dx
    65 0000D03E 8CD6                        		mov si,ss
    66 0000D040 8EC6                        		mov es,si
    67 0000D042 8CC7                        		mov di,es
    68 0000D044 8EDF                        		mov ds,di
    69 0000D046 8CD8                        		mov ax,ds
    70 0000D048 3D5555                      		cmp ax,0x5555
    71 0000D04B 7506                        		jnz l0xae
    72 0000D04D F7D0                        		not ax
    73 0000D04F 89C3                        		mov bx,ax
    74 0000D051 EBE1                        		jmp short l0x8f
    75 0000D053 35AAAA                  l0xae: 		xor ax,0xaaaa
    76 0000D056 7403                        		jz l0xb4
    77 0000D058 E9300D                  l0xb3: 		jmp led3blinks
    78 0000D05B FC                      l0xb4: 		cld                     
    79                                              ;Verify if the board has at least 32kbytes of RAM
    80 0000D05C E9CC0E                              jmp testFirst64kb
    81                                  
    82                                  initBios:
    83 0000D05F B80000                          mov ax, 0x0000
    84 0000D062 8EC0                            mov es, ax
    85 0000D064 8ED0                            mov ss, ax                  ; Segmento Stack
    86 0000D066 B800F0                          mov ax, 0xF000
    87 0000D069 8ED8                            mov ds, ax
    88 0000D06B 8EC8                    		mov cs, ax
    89                                          ;Put 0x8000 in stack pointer top of the first 32kbytes of mem
    90 0000D06D 31E4                            xor sp, sp          ;The minimum of 64k of ram are OK.
    91 0000D06F 31C0                            xor ax, ax              ; Put flags in known state
    92 0000D071 50                              PUSH AX
    93 0000D072 9D                              POPF
    94 0000D073 B000                    		mov	al, 0x0
    95 0000D075 26A20105                		mov byte es:[mem_led_reg],al
    96                                     
    97                                  ;******************************************************
    98                                  ; END INITIALIZATION
    99                                  ;======================================================
   100                                  ;PUT MAIN CODE HERE
   101 0000D079 E82301                  		call configure_uart
   102                                  
   103 0000D07C E82A0C                  		call scr_clear
   104 0000D07F BE[0800]                		mov  si, welcome
   105 0000D082 E89901                  		call pstr
   106                                  
   107 0000D085 E82F0F                  		call memoryTest
   108                                  
   109 0000D088 E8E810                  		call init_system
   110 0000D08B B000                            mov al,0x0
   111 0000D08D 26A20105                        mov byte es:[mem_led_reg],al
   112                                  		;Checking cpu type
   113 0000D091 E87C23                  		call cpu_check
   114                                  		;Loading bios 
   115 0000D094 E82B16                  		call BiosLoad
   116                                  
   117                                  Mainloop:
   118 0000D097 E86F12                  		call	printPrompt
   119 0000D09A E8C001                  		call	cin_blct
   120 0000D09D E89F01                  		call	cout
   121 0000D0A0 3C62                    		cmp		al, 'b'
   122 0000D0A2 743A                    		je 		bootRecord
   123 0000D0A4 3C64                    		cmp		al, 'd'
   124 0000D0A6 7503E9AB00              		je 		show_dump
   125 0000D0AB 3C65                    		cmp		al, 'e'
   126 0000D0AD 7503E9AD00              		je		editmemory
   127 0000D0B2 3C66                    		cmp		al, 'f'
   128 0000D0B4 7467                    		je		fillMemory
   129 0000D0B6 3C6C                    		cmp		al, 'l'
   130 0000D0B8 746C                    		je		ldIntelHex
   131 0000D0BA 3C68                    		cmp		al, 'h'
   132 0000D0BC 7503E9BA00              		je 		show_help_msg
   133 0000D0C1 3C73                    		cmp		al, 's'
   134 0000D0C3 7421                    		je 		readSector1
   135 0000D0C5 3C74                    		cmp		al, 't'
   136 0000D0C7 7503E99C00              		je 		show_systic
   137 0000D0CC 3C70                    		cmp		al, 'p'
   138 0000D0CE 747A                    		je 		show_reg
   139                                  
   140                                  
   141 0000D0D0 3C77                    		cmp		al, 'w'
   142 0000D0D2 745B                    		je 		writePeripherals
   143 0000D0D4 3C6F                    		cmp		al, 'o'
   144 0000D0D6 7460                    		je 		outByte
   145 0000D0D8 3C69                    		cmp		al, 'i'
   146 0000D0DA 7465                    		je 		inByte
   147                                  
   148                                  
   149                                  		;CALL	newLine
   150 0000D0DC EBB9                    		jmp 	Mainloop	
   151                                  bootRecord:
   152 0000D0DE E8A309                  		call LOAD_BOOT_RECORD		
   153 0000D0E1 E80401                  		call	newLine
   154 0000D0E4 EBB1                    		jmp 	Mainloop	
   155                                  readSector1:		
   156 0000D0E6 B8C007                  	MOV AX, 0X07C0 	;0X07C0:0X0000
   157 0000D0E9 8EC0                    	MOV ES, AX		;ES:BX = ADDRESS BUFFER
   158 0000D0EB B80102                  	MOV AX, 0X0201	;READ ONE SECTOR
   159 0000D0EE BB0000                  	MOV BX, 0X0000	;ES:BX = ADDRESS BUFFER
   160 0000D0F1 B90100                  	MOV CX, 0X0001	;1 SECTOR
   161 0000D0F4 BA8100                  	MOV DX, 0X0081	;DRIVE TO BOOT UP 0=A, 80=C
   162                                  
   163 0000D0F7 E80F12                  		call	printPrompt
   164 0000D0FA E86001                  		call	cin_blct
   165 0000D0FD E83F01                  		call	cout
   166 0000D100 E85D10                  		call 	to_hex
   167 0000D103 88C1                    		mov		cl, al
   168 0000D105 B8C007                  	MOV AX, 0X07C0 	;0X07C0:0X0000
   169 0000D108 8EC0                    	MOV ES, AX		;ES:BX = ADDRESS BUFFER
   170 0000D10A B80102                  	MOV AX, 0X0201	;READ ONE SECTOR
   171 0000D10D BB0000                  	MOV BX, 0X0000	;ES:BX = ADDRESS BUFFER
   172 0000D110 B500                    	MOV CH, 0X00	;
   173 0000D112 BA8100                  	MOV DX, 0X0081	;DRIVE TO BOOT UP 0=A, 80=C
   174                                  		
   175                                  		
   176 0000D115 CD13                    	INT 0X13		;INT 13
   177 0000D117 E8CE00                  		call	newLine
   178 0000D11A E97AFF                  		jmp 	Mainloop	
   179                                  fillMemory:		
   180 0000D11D E87314                  		call 	fill_memory
   181 0000D120 E8C500                  		call	newLine
   182 0000D123 E971FF                  		jmp 	Mainloop	
   183                                  ldIntelHex:		
   184 0000D126 E86512                  		call 	load_intel_hex
   185 0000D129 E8BC00                  		call	newLine
   186 0000D12C E968FF                  		jmp 	Mainloop	
   187                                  writePeripherals:
   188 0000D12F E8B113                  		call 	write_peripherals
   189 0000D132 E8B300                  		call	newLine
   190 0000D135 E95FFF                  		jmp 	Mainloop	
   191                                  outByte:
   192 0000D138 E8C713                  		call 	outbyte
   193 0000D13B E8AA00                  		call	newLine
   194 0000D13E E956FF                  		jmp 	Mainloop	
   195                                  inByte:		
   196 0000D141 E8E613                  		call	inbyte
   197 0000D144 E8A100                  		call	newLine
   198 0000D147 E94DFF                  		jmp 	Mainloop	
   199                                  show_reg:
   200 0000D14A B83412                  		mov	AX, 0x1234
   201 0000D14D E82E0F                  		call	print_hex
   202 0000D150 E89500                  		call	newLine
   203 0000D153 E941FF                  		jmp 	Mainloop		
   204                                  show_dump:
   205 0000D156 E83311                  		call	dump
   206 0000D159 E88C00                  		call	newLine
   207 0000D15C E938FF                  		jmp 	Mainloop	
   208                                  editmemory:			
   209 0000D15F E8DA11                  		call	edit_memory
   210 0000D162 E88300                  		call	newLine
   211 0000D165 E92FFF                  		jmp 	Mainloop	
   212                                  show_systic:
   213 0000D168 E85A10                  		call    get_sys_ticks
   214 0000D16B 50                      		push	AX
   215 0000D16C 89D0                    		mov		AX, DX
   216 0000D16E E80D0F                  		call	print_hex
   217 0000D171 58                      		pop		AX
   218 0000D172 E8090F                  		call	print_hex
   219 0000D175 E87000                  		call	newLine
   220 0000D178 E91CFF                  		jmp 	Mainloop		
   221                                  show_help_msg:
   222 0000D17B BE[D500]                		mov		si, help_msg
   223 0000D17E E89D00                  		call 	pstr
   224 0000D181 E913FF                  		jmp 	Mainloop
   225                                  
   226                                  
   227                                  %include "DRV16C550.asm"
     1                              <1>         CPU 8086
     2                              <1>    
     3                              <1> 
     4                              <1> ; Port
     5 0000D184 F803                <1> COM1:	DW		0x3F8
     6                              <1> ; Here are the port numbers for various UART registers:
     7                              <1> uart_tx_rx 		EQU  0x3f8 ; 0 DLAB = 0 for Regs. TX and RX
     8                              <1> uart_DLL 		EQU  0x3f8 ; 0 DLAB = 1 Divisor lacth low
     9                              <1> uart_IER 		EQU  0x3f9 ; 1 DLAB = 0 Interrupt Enable Register
    10                              <1> uart_DLH 		EQU  0x3f9 ; 1 DLAB = 1 Divisor lacth high
    11                              <1> uart_ISR 		EQU  0x3fa ; 2 IIR Interrupt Ident. Register READ ONLY
    12                              <1> uart_FCR 		EQU  0x3fa ; 2 Fifo Control Resgister WRITE ONLY
    13                              <1> uart_LCR 		EQU  0x3fb ; 3 Line Control Register
    14                              <1> uart_MCR 		EQU  0x3fc ; 4 Modem Control Register
    15                              <1> uart_LSR 		EQU  0x3fd ; 5 Line Status Register
    16                              <1> uart_MSR 		EQU  0x3fe ; 6 Modem Status Register
    17                              <1> uart_scratch 	EQU  0x3ff ; 7 SCR Scratch Register
    18                              <1> 
    19                              <1> UART_FREQUENCY		equ 4915000
    20                              <1> ;Fomula UART_FREQUENCY/(  9600 * 16)
    21                              <1> ;Baudrates
    22                              <1> UART_BAUD_9600		EQU 32
    23                              <1> UART_BAUD_19200		EQU 16
    24                              <1> UART_BAUD_38400		EQU  8
    25                              <1> UART_BAUD_56800		EQU  5
    26                              <1> UART_BAUD_115200	EQU  3
    27                              <1> UART_BAUD_230400	EQU  1
    28                              <1> 
    29                              <1> UART_TX_WAIT		EQU	0x7fff		; Count before a TX times out
    30                              <1> 
    31 0000D186 53657269616C206472- <1> msg0_01:   db "Serial driver for 16C550",0
    31 0000D18F 6976657220666F7220- <1>
    31 0000D198 31364335353000      <1>
    32                              <1> ;configure_uart
    33                              <1> ;Parameters:None
    34                              <1> ;			
    35                              <1> ;			
    36                              <1> configure_uart:
    37 0000D19F B9FF1F              <1> 			mov cx, 0x1fff
    38 0000D1A2 E85000              <1> 			call	basicDelay
    39 0000D1A5 B000                <1> 			MOV		AL,0x0	 		;
    40 0000D1A7 BAF903              <1> 			MOV		DX, uart_IER
    41 0000D1AA EE                  <1> 			OUT  	DX,	AL	; Disable interrupts
    42                              <1> 
    43 0000D1AB B91F00              <1> 			mov cx, 0x1f
    44 0000D1AE E84400              <1> 			call	basicDelay
    45                              <1> 
    46 0000D1B1 B080                <1> 			MOV		AL, 0x80			;
    47 0000D1B3 BAFB03              <1> 			MOV		DX, uart_LCR
    48 0000D1B6 EE                  <1> 			OUT     DX,	AL 	; Turn DLAB on
    49 0000D1B7 B91F00              <1> 			mov cx, 0x1f
    50 0000D1BA E83800              <1> 			call	basicDelay
    51                              <1> 
    52 0000D1BD B008                <1> 			MOV		AL, UART_BAUD_38400 ;0x08
    53 0000D1BF BAF803              <1> 			MOV		DX, uart_DLL
    54 0000D1C2 EE                  <1> 			OUT     DX,   AL	; Set divisor low
    55 0000D1C3 B91F00              <1> 			mov cx, 0x1f
    56 0000D1C6 E82C00              <1> 			call	basicDelay
    57                              <1> 
    58 0000D1C9 B000                <1> 			MOV		AL, 0x00		;
    59 0000D1CB BAF903              <1> 			MOV		DX, uart_DLH
    60 0000D1CE EE                  <1> 			OUT     DX,	AL	; Set divisor high
    61 0000D1CF B91F00              <1> 			mov cx, 0x1f
    62 0000D1D2 E82000              <1> 			call	basicDelay
    63                              <1> 
    64 0000D1D5 B003                <1> 			MOV     AL, 0x03	; AH	
    65 0000D1D7 BAFB03              <1> 			MOV		DX, uart_LCR
    66 0000D1DA EE                  <1> 			OUT     DX,	AL	; Write out flow control bits 8,1,N
    67 0000D1DB B91F00              <1> 			mov cx, 0x1f
    68 0000D1DE E81400              <1> 			call	basicDelay
    69                              <1> 
    70 0000D1E1 B081                <1> 			MOV 	AL,0x81			;
    71 0000D1E3 BAFA03              <1> 			MOV		DX, uart_ISR
    72 0000D1E6 EE                  <1> 			OUT     DX,	AL	; Turn on FIFO, with trigger level of 8.
    73                              <1> 								                ; This turn on the 16bytes buffer!
    74 0000D1E7 C3                  <1> 			RET
    75                              <1> 
    76                              <1> newLine:
    77 0000D1E8 50                  <1> 	push	AX
    78 0000D1E9 B00D                <1> 	mov  al, 0Dh
    79 0000D1EB E85100              <1> 	call cout
    80 0000D1EE B00A                <1> 	mov  al, 0Ah
    81 0000D1F0 E84C00              <1> 	call cout
    82 0000D1F3 58                  <1> 	pop		AX
    83 0000D1F4 C3                  <1> 	ret
    84                              <1> 	
    85                              <1> basicDelay:
    86 0000D1F5 49                  <1>         dec cx
    87 0000D1F6 75FD                <1>         jnz basicDelay
    88 0000D1F8 C3                  <1>         ret
    89                              <1> 
    90                              <1> readLine:
    91 0000D1F9 57                  <1> 		push	DI
    92 0000D1FA 52                  <1> 		push	DX
    93 0000D1FB 51                  <1> 		push	CX
    94 0000D1FC BF0F05              <1>         mov  	DI,  buff_read   
    95 0000D1FF B100                <1> 		mov		cl, 0x0
    96                              <1> .loopP:  ;RX blocante
    97 0000D201 E85900              <1>         call 	cin_blct    
    98                              <1> 		;call	printb_hex   
    99 0000D204 3C08                <1> 		cmp 	al, 0x08
   100 0000D206 7411                <1> 		je 		.loopP1
   101 0000D208 AA                  <1> 		stosb
   102 0000D209 FEC1                <1> 		inc		cl
   103 0000D20B E83100              <1>         call 	cout
   104 0000D20E 3C0D                <1>         CMP  	AL, cr
   105 0000D210 75EF                <1>         JNZ  	.loopP
   106 0000D212 B000                <1> 		mov  	al,0x0
   107 0000D214 AA                  <1> 		stosb
   108 0000D215 59                  <1> 		pop 	CX
   109 0000D216 5A                  <1> 		pop		DX
   110 0000D217 5F                  <1> 		pop 	DI
   111 0000D218 C3                  <1>         ret
   112                              <1> .loopP1:		     
   113                              <1> 		;call	printb_hex   
   114 0000D219 FEC9                <1> 		dec		cl
   115 0000D21B 4F                  <1> 		dec		DI
   116 0000D21C EBE3                <1> 		jmp 	.loopP
   117                              <1> 
   118                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   119                              <1> ;Mais funções
   120                              <1> ; send string to terminal
   121                              <1> ; entry: si
   122                              <1> 
   123                              <1> eos	equ 0
   124                              <1> cr	equ 13
   125                              <1> lf	equ 10
   126                              <1> 
   127                              <1> pstr:   
   128 0000D21E 2E8A04              <1> 		mov al,cs:[si]
   129 0000D221 3C00                <1> 		cmp al,eos
   130 0000D223 7501                <1> 		jnz pstr1
   131 0000D225 C3                  <1> 		ret
   132                              <1> pstr1:
   133 0000D226 E81600              <1> 		call cout
   134 0000D229 46                  <1> 		inc si
   135 0000D22A EBF2                <1> 		jmp pstr
   136                              <1> 
   137                              <1> pstr_sram:
   138 0000D22C B80000              <1> 		mov ax, 0x0
   139 0000D22F 8EC0                <1>         mov ES, AX 
   140 0000D231 268A04              <1> 		mov al,es:[si]
   141 0000D234 3C00                <1> 		cmp al,eos
   142 0000D236 7501                <1> 		jnz .pstr1
   143 0000D238 C3                  <1> 		ret
   144                              <1> .pstr1:
   145 0000D239 E80300              <1> 		call cout
   146 0000D23C 46                  <1> 		inc si
   147 0000D23D EBED                <1> 		jmp pstr_sram
   148                              <1> 
   149                              <1> ;=================================================================================
   150                              <1> ;cout
   151                              <1> ; send 8-bit character in al to terminal
   152                              <1> ; entry: al
   153                              <1> cout:
   154 0000D23F 50                  <1> 		push 		ax
   155 0000D240 BAFD03              <1> 		mov 		dx,	uart_LSR
   156                              <1> cout1:	
   157 0000D243 EC                  <1> 		in  al,		dx
   158 0000D244 2460                <1> 		and al, 	0x60	; Check for TX empty
   159 0000D246 74FB                <1> 		jz 	cout1			; wait until TXE = 1
   160 0000D248 58                  <1> 		pop ax
   161 0000D249 BAF803              <1> 		mov dx,		uart_tx_rx
   162 0000D24C EE                  <1> 		out dx,		al
   163 0000D24D C3                  <1> 		ret
   164                              <1> ;=================================================================================
   165                              <1> ;cin:
   166                              <1> ;Parameters: 
   167                              <1> ;			AL = return the available character
   168                              <1> ;			If al returns with a valid char flag carry is set, otherwise
   169                              <1> ;			flag carry is clear
   170                              <1> cin:	
   171 0000D24E BAFD03              <1> 			MOV DX, uart_LSR
   172 0000D251 EC                  <1> 			IN	AL, DX	 		; Get the line status register
   173 0000D252 2401                <1> 			AND AL, 0x01		; Check for characters in buffer
   174 0000D254 F8                  <1> 			CLC 				; Clear carry
   175 0000D255 7405                <1> 			JZ	.end			; Just ret (with carry clear) if no characters
   176 0000D257 BAF803              <1> 			MOV DX, uart_tx_rx
   177 0000D25A EC                  <1> 			IN	AL, DX			; Read the character from the UART receive buffer
   178 0000D25B F9                  <1> 			STC 				; Set the carry flag
   179                              <1> .end:			
   180 0000D25C C3                  <1> 			RET
   181                              <1> 
   182                              <1> cin_blct:	
   183 0000D25D BAFD03              <1> 			MOV DX, uart_LSR
   184 0000D260 EC                  <1> 			IN	AL, DX	 		; Get the line status register
   185 0000D261 2401                <1> 			AND AL, 0x01		; Check for characters in buffer
   186 0000D263 74F8                <1> 			JZ	cin_blct		; Just loopif no characters
   187 0000D265 BAF803              <1> 			MOV DX, uart_tx_rx
   188 0000D268 EC                  <1> 			IN	AL, DX			; Read the character from the UART receive buffer
   189 0000D269 C3                  <1> 			RET
   190                              <1> 
   191                              <1> space:  
   192 0000D26A B020                <1> 			mov al," "
   193 0000D26C E8D0FF              <1> 	    	call cout
   194 0000D26F C3                  <1> 	    	ret
   195                              <1> 
   196                              <1> get_hex: 
   197 0000D270 E8DBFF              <1> 		call cin
   198 0000D273 E8EA0E              <1> 		call to_hex
   199 0000D276 D0C0                <1> 		rol al,1
   200 0000D278 D0C0                <1> 		rol al,1
   201 0000D27A D0C0                <1> 		rol al,1
   202 0000D27C D0C0                <1> 		rol al,1
   203 0000D27E 88C4                <1> 		mov ah,al
   204 0000D280 E8CBFF              <1> 		call cin
   205 0000D283 E8DA0E              <1> 		call to_hex
   206 0000D286 00E0                <1> 		add al, ah
   207 0000D288 C3                  <1> 		ret			
   228                                  %include "DRVCH376S.asm"
     1                              <1> 
     2                              <1> 
     3                              <1> 
     4                              <1> INITIALIZE_CH376S_0XE0_00:
     5 0000D289 B005                <1> 	MOV AL, 0X05 		;COMMAND RESET
     6 0000D28B E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
     7                              <1> 	
     8 0000D28D E80321              <1> 	CALL WAIT_32
     9                              <1>   	
    10 0000D290 B015                <1> 	MOV AL, 0X15 		;SET_USB_MODE
    11 0000D292 E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
    12 0000D294 B006                <1> 	MOV AL, 0X06		;MODE 0X06
    13 0000D296 E6E0                <1> 	OUT 0XE0, AL		;OUT DATA PORT
    14 0000D298 E8E920              <1> 	CALL WAIT_16		;DELAY TO GIVE IT TIME
    15 0000D29B B031                <1> 	MOV AL, 0X31		;DISK_MOUNT
    16 0000D29D E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
    17 0000D29F E8E220              <1> 	CALL WAIT_16		;DELAY TO GIVE IT TIME
    18                              <1> 
    19                              <1> 	;CALL LOAD_BOOT_RECORD		;LOADS MBR CHECKS FOR BOOTABLE
    20                              <1>                                 ;THEN LOADS VOLUME BOOT RECORD CHECKS FOR BOOTABLE
    21                              <1> 				                ;DISK GEOMETRY IS USED IN OTHER 0X13 OPERATIONS
    22                              <1> 		
    23 0000D2A2 E8DF20              <1> 	CALL WAIT_16		;DELAY TO GIVE IT TIME
    24 0000D2A5 B8410E              <1> 	MOV AX, 0X0E41
    25 0000D2A8 C3                  <1> 	RET			        ;RETURN
    26                              <1> 
    27                              <1> 
    28                              <1> ; Conservatively assume the 504M limit
    29                              <1> ; It may be possible to use MAX_HPC of 256 and get an 8Gb limit, but it's likely this will
    30                              <1> ; require device repartition/reformat if it was set up with a 504M geometry.
    31                              <1> 
    32                              <1> MAX_SPT equ 63
    33                              <1> MAX_HPC equ 16
    34                              <1> MAX_CYL equ 1024
    35                              <1> 
    36                              <1> ; Set to 1 if you want the CH376S errors dumped to the screen.
    37                              <1> %define DISPLAY_CH376S_ERRORS 0
    38                              <1> 
    39                              <1> ; Define the port numbers for easier swap if it ever supports the CH376S loaded elsewhere (i. e. two units)
    40                              <1> COMMAND_PORT equ 0xE4
    41                              <1> DATA_PORT equ 0xE0
    42                              <1> 
    43                              <1> ; And ROM sector if we want to load it higher.  Right now, it fits into a 4k box so it can theoretically go as high
    44                              <1> ; as 0xFD000 and still clear the main BIOS at 0xFE00
    45                              <1> 
    46                              <1> ROM_SECTOR equ 0xF000
    47                              <1> 
    48                              <1> ; Define CH376S commands by name for improved legibility
    49                              <1> CH376S_GET_IC_VER equ		0x01
    50                              <1> CH376S_RESET_ALL equ 		0x05
    51                              <1> CH376S_CHECK_EXIST equ 		0x06
    52                              <1> CH376S_SET_USB_MODE equ 	0x15
    53                              <1> CH376S_GET_STATUS equ 		0x22
    54                              <1> CH376S_RD_USB_DATA0 equ		0x27
    55                              <1> CH376S_WR_USB_DATA	equ		0x2C
    56                              <1> CH376S_WR_REQ_DATA	equ		0x2D
    57                              <1> CH376S_DISK_CONNECT equ		0x30
    58                              <1> CH376S_DISK_MOUNT equ		0x31
    59                              <1> CH376S_DISK_CAPACITY equ	0x3E
    60                              <1> CH376S_DISK_READ equ		0x54
    61                              <1> CH376S_DISK_RD_GO equ		0x55
    62                              <1> CH376S_DISK_WRITE equ		0x56
    63                              <1> CH376S_DISK_WR_GO equ		0x57
    64                              <1> 
    65                              <1> 
    66                              <1> CH376S_USB_INT_SUCCESS equ  	0x14
    67                              <1> CH376S_USB_INT_DISCONNECT equ	0x16
    68                              <1> CH376S_USB_INT_BUF_OVER equ		0x17
    69                              <1> CH376S_USB_INT_DISK_READ equ	0x1D
    70                              <1> CH376S_USB_INT_DISK_WRITE equ	0x1E
    71                              <1> CH376S_USB_INT_DISK_ERR equ 	0x1F
    72                              <1> 
    73                              <1> CH376S_CMD_RET_SUCCESS equ  	0x51
    74                              <1> 
    75                              <1> 
    76                              <1> ;Header so it's recognized as an option card
    77                              <1> 
    78 0000D2A9 55                  <1> DB 0x55
    79 0000D2AA AA                  <1> DB 0xAA
    80                              <1> 
    81                              <1> ; Uses 8 512-byte pages.  Expand if this grows over 4kb.
    82 0000D2AB 08                  <1> DB 0x08
    83                              <1> 
    84                              <1> ; Code starts here.  Save everything before we start.
    85                              <1> 
    86                              <1> INITIALIZE_CH376S_0XE0:
    87                              <1> 
    88 0000D2AC 9C                  <1> PUSHF
    89 0000D2AD 50                  <1> PUSH AX
    90 0000D2AE 53                  <1> PUSH BX
    91 0000D2AF 51                  <1> PUSH CX
    92 0000D2B0 52                  <1> PUSH DX
    93                              <1> 
    94 0000D2B1 B95200              <1> 	MOV CX, END_CHECKPOINT_1 - CHECKPOINT_1
    95 0000D2B4 BB[19D5]            <1>     MOV BX, CHECKPOINT_1
    96 0000D2B7 E80003              <1>     CALL WRITE_MESSAGE;
    97                              <1> 
    98 0000D2BA BAC800              <1> 	MOV DX, 200			; Try to reset the thing 200 times
    99                              <1> TRY_RESET:
   100 0000D2BD B005                <1> 	MOV AL, CH376S_RESET_ALL 		;COMMAND RESET
   101 0000D2BF E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   102                              <1> 									; It seems like using a longer delay like WAIT_16 is
   103                              <1> 									; actually less reliable for some reason than
   104                              <1> 									; this small delay
   105 0000D2C1 E8A420              <1> 	CALL WAIT_2
   106 0000D2C4 E4E0                <1> 	IN AL, DATA_PORT				; Docs say this should be 00 after reset.
   107 0000D2C6 B006                <1> 	MOV AL, CH376S_CHECK_EXIST
   108 0000D2C8 E6E4                <1> 	OUT COMMAND_PORT, AL
   109 0000D2CA B057                <1> 	MOV AL, 0X57					; Existence check:  Send 0x57, expect 0xA8 back
   110 0000D2CC E6E0                <1> 	OUT DATA_PORT, AL
   111 0000D2CE E4E0                <1> 	IN AL, DATA_PORT
   112 0000D2D0 3CA8                <1> 	CMP AL, 0xA8
   113 0000D2D2 7410                <1> 	JE CH376S_EXISTS
   114 0000D2D4 4A                  <1> 	DEC DX
   115 0000D2D5 83FA00              <1> 	CMP DX, 0
   116 0000D2D8 7503E96801          <1> 	JE CH376S_EXIST_FAILED
   117 0000D2DD B82E0E              <1> 	MOV AX, 0x0E2E		; Add a period for the display
   118 0000D2E0 CD10                <1> 	INT 0x10
   119 0000D2E2 EBD9                <1> 	JMP TRY_RESET
   120                              <1> 
   121                              <1> CH376S_EXISTS:
   122 0000D2E4 B91600              <1> 	mov cx, END_MODE_SET_TEXT - MODE_SET_TEXT
   123 0000D2E7 BB[6BD5]            <1>     mov BX, MODE_SET_TEXT
   124 0000D2EA E8CD02              <1>     call WRITE_MESSAGE;
   125                              <1> 
   126 0000D2ED BA1400              <1> 	MOV DX, 0020
   127                              <1> CH376S_MODE_SET:
   128                              <1> 	;Set the mode to 0x07 first (valid USB host/reset USB)
   129                              <1> 	;then to 0x06 (valid USB host, auto generate SOF packet)
   130                              <1> 
   131 0000D2F0 B015                <1>     MOV AL, CH376S_SET_USB_MODE 	; SET_USB_MODE
   132 0000D2F2 E6E4                <1> 	OUT COMMAND_PORT, AL			; OUT COMMAND PORT
   133 0000D2F4 B007                <1>     MOV AL, 0X07					; MODE 0X07
   134 0000D2F6 E6E0                <1> 	OUT DATA_PORT, AL				; OUT DATA PORT
   135 0000D2F8 E87A20              <1> 	CALL WAIT_8						; DELAY TO GIVE IT TIME
   136                              <1> 	
   137 0000D2FB B015                <1>     MOV AL, CH376S_SET_USB_MODE		; SET_USB_MODE
   138 0000D2FD E6E4                <1> 	OUT COMMAND_PORT, AL			; OUT COMMAND PORT
   139 0000D2FF B006                <1>     MOV AL, 0X06					; MODE 0X06
   140 0000D301 E6E0                <1> 	OUT DATA_PORT, AL				; OUT DATA PORT
   141 0000D303 E86F20              <1> 	CALL WAIT_8						; DELAY TO GIVE IT TIME
   142                              <1> 
   143 0000D306 E4E0                <1> 	IN AL, DATA_PORT
   144 0000D308 3C51                <1> 	CMP AL, CH376S_CMD_RET_SUCCESS	; Once we have success, move on
   145 0000D30A 7410                <1> 	JE CH376S_RIGHT_MODE
   146 0000D30C 4A                  <1> 	DEC DX
   147 0000D30D 83FA00              <1> 	CMP DX, 0
   148 0000D310 7503E93B01          <1> 	JE CH376S_WRONG_MODE
   149 0000D315 B82E0E              <1> 	MOV AX, 0x0E2E					; Add a period for the display
   150 0000D318 CD10                <1> 	INT 0x10
   151 0000D31A EBD4                <1> 	JMP CH376S_MODE_SET
   152                              <1> 
   153                              <1> CH376S_RIGHT_MODE:
   154                              <1> 	; DEBUG - print IC version
   155 0000D31C B91000              <1>     MOV CX, END_REVINFO - REVINFO
   156 0000D31F BB[81D5]            <1>     MOV BX, REVINFO
   157 0000D322 E89502              <1>     CALL WRITE_MESSAGE;
   158                              <1> 
   159 0000D325 B001                <1>     MOV AL, CH376S_GET_IC_VER	;GET IC Version
   160 0000D327 E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   161 0000D329 E4E0                <1> 	IN AL, DATA_PORT			;READ IN STATUS DATA PORT
   162 0000D32B E8FD1F              <1>     CALL WRITE_AL_INT10_E;
   163                              <1> 
   164                              <1> 	
   165 0000D32E B90000              <1> 	MOV CX, 0
   166                              <1> TRY_CONNECT:
   167                              <1> 	; Some comments suggested doing DISK_CONNECT then DISK_MOUNT
   168 0000D331 83F90A              <1> 	CMP CX, 10
   169 0000D334 7D15                <1> 	JGE TRY_MOUNT ; GIVE UP
   170 0000D336 B030                <1>     MOV AL, CH376S_DISK_CONNECT	;DISK_CONNECT
   171 0000D338 E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   172                              <1> 
   173 0000D33A E8E006              <1> 	CALL AWAIT_INTERRUPT
   174                              <1> 
   175 0000D33D B022                <1> 	MOV AL, CH376S_GET_STATUS		;GET_STATUS AFTER INTERRUPT
   176 0000D33F E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT				
   177 0000D341 E4E0                <1> 	IN AL, DATA_PORT				;READ IN STATUS DATA PORT
   178 0000D343 41                  <1> 	INC CX
   179 0000D344 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS  ;CHECK FOR USB_INT_SUCCESS
   180 0000D346 75E9                <1> 	JNE TRY_CONNECT
   181                              <1> 
   182 0000D348 B90000              <1> 	MOV CX, 0
   183                              <1> TRY_MOUNT:
   184 0000D34B 83F90A              <1> 	CMP CX, 10
   185 0000D34E 7D15                <1> 	JGE MOUNT_FINISHED				;GIVE UP IF WE TRIED 10 TIMES
   186 0000D350 B031                <1>     MOV AL, CH376S_DISK_MOUNT		;DISK_MOUNT
   187 0000D352 E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   188                              <1> 
   189                              <1> AWAIT_MOUNT:
   190 0000D354 E4E4                <1> 	IN AL, COMMAND_PORT				; Loop waiting for the interrupt
   191 0000D356 2480                <1> 	AND AL, 0x80
   192 0000D358 75FA                <1> 	JNZ AWAIT_MOUNT
   193 0000D35A B022                <1> 	MOV AL, CH376S_GET_STATUS		;GET_STATUS AFTER INTERRUPT
   194 0000D35C E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT				
   195 0000D35E E4E0                <1> 	IN AL, DATA_PORT				;READ IN STATUS DATA PORT
   196 0000D360 41                  <1> 	INC CX
   197 0000D361 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS	;CHECK FOR USB_INT_SUCCESS
   198 0000D363 75E6                <1> 	JNE TRY_MOUNT
   199                              <1> 
   200                              <1> MOUNT_FINISHED:
   201                              <1> 	; After the mount operation, the data port is stuffed with the device name.  
   202                              <1> 	; Let's show it so we have proof we're talking to the right drive
   203 0000D365 B027                <1>     MOV AL, CH376S_RD_USB_DATA0		; Read device data
   204 0000D367 E6E4                <1>     OUT COMMAND_PORT, AL
   205 0000D369 E4E0                <1>     IN AL, DATA_PORT				; READ IN STATUS DATA PORT
   206 0000D36B 88C3                <1>     MOV BL, AL						; The first byte is length of the name
   207                              <1> 
   208 0000D36D 3C00                <1> 	CMP AL, 0
   209 0000D36F 7503E9C600          <1> 	JE NO_DISC_FOUND
   210 0000D374 3CE8                <1> 	CMP AL, 0xE8 					; When it doesn't wake up right,
   211 0000D376 7503E9BF00          <1> 	JE NO_DISC_FOUND				; it often returns E8 constantly
   212                              <1> 
   213                              <1> 	
   214                              <1> 	; Print the "Device ID" string
   215 0000D37B 53                  <1> 	PUSH BX
   216 0000D37C B90E00              <1>     MOV CX, END_DEVINFO - DEVINFO
   217 0000D37F BB[91D5]            <1> 	MOV BX, DEVINFO
   218 0000D382 E83502              <1>     call WRITE_MESSAGE;			
   219 0000D385 5B                  <1> 	POP BX
   220                              <1> 	
   221 0000D386 80EB08              <1> 	SUB BL, 8			; The first 8 characters of the response struct
   222 0000D389 B90800              <1> 	MOV CX, 8			; are not human readable.  Skip to vendor/product/Revision
   223                              <1> SKIP_HEADER:			
   224 0000D38C E4E0                <1> 	IN AL, DATA_PORT
   225 0000D38E E2FC                <1> 	LOOP SKIP_HEADER
   226                              <1> 
   227 0000D390 B40E                <1>     MOV AH, 0x0E		; INT 0x10 operation for writing character
   228                              <1> NEXT_ID_CHAR:
   229 0000D392 80FB00              <1>     CMP BL, 0
   230 0000D395 7408                <1>     JE AFTER_IDENT
   231 0000D397 E4E0                <1>     IN AL, DATA_PORT	;Read and print BL-count characters
   232 0000D399 CD10                <1>     INT 0x10
   233 0000D39B FECB                <1>     DEC BL
   234 0000D39D EBF3                <1>     JMP NEXT_ID_CHAR
   235                              <1>     AFTER_IDENT:
   236                              <1> 
   237 0000D39F B8200E              <1> 	MOV AX, 0x0E20		; Write space
   238 0000D3A2 CD10                <1> 	INT 0x10
   239 0000D3A4 B03A                <1> 	MOV AL, 0x3A		; Write colon
   240 0000D3A6 CD10                <1> 	INT 0x10
   241 0000D3A8 B020                <1> 	MOV AL, 0x20		; Write space
   242 0000D3AA CD10                <1> 	INT 0x10
   243                              <1> 
   244 0000D3AC E8A506              <1>  	CALL GET_CAPACITY
   245                              <1> 
   246                              <1> 
   247 0000D3AF E85805              <1> 	CALL WRITE_SECTORS_IN_MB		; Display size on screen
   248                              <1> 
   249                              <1> 	; Check if we're above the maximum size for the BIOS
   250 0000D3B2 83FA0F              <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   251 0000D3B5 7C13                <1> 	JL BELOW_SIZE
   252 0000D3B7 83FA0F              <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   253 0000D3BA 7F05                <1> 	JG ABOVE_SIZE
   254 0000D3BC 3D00C0              <1> 	CMP AX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   255 0000D3BF 7E09                <1> 	JLE BELOW_SIZE
   256                              <1> 
   257                              <1> ABOVE_SIZE:
   258 0000D3C1 B94A00              <1> 	MOV CX, END_OVERSIZE_MESSAGE - OVERSIZE_MESSAGE
   259 0000D3C4 BB[8AD9]            <1>     MOV BX, OVERSIZE_MESSAGE
   260 0000D3C7 E8F001              <1>     CALL WRITE_MESSAGE;
   261                              <1> 
   262                              <1> BELOW_SIZE:
   263                              <1> 	; If we have a device that's smaller than the dimensions in the disk table
   264                              <1> 	; we should warn the user to update the table.
   265                              <1> 	; or some detection software may assume the wrong dimensions.
   266 0000D3CA B9F003              <1> 	MOV CX, (MAX_SPT * MAX_HPC)
   267 0000D3CD F7F1                <1> 	DIV CX
   268 0000D3CF 2E3B06[7DDC]        <1> 	CMP AX, [CS:DISK_1_TABLE]
   269 0000D3D4 7D13                <1> 	JGE BELOW_TABLE_SIZE
   270                              <1> 
   271 0000D3D6 B94900              <1> 	MOV CX, END_BELOW_TABLE_SIZE_MESSAGE - BELOW_TABLE_SIZE_MESSAGE
   272 0000D3D9 BB[D4D9]            <1>     MOV BX, BELOW_TABLE_SIZE_MESSAGE
   273 0000D3DC E8DB01              <1> 	CALL WRITE_MESSAGE
   274                              <1> 
   275 0000D3DF 50                  <1> 	PUSH AX
   276 0000D3E0 88E0                <1> 	MOV AL, AH
   277 0000D3E2 E8461F              <1> 	CALL WRITE_AL_INT10_E
   278 0000D3E5 58                  <1> 	POP AX
   279 0000D3E6 E8421F              <1> 	CALL WRITE_AL_INT10_E
   280                              <1> 
   281                              <1> BELOW_TABLE_SIZE:
   282                              <1> 
   283                              <1> 	; Beginning the final initialization steps.  Start with a message...
   284                              <1> 
   285 0000D3E9 B91B00              <1>     MOV CX, END_RETURNING_TEXT - RETURNING_TEXT
   286 0000D3EC BB[9FD5]            <1>     MOV BX, RETURNING_TEXT
   287 0000D3EF E8C801              <1>     CALL WRITE_MESSAGE;
   288                              <1>     
   289                              <1> 
   290                              <1> 	; Set the interrupt vector at 0x004C to point to the INT13 code below.
   291 0000D3F2 1E                  <1>     PUSH DS
   292 0000D3F3 50                  <1>     PUSH AX	
   293 0000D3F4 31C0                <1> 	XOR AX, AX
   294 0000D3F6 8ED8                <1>     MOV DS, AX
   295                              <1> 	; Vector migration logic based on examples at https://www.bttr-software.de/forum/board_entry.php?id=11433
   296                              <1> 	; Save old vector to INT 0x40 - this is reported as where old BIOSes really moved INT 0x13 to.
   297 0000D3F8 3EA14C00            <1> 	MOV AX, DS:0x004C
   298 0000D3FC 3EA30001            <1> 	MOV DS:0x0100, AX
   299 0000D400 3EA14E00            <1> 	MOV AX, DS:0x004E
   300 0000D404 3EA30201            <1> 	MOV DS:0x0102, AX
   301                              <1> 	
   302                              <1> 	; write our new vector into place
   303 0000D408 3EC7064C00[CBD5]    <1>     MOV WORD DS:0x004C, INT13
   304 0000D40F 3EC7064E0000F0      <1>     MOV WORD DS:0x004E, ROM_SECTOR
   305                              <1> 
   306                              <1> 	; write the drive data table to INT 0x41 and 0x46
   307 0000D416 3EC7060401[7DDC]    <1> 	MOV WORD DS:0x0104, DISK_1_TABLE
   308 0000D41D 3EC706060100F0      <1> 	MOV WORD DS:0x0106, ROM_SECTOR
   309 0000D424 3EC7061801[8DDC]    <1> 	MOV WORD DS:0x0118, DISK_2_TABLE
   310 0000D42B 3EC706200100F0      <1> 	MOV WORD DS:0x0120, ROM_SECTOR
   311 0000D432 58                  <1> 	POP AX
   312 0000D433 1F                  <1>     POP DS
   313                              <1> 
   314                              <1> END_STARTUP:
   315 0000D434 5A                  <1>     POP DX
   316 0000D435 59                  <1>     POP CX
   317 0000D436 5B                  <1>     POP BX
   318 0000D437 58                  <1>     POP AX
   319 0000D438 9D                  <1>     POPF
   320                              <1> 	;RETF			;RETURN
   321 0000D439 C3                  <1>     RET
   322                              <1> 
   323                              <1> NO_DISC_FOUND:
   324 0000D43A B93400              <1> 	MOV CX, END_NO_DISC_MSG - NO_DISC_MSG
   325 0000D43D BB[61D4]            <1>     MOV BX, NO_DISC_MSG
   326 0000D440 E87701              <1>     CALL WRITE_MESSAGE
   327 0000D443 EBEF                <1> 	JMP END_STARTUP
   328                              <1> 
   329                              <1> CH376S_EXIST_FAILED:
   330 0000D445 B94A00              <1> 	MOV CX, END_NO_CH376S_MSG - NO_CH376S_MSG
   331 0000D448 BB[95D4]            <1>     MOV BX, NO_CH376S_MSG
   332 0000D44B E86C01              <1>     CALL WRITE_MESSAGE
   333 0000D44E EBE4                <1> 	JMP END_STARTUP
   334                              <1> 
   335                              <1> CH376S_WRONG_MODE:
   336 0000D450 E82506              <1> 	CALL END_OF_LINE
   337 0000D453 E8D51E              <1> 	CALL WRITE_AL_INT10_E ; Display actual responde code
   338 0000D456 B93A00              <1> 	MOV CX, END_WRONG_MODE_MSG - WRONG_MODE_MSG
   339 0000D459 BB[DFD4]            <1>     MOV BX, WRONG_MODE_MSG
   340 0000D45C E85B01              <1>     CALL WRITE_MESSAGE
   341 0000D45F EBD3                <1> 	JMP END_STARTUP
   342                              <1> 
   343                              <1> NO_DISC_MSG:
   344 0000D461 0D0A4E6F2064726976- <1> 	DB 0x0D, 0x0A, 'No drive reported by module.  Skipping install.', 0x0D, 0x0A ,0
   344 0000D46A 65207265706F727465- <1>
   344 0000D473 64206279206D6F6475- <1>
   344 0000D47C 6C652E2020536B6970- <1>
   344 0000D485 70696E6720696E7374- <1>
   344 0000D48E 616C6C2E0D0A00      <1>
   345                              <1> END_NO_DISC_MSG:
   346                              <1> 
   347                              <1> NO_CH376S_MSG:
   348 0000D495 0D0A43483337365320- <1> 	DB 0x0D, 0x0A, 'CH376S Module does not respond to existence check.  Skipping install.', 0x0D, 0x0A,0
   348 0000D49E 4D6F64756C6520646F- <1>
   348 0000D4A7 6573206E6F74207265- <1>
   348 0000D4B0 73706F6E6420746F20- <1>
   348 0000D4B9 6578697374656E6365- <1>
   348 0000D4C2 20636865636B2E2020- <1>
   348 0000D4CB 536B697070696E6720- <1>
   348 0000D4D4 696E7374616C6C2E0D- <1>
   348 0000D4DD 0A00                <1>
   349                              <1> END_NO_CH376S_MSG:
   350                              <1> 
   351                              <1> WRONG_MODE_MSG:
   352 0000D4DF 202D20434833373653- <1> 	DB ' - CH376S failed switching USB mode.  Skipping Install.', 0x0D, 0x0A,0
   352 0000D4E8 206661696C65642073- <1>
   352 0000D4F1 7769746368696E6720- <1>
   352 0000D4FA 555342206D6F64652E- <1>
   352 0000D503 2020536B697070696E- <1>
   352 0000D50C 6720496E7374616C6C- <1>
   352 0000D515 2E0D0A00            <1>
   353                              <1> END_WRONG_MODE_MSG:
   354                              <1> 
   355                              <1> CHECKPOINT_1:
   356 0000D519 5374616E64616C6F6E- <1>     DB 'Standalone CH376S Firmware v0.50 (8086 version) - 2021-11-20', 0x0D, 0x0A, 'Resetting Module...',0
   356 0000D522 652043483337365320- <1>
   356 0000D52B 4669726D7761726520- <1>
   356 0000D534 76302E353020283830- <1>
   356 0000D53D 38362076657273696F- <1>
   356 0000D546 6E29202D2032303231- <1>
   356 0000D54F 2D31312D32300D0A52- <1>
   356 0000D558 6573657474696E6720- <1>
   356 0000D561 4D6F64756C652E2E2E- <1>
   356 0000D56A 00                  <1>
   357                              <1> END_CHECKPOINT_1:
   358                              <1> 
   359                              <1> MODE_SET_TEXT:
   360 0000D56B 0D0A53657474696E67- <1>     DB 0x0D, 0x0A, 'Setting USB mode...',0
   360 0000D574 20555342206D6F6465- <1>
   360 0000D57D 2E2E2E00            <1>
   361                              <1> END_MODE_SET_TEXT:
   362                              <1> 
   363                              <1> REVINFO:
   364 0000D581 0D0A49432052657669- <1> 	DB 0x0D, 0x0A, 'IC Revision: ',0
   364 0000D58A 73696F6E3A2000      <1>
   365                              <1> END_REVINFO:
   366                              <1> 
   367                              <1> DEVINFO:
   368 0000D591 0D0A44657669636520- <1> 	DB 0x0D, 0x0A, 'Device ID: ',0
   368 0000D59A 49443A2000          <1>
   369                              <1> END_DEVINFO:
   370                              <1> 
   371                              <1> RETURNING_TEXT:
   372 0000D59F 0D0A52657475726E69- <1>     DB 0x0D, 0x0A, 'Returning to Main Exec', 0x0D, 0x0A,0
   372 0000D5A8 6E6720746F204D6169- <1>
   372 0000D5B1 6E20457865630D0A00  <1>
   373                              <1> END_RETURNING_TEXT:
   374                              <1> 
   375                              <1> 
   376                              <1> WRITE_MESSAGE:
   377 0000D5BA 50                  <1>     PUSH    AX
   378 0000D5BB B40E                <1>     MOV     AH, 0x0E
   379                              <1> .WRITE_LOOP:
   380 0000D5BD 8A07                <1>     MOV     AL, [BX]
   381 0000D5BF 3C00                <1>     cmp     al, 0x0 
   382 0000D5C1 7406                <1>     jz      .fim
   383                              <1>     ;INT 0x10
   384 0000D5C3 E879FC              <1>     call    cout
   385 0000D5C6 43                  <1>     INC     BX
   386 0000D5C7 E2F4                <1>     LOOP    .WRITE_LOOP
   387                              <1> .fim:    
   388 0000D5C9 58                  <1>     POP AX
   389 0000D5CA C3                  <1>     RET
   390                              <1> 
   391                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   392                              <1> ;INT 0X13 SOFTWARE DISK INTERRUPTS
   393                              <1> ;DONT FORGET HARDWARE INTERRUPTS ARE DISABLED WHEN SOFTWARE INTERRUPTS ARE CALLED
   394                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   395                              <1> INT13:
   396 0000D5CB 9C                  <1> 	PUSHF
   397 0000D5CC 80FA81              <1> 	CMP     DL, 0x81		;CHECK FOR DISK NUMBER BEING REQUESTED 
   398 0000D5CF 7405                <1> 	JE      .START_INT13		;JMP IF 0X80 C:
   399 0000D5D1 7403E91503          <1> 	JNE     .NOT_A_DRIVE	;JMP IF NOT C: NOT A DRIVE IN THE SYSTEM
   400                              <1>   .START_INT13:	
   401 0000D5D6 9D                  <1> 	POPF				    ; we don't need the pushed flags, so discard them.
   402                              <1> 
   403                              <1> 
   404 0000D5D7 80FC00              <1> 	CMP AH, 0X00
   405 0000D5DA 7470                <1> 	JE .RESET_DISK_SYSTEM 			;RESET DISK
   406 0000D5DC 80FC0D              <1> 	CMP AH, 0X0D
   407 0000D5DF 746B                <1> 	JE .RESET_DISK_SYSTEM 			;RESET DISK
   408 0000D5E1 80FC01              <1> 	CMP AH, 0X01
   409 0000D5E4 746C                <1> 	JE .GET_STATUS_LAST_OPERATION	;GET STATUS OF LAST OPERATION 
   410 0000D5E6 80FC02              <1> 	CMP AH, 0X02	
   411 0000D5E9 7503E99200          <1> 	JE .DISK_READ					;READ DISK CHS
   412 0000D5EE 80FC03              <1> 	CMP AH, 0X03
   413 0000D5F1 7503E92501          <1> 	JE .WRITE_DISK					;WRITE DISK CHS
   414 0000D5F6 80FC08              <1> 	CMP AH, 0X08
   415 0000D5F9 7503E94202          <1> 	JE .PARAMETERS					;GET DISK PARAMETERS
   416 0000D5FE 80FC15              <1> 	CMP AH, 0X15
   417 0000D601 7503E99402          <1> 	JE .GET_DISK_TYPE				;GET DISK TYPE
   418 0000D606 80FC10              <1> 	CMP AH, 0X10
   419 0000D609 743B                <1> 	JE .PLACEHOLDER_RETURN			;Test if ready
   420 0000D60B 80FC11              <1> 	CMP AH, 0X11
   421 0000D60E 7436                <1> 	JE .PLACEHOLDER_RETURN			;Calibrate Drive
   422 0000D610 80FC05              <1> 	CMP AH, 0X05
   423 0000D613 7503E99B01          <1> 	JE .FORMAT_TRACK				;FORMAT TRACK
   424 0000D618 80FC06              <1> 	CMP AH, 0X06
   425 0000D61B 7429                <1> 	JE .PLACEHOLDER_RETURN			;FORMAT TRACK/MARK BAD
   426 0000D61D 80FC04              <1> 	CMP AH, 0X04
   427 0000D620 7424                <1> 	JE .PLACEHOLDER_RETURN			;VERIFY
   428 0000D622 80FC0C              <1> 	CMP AH, 0X0C
   429 0000D625 741F                <1> 	JE .PLACEHOLDER_RETURN			;Seek to cylinder
   430 0000D627 80FC12              <1> 	CMP AH, 0X12
   431 0000D62A 741A                <1> 	JE .PLACEHOLDER_RETURN			;Controller Diagnostic
   432 0000D62C 80FC13              <1> 	CMP AH, 0X13
   433 0000D62F 7415                <1> 	JE .PLACEHOLDER_RETURN			;Drive Diagnostic
   434 0000D631 80FC14              <1> 	CMP AH, 0X14
   435 0000D634 7410                <1> 	JE .PLACEHOLDER_RETURN			;Internal Diagnostic
   436 0000D636 80FC16              <1> 	CMP AH, 0X16
   437 0000D639 740B                <1> 	JE .PLACEHOLDER_RETURN			;Disc change detection
   438 0000D63B 80FC09              <1> 	CMP AH, 0X09					
   439 0000D63E 7406                <1> 	JE .PLACEHOLDER_RETURN			;Initialize format to disk table
   440                              <1> 
   441                              <1> 									;FUNCTION NOT FOUND
   442 0000D640 B401                <1> 	MOV AH, 0X01					;INVALID FUNCTION IN AH
   443 0000D642 F9                  <1> 	STC								;SET CARRY FLAG 	
   444 0000D643 E98E02              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   445                              <1> 
   446                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   447                              <1> ;PLACEHOLDER FOR FUNCTIONS THAT DON'T APPLY/WORK
   448                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
   449                              <1> .PLACEHOLDER_RETURN:	
   450 0000D646 B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   451 0000D648 F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   452 0000D649 E98802              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   453                              <1> 
   454                              <1> 
   455                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   456                              <1> ;RESET DISK 
   457                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
   458                              <1> .RESET_DISK_SYSTEM:	
   459 0000D64C B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   460 0000D64E F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   461 0000D64F E98202              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   462                              <1> 
   463                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   464                              <1> ;STATUS OF LAST OPERATION  
   465                              <1> ;THIS PROABLY WILL NEED WORK
   466                              <1> ;THE CH376 ERROR STATUS NUMBERS DO NOT MATCH PC COMPATABLE NUMBERS
   467                              <1> ;STATUS 0X14 IS SUCCESS AND INTERPRETED TO RETURN 0X00
   468                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
   469                              <1> .GET_STATUS_LAST_OPERATION:	
   470                              <1> 	
   471 0000D652 B022                <1> 	MOV AL, CH376S_GET_STATUS			;GET_STATUS OF INT
   472 0000D654 E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT				
   473 0000D656 E4E0                <1> 	IN AL, DATA_PORT					;READ IN STATUS DATA PORT
   474                              <1> 	
   475 0000D658 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS		;CHECK FOR USB_INT_SUCCESS
   476 0000D65A 7506                <1> 	JNE .STATUS_DISK_ERROR				;IF USB_INT_SUCCESS
   477                              <1> 	
   478 0000D65C B400                <1> 	MOV AH, 0X00						;STATUS 0X00 SUCCESSFULL
   479 0000D65E F8                  <1> 	CLC									;CLEAR CARRY FLAG SUCCESFUL	
   480 0000D65F E97202              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   481                              <1> 	
   482                              <1> .STATUS_DISK_ERROR:
   483                              <1> 	; Instead of returning the CH376S status code in AL,
   484                              <1> 	; map some of them to BIOS-friendly codes
   485 0000D662 3C16                <1> 	CMP AL, CH376S_USB_INT_DISCONNECT		; DISC DISCONNECTED
   486 0000D664 7504                <1> 	JNE .NOT_0X16
   487 0000D666 B4AA                <1> 	MOV AH, 0xAA							; BIOS CODE AA
   488 0000D668 EB12                <1> 	JMP .STATUS_SELECTED
   489                              <1> 
   490                              <1> .NOT_0X16:
   491 0000D66A 3C17                <1> 	CMP AL, CH376S_USB_INT_BUF_OVER			; DATA ERROR OR BUFFER OVERFLOW
   492 0000D66C 7504                <1> 	JNE .NOT_0X17
   493 0000D66E B410                <1> 	MOV AH, 0x10							; BIOS CODE 10
   494 0000D670 EB0A                <1> 	JMP .STATUS_SELECTED
   495                              <1> 
   496                              <1> .NOT_0X17:
   497 0000D672 3C1F                <1> 	CMP AL, CH376S_USB_INT_DISK_ERR			; STORAGE DEVICE FAILURE
   498 0000D674 7504                <1> 	JNE .NOT_0X1F
   499 0000D676 B420                <1> 	MOV AH, 0x20							; BIOS CODE 20
   500 0000D678 EB02                <1> 	JMP .STATUS_SELECTED
   501                              <1> 
   502                              <1> .NOT_0X1F:
   503 0000D67A B4BB                <1> 	MOV AH, 0xBB							; BIOS CODE BB as catch all
   504                              <1> 
   505                              <1> .STATUS_SELECTED:
   506 0000D67C F9                  <1> 	STC										;SET CARRY FLAG 	
   507 0000D67D E95402              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   508                              <1> 	
   509                              <1> 
   510                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   511                              <1> ;READ DISK SECTOR	
   512                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   513                              <1> ;LBA = (C × HPC + H) × SPT + (S − 1)
   514                              <1> ;MAX NUMBERS C = 0X3FF, H = 0XFF, S = 0X3F
   515                              <1> ;AH = 02h
   516                              <1> ;AL = number of sectors to read (must be nonzero)
   517                              <1> ;CH = low eight bits of cylinder number
   518                              <1> ;CL = sector number 1-63 (bits 0-5)
   519                              <1> ;high two bits of cylinder (bits 6-7, hard disk only)
   520                              <1> ;DH = head number
   521                              <1> ;DL = drive number (bit 7 set for hard disk)
   522                              <1> ;ES:BX -> data buffer
   523                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   524                              <1> .DISK_READ:
   525 0000D680 53                  <1> 	PUSH BX					;
   526 0000D681 51                  <1> 	PUSH CX					;STORE REGISTERS
   527 0000D682 52                  <1> 	PUSH DX					;
   528 0000D683 06                  <1> 	PUSH ES					;
   529 0000D684 57                  <1> 	PUSH DI					;Used for bulk read
   530                              <1> 	
   531 0000D685 50                  <1> 	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
   532 0000D686 50                  <1> 	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
   533                              <1> 	
   534 0000D687 E89C03              <1> 	CALL CONVERT_CHS_TO_LBA
   535                              <1> 
   536 0000D68A 52                  <1> 	PUSH DX					;STORE LBA UPPER
   537 0000D68B 50                  <1> 	PUSH AX					;STORE LBA LOWER
   538                              <1> 		
   539                              <1> 	
   540 0000D68C B054                <1> 	MOV AL, CH376S_DISK_READ	;DISK_READ
   541 0000D68E E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   542 0000D690 58                  <1> 	POP AX						;GET LOWER LBA
   543 0000D691 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   544 0000D693 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   545 0000D695 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   546 0000D697 58                  <1> 	POP AX						;GET UPPER LBA
   547 0000D698 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   548 0000D69A 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   549 0000D69C E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   550 0000D69E 58                  <1> 	POP AX						;GET NUMBER OF SECTORS
   551 0000D69F E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   552                              <1> 
   553                              <1> 
   554                              <1> .READ_SECTOR:
   555 0000D6A1 E87903              <1> 	CALL AWAIT_INTERRUPT
   556                              <1> 
   557 0000D6A4 B022                <1> 	MOV AL, CH376S_GET_STATUS		;GET_STATUS
   558 0000D6A6 E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   559 0000D6A8 E4E0                <1> 	IN AL, DATA_PORT				;READ IN STATUS DATA PORT
   560 0000D6AA 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS	;CHECK FOR USB_INT_SUCCESS COMPLETED READING
   561 0000D6AC 7458                <1> 	JE .READ_DISK_SUCCESS			;IF USB_INT_SUCCESS
   562 0000D6AE 3C1D                <1> 	CMP AL, CH376S_USB_INT_DISK_READ;COMPARE TO USB_INT_DISK_READ
   563                              <1> %if DISPLAY_CH376S_ERRORS = 1
   564                              <1> 	JNE .NOT_1D						;IF NOT USB_INT_DISK_READ
   565                              <1> %else
   566 0000D6B0 7560                <1> 	JNE .READ_DISK_ERROR
   567                              <1> %endif	
   568                              <1> 
   569 0000D6B2 B027                <1> 	MOV AL, CH376S_RD_USB_DATA0		;RD_USB_DATA0
   570 0000D6B4 E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   571 0000D6B6 E4E0                <1> 	IN AL, DATA_PORT				;READ NUMBER OF BYTES FROM DATA PORT 
   572 0000D6B8 B400                <1> 	MOV AH, 0X00					;CLEAR AH
   573 0000D6BA 89C1                <1> 	MOV CX, AX						;SET CX TO NUMBER OF BYTES
   574                              <1> .READ_IN_LOOP:		    ;LOOP LABLE
   575 0000D6BC E4E0                <1> 	IN AL, DATA_PORT	;READ BYTE
   576 0000D6BE 268807              <1> 	MOV [ES:BX], AL		;STORE BYTE
   577 0000D6C1 43                  <1> 	INC BX				;INC BX
   578 0000D6C2 E2F8                <1> 	LOOP .READ_IN_LOOP	;LOOP UNTIL DONE
   579                              <1> 
   580 0000D6C4 B055                <1> 	MOV AL, CH376S_DISK_RD_GO		;DISK_RD_GO READ NEXT 64 BYTES
   581 0000D6C6 E6E4                <1> 	OUT COMMAND_PORT, AL			;OUT COMMAND PORT
   582 0000D6C8 EBD7                <1> 	JMP .READ_SECTOR				;LOOP UNTIL DONE
   583                              <1> 		
   584                              <1> .NOT_1D:							; DEBUG FEATURE: DISPLAY ERROR MESSAGE
   585 0000D6CA E85E1C              <1> 	CALL WRITE_AL_INT10_E			; PRINTS ERROR NUMBER TO SCREEN
   586 0000D6CD 50                  <1> 	PUSH AX
   587 0000D6CE 1E                  <1> 	PUSH DS
   588 0000D6CF 8CC8                <1> 	MOV AX, CS						; GET CS 
   589 0000D6D1 8ED8                <1> 	MOV DS, AX						; SET DS TO CS
   590 0000D6D3 B40E                <1> 	MOV AH, 0X0E					; FOR TELOTYPE
   591 0000D6D5 B92000              <1> 	MOV CX, .END_READ_ERROR_MESSAGE - .READ_ERROR_MESSAGE
   592 0000D6D8 BB[E6D6]            <1> 	MOV BX, .READ_ERROR_MESSAGE	
   593                              <1> 	.LOOP_NOT_1D:
   594 0000D6DB 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
   595 0000D6DD CD10                <1> 	INT 0X10						;PRINT TO SCREEN
   596 0000D6DF 43                  <1> 	INC BX							;INC BX
   597 0000D6E0 E2F9                <1> 	LOOP .LOOP_NOT_1D				;LOOP UNTIL DONE
   598 0000D6E2 1F                  <1> 	POP DS
   599 0000D6E3 58                  <1> 	POP AX
   600 0000D6E4 EB2C                <1> 	JMP .READ_DISK_ERROR
   601                              <1> 
   602                              <1> 	.READ_ERROR_MESSAGE:
   603 0000D6E6 0D0A55534220524541- <1> 	DB 0X0D, 0X0A, 'USB READ ERROR READING DISC', 0X0D, 0X0A, 0
   603 0000D6EF 44204552524F522052- <1>
   603 0000D6F8 454144494E47204449- <1>
   603 0000D701 53430D0A00          <1>
   604                              <1> 	.END_READ_ERROR_MESSAGE:
   605                              <1> 
   606                              <1> .READ_DISK_SUCCESS:
   607                              <1> 
   608 0000D706 58                  <1> 	POP AX
   609 0000D707 5F                  <1> 	POP DI
   610 0000D708 07                  <1> 	POP ES
   611 0000D709 5A                  <1> 	POP DX
   612 0000D70A 59                  <1> 	POP CX
   613 0000D70B 5B                  <1> 	POP BX
   614 0000D70C B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   615 0000D70E F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   616 0000D70F E9C201              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   617                              <1> 	
   618                              <1> .READ_DISK_ERROR:
   619 0000D712 5F                  <1> 	POP DI				; Discard the unwanted copy of AX on stack
   620 0000D713 5F                  <1> 	POP DI
   621 0000D714 07                  <1> 	POP ES
   622 0000D715 5A                  <1> 	POP DX
   623 0000D716 59                  <1> 	POP CX
   624 0000D717 5B                  <1> 	POP BX
   625 0000D718 E947FF              <1> 	JMP .STATUS_DISK_ERROR
   626                              <1> 
   627                              <1> 
   628                              <1> 
   629                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   630                              <1> ;WRITE DISK SECTOR(S)
   631                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   632                              <1> ;LBA = (C × HPC + H) × SPT + (S − 1)
   633                              <1> ;MAX NUMBERS C = 0X3FF, H = 0XFF, S = 0X3F
   634                              <1> ;AH = 03h
   635                              <1> ;AL = number of sectors to read (must be nonzero)
   636                              <1> ;CH = low eight bits of cylinder number
   637                              <1> ;CL = sector number 1-63 (bits 0-5)
   638                              <1> ;high two bits of cylinder (bits 6-7, hard disk only)
   639                              <1> ;DH = head number
   640                              <1> ;DL = drive number (bit 7 set for hard disk)
   641                              <1> ;ES:BX -> data buffer
   642                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   643                              <1> .WRITE_DISK:
   644 0000D71B 53                  <1> 	PUSH BX					;
   645 0000D71C 51                  <1> 	PUSH CX					;STORE REGISTERS
   646 0000D71D 52                  <1> 	PUSH DX					;
   647 0000D71E 06                  <1> 	PUSH ES					;
   648 0000D71F 1E                  <1> 	PUSH DS					; we'll need this for bulk writing
   649 0000D720 56                  <1> 	PUSH SI					; We need this for string operation
   650                              <1> 	
   651 0000D721 50                  <1> 	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
   652 0000D722 50                  <1> 	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
   653                              <1> 	
   654 0000D723 E80003              <1> 	CALL CONVERT_CHS_TO_LBA
   655                              <1> 
   656 0000D726 52                  <1> 	PUSH DX					;STORE LBA UPPER
   657 0000D727 50                  <1> 	PUSH AX					;STORE LBA LOWER
   658                              <1> 
   659 0000D728 B056                <1> 	MOV AL, CH376S_DISK_WRITE	;DISK_WRITE
   660 0000D72A E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   661                              <1> 
   662                              <1> 
   663 0000D72C 58                  <1> 	POP AX						;GET LOWER LBA
   664 0000D72D E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   665                              <1> 
   666                              <1> 
   667 0000D72F 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   668 0000D731 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   669                              <1> 
   670                              <1> 
   671 0000D733 58                  <1> 	POP AX						;GET UPPER LBA
   672 0000D734 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   673                              <1> 
   674 0000D736 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   675 0000D738 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   676                              <1> 
   677 0000D73A 58                  <1> 	POP AX						;GET NUMBER OF SECTORS
   678 0000D73B E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   679 0000D73D 8CC0                <1> 	MOV AX, ES					; While the BIOS spec has the package at ES:BX
   680 0000D73F 8ED8                <1> 	MOV DS, AX					; REP OUTSB transfers from DS:BX
   681                              <1> 	
   682                              <1> .WRITE_SECTOR:
   683 0000D741 E8D902              <1> 	CALL AWAIT_INTERRUPT
   684 0000D744 B022                <1> 	MOV AL, CH376S_GET_STATUS			;GET_STATUS
   685 0000D746 E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   686 0000D748 E4E0                <1> 	IN AL, DATA_PORT					;READ IN STATUS DATA PORT
   687 0000D74A 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS		;CHECK FOR USB_INT_SUCCESS COMPLETED WRITING
   688 0000D74C 744E                <1> 	JE .WRITE_DISK_SUCCESS				;IF USB_INT_SUCCESS
   689 0000D74E 3C1E                <1> 	CMP AL, CH376S_USB_INT_DISK_WRITE	;COMPARE TO USB_INT_DISK_WRITE
   690                              <1> %if DISPLAY_CH376S_ERRORS = 1
   691                              <1> 	JNE .NOT_1E			;IF NOT USB_INT_DISK_WRITE
   692                              <1> %else
   693 0000D750 7557                <1> 	JNE .WRITE_DISK_ERROR
   694                              <1> %endif	
   695 0000D752 B02C                <1> 	MOV AL, CH376S_WR_USB_DATA			;COMMAND WR_HOST_DATA
   696 0000D754 E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   697 0000D756 B040                <1> 	MOV AL, 0X40
   698 0000D758 E6E0                <1> 	OUT DATA_PORT, AL					;WRITE NUMBER OF BYTES TO PORT
   699 0000D75A B400                <1> 	MOV AH, 0X00						;CLEAR AH
   700 0000D75C 89C1                <1> 	MOV CX, AX							;SET CX TO NUMBER OF BYTES
   701                              <1>  .WRITE_IN_LOOP:		;LOOP LABLE
   702 0000D75E 268A07              <1>   	MOV AL, [ES:BX]		;STORE BYTE
   703 0000D761 E6E0                <1> 	OUT 0XE0, AL			;READ BYTE
   704                              <1> 	
   705 0000D763 43                  <1> 	INC BX				;INC BX
   706 0000D764 E2F8                <1> 	LOOP .WRITE_IN_LOOP	;LOOP UNTIL DONE
   707 0000D766 B057                <1> 	MOV AL, CH376S_DISK_WR_GO			;DISK_WR_GO WRITE NEXT 64 BYTES
   708 0000D768 E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   709 0000D76A EBD5                <1> 	JMP .WRITE_SECTOR					;LOOP UNTIL DONE
   710                              <1> 
   711                              <1> 		
   712                              <1> .NOT_1E:							; Version for debugging which displays error text
   713 0000D76C E8BC1B              <1> 	CALL WRITE_AL_INT10_E			;PRINTS ERROR NUMBER TO SCREEN
   714 0000D76F 50                  <1> 	PUSH AX
   715 0000D770 1E                  <1> 	PUSH DS
   716 0000D771 8CC8                <1> 	MOV AX, CS						;GET CS 
   717 0000D773 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
   718 0000D775 B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
   719 0000D777 B91400              <1> 	MOV CX, .END_WRITE_ERROR_MESSAGE - .WRITE_ERROR_MESSAGE
   720 0000D77A BB[88D7]            <1> 	MOV BX, .WRITE_ERROR_MESSAGE	
   721                              <1> 	.LOOP_NOT_1E:
   722 0000D77D 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
   723 0000D77F CD10                <1> 	INT 0X10						;PRINT TO SCREEN
   724 0000D781 43                  <1> 	INC BX							;INC BX
   725 0000D782 E2F9                <1> 	LOOP .LOOP_NOT_1E				;LOOP UNTIL DONE
   726 0000D784 1F                  <1> 	POP DS
   727 0000D785 58                  <1> 	POP AX
   728 0000D786 EB21                <1> 	JMP .WRITE_DISK_ERROR
   729                              <1> 
   730                              <1> 	.WRITE_ERROR_MESSAGE:
   731 0000D788 0D0A55534220575249- <1> 	DB 0X0D, 0X0A, 'USB WRITE ERROR', 0X0D, 0X0A,0
   731 0000D791 5445204552524F520D- <1>
   731 0000D79A 0A00                <1>
   732                              <1> 	.END_WRITE_ERROR_MESSAGE:
   733                              <1> 
   734                              <1> .WRITE_DISK_SUCCESS:
   735 0000D79C 58                  <1> 	POP AX
   736 0000D79D 5E                  <1> 	POP SI
   737 0000D79E 1F                  <1> 	POP DS
   738 0000D79F 07                  <1> 	POP ES
   739 0000D7A0 5A                  <1> 	POP DX
   740 0000D7A1 59                  <1> 	POP CX
   741 0000D7A2 5B                  <1> 	POP BX
   742 0000D7A3 B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   743 0000D7A5 F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   744 0000D7A6 E92B01              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   745                              <1> 	
   746                              <1> .WRITE_DISK_ERROR:
   747 0000D7A9 07                  <1> 	POP ES				; Discard the unwanted copy of AX on stack
   748 0000D7AA 5E                  <1> 	POP SI
   749 0000D7AB 1F                  <1> 	POP DS
   750 0000D7AC 07                  <1> 	POP ES
   751 0000D7AD 5A                  <1> 	POP DX
   752 0000D7AE 59                  <1> 	POP CX
   753 0000D7AF 5B                  <1> 	POP BX
   754 0000D7B0 E9AFFE              <1> 	JMP .STATUS_DISK_ERROR
   755                              <1> 	
   756                              <1> 
   757                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   758                              <1> ;FORMAT A TRACK
   759                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   760                              <1> ;LBA = (C × HPC + H) × SPT + (S − 1)
   761                              <1> ;MAX NUMBERS C = 0X3FF, H = 0XFF, S = 0X3F
   762                              <1> ;AH = 05h
   763                              <1> ;AL = Interleave value (ignored)
   764                              <1> ;CH = low eight bits of cylinder number
   765                              <1> ;CL = Low six bits ignored
   766                              <1> ;high two bits of cylinder (bits 6-7, hard disk only)
   767                              <1> ;DH = head number
   768                              <1> ;DL = drive number (bit 7 set for hard disk)
   769                              <1> ;ES:BX -> data buffer
   770                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   771                              <1> .FORMAT_TRACK:
   772 0000D7B3 53                  <1> 	PUSH BX					;
   773 0000D7B4 51                  <1> 	PUSH CX					;STORE REGISTERS
   774 0000D7B5 52                  <1> 	PUSH DX					;
   775                              <1> 
   776 0000D7B6 80E1C0              <1> 	AND CL, 0b11000000		;Remove the "sector" part of CX (ignored) and
   777 0000D7B9 80C901              <1> 	OR CL, 1				;treat it as "Sector 1", and
   778 0000D7BC E86702              <1> 	CALL CONVERT_CHS_TO_LBA	;the CHS->LBA formula will get us the first block of the track
   779                              <1> 
   780 0000D7BF 52                  <1> 	PUSH DX					;STORE LBA UPPER
   781 0000D7C0 50                  <1> 	PUSH AX					;STORE LBA LOWER
   782                              <1> 
   783 0000D7C1 B056                <1> 	MOV AL, CH376S_DISK_WRITE	;DISK_WRITE
   784 0000D7C3 E6E4                <1> 	OUT COMMAND_PORT, AL		;OUT COMMAND PORT
   785                              <1> 
   786 0000D7C5 58                  <1> 	POP AX						;GET LOWER LBA
   787 0000D7C6 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   788 0000D7C8 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   789 0000D7CA E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   790 0000D7CC 58                  <1> 	POP AX						;GET UPPER LBA
   791 0000D7CD E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   792 0000D7CF 88E0                <1> 	MOV AL, AH					;NEXT BYTE
   793 0000D7D1 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   794 0000D7D3 B03F                <1> 	MOV AL, MAX_SPT				;ALWAYS DO MAX SECTORS IN A TRACK
   795 0000D7D5 E6E0                <1> 	OUT DATA_PORT, AL			;OUT DATA PORT
   796                              <1> 	
   797                              <1> .FORMAT_SECTOR:
   798 0000D7D7 E84302              <1> 	CALL AWAIT_INTERRUPT
   799 0000D7DA B022                <1> 	MOV AL, CH376S_GET_STATUS			;GET_STATUS
   800 0000D7DC E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   801 0000D7DE E4E0                <1> 	IN AL, DATA_PORT					;READ IN STATUS DATA PORT
   802 0000D7E0 3C14                <1> 	CMP AL, CH376S_USB_INT_SUCCESS		;CHECK FOR USB_INT_SUCCESS COMPLETED WRITING
   803 0000D7E2 744D                <1> 	JE .FORMAT_DISK_SUCCESS				;IF USB_INT_SUCCESS
   804 0000D7E4 3C1E                <1> 	CMP AL, CH376S_USB_INT_DISK_WRITE	;COMPARE TO USB_INT_DISK_WRITE
   805                              <1> %if DISPLAY_CH376S_ERRORS = 1
   806                              <1> 	JNE .NOT_1E_FORMAT  				;IF NOT USB_INT_DISK_WRITE
   807                              <1> %else
   808 0000D7E6 7552                <1> 	JNE .FORMAT_DISK_ERROR
   809                              <1> %endif
   810 0000D7E8 B02C                <1> 	MOV AL, CH376S_WR_USB_DATA			;COMMAND WR_HOST_DATA
   811 0000D7EA E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   812 0000D7EC B040                <1> 	MOV AL, 0X40
   813 0000D7EE E6E0                <1> 	OUT DATA_PORT, AL					;WRITE NUMBER OF BYTES TO PORT
   814 0000D7F0 B400                <1> 	MOV AH, 0X00						;CLEAR AH
   815 0000D7F2 89C1                <1> 	MOV CX, AX							;SET CX TO NUMBER OF BYTES
   816 0000D7F4 B000                <1> 	MOV AL, 00h
   817                              <1> .FORMAT_BYTE:
   818 0000D7F6 E6E0                <1> 	OUT DATA_PORT, AL
   819 0000D7F8 E2FC                <1> 	LOOP .FORMAT_BYTE
   820 0000D7FA B057                <1> 	MOV AL, CH376S_DISK_WR_GO			;DISK_WR_GO READ NEXT 64 BYTES
   821 0000D7FC E6E4                <1> 	OUT COMMAND_PORT, AL				;OUT COMMAND PORT
   822 0000D7FE EBD7                <1> 	JMP .FORMAT_SECTOR					;LOOP UNTIL DONE
   823                              <1> 
   824                              <1> 		
   825                              <1> .NOT_1E_FORMAT:						; Debug version that displays error
   826 0000D800 E8281B              <1> 	CALL WRITE_AL_INT10_E			;PRINTS ERROR NUMBER TO SCREEN
   827 0000D803 50                  <1> 	PUSH AX
   828 0000D804 1E                  <1> 	PUSH DS
   829 0000D805 8CC8                <1> 	MOV AX, CS						;GET CS 
   830 0000D807 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
   831 0000D809 B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
   832 0000D80B B91500              <1> 	MOV CX, .END_FORMAT_ERROR_MESSAGE - .FORMAT_ERROR_MESSAGE
   833 0000D80E BB[1CD8]            <1> 	MOV BX, .FORMAT_ERROR_MESSAGE	
   834                              <1> 	.LOOP_NOT_1E_FORMAT:
   835 0000D811 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
   836 0000D813 CD10                <1> 	INT 0X10						;PRINT TO SCREEN
   837 0000D815 43                  <1> 	INC BX							;INC BX
   838 0000D816 E2F9                <1> 	LOOP .LOOP_NOT_1E_FORMAT				;LOOP UNTIL DONE
   839 0000D818 1F                  <1> 	POP DS
   840 0000D819 58                  <1> 	POP AX
   841 0000D81A EB1E                <1> 	JMP .FORMAT_DISK_ERROR
   842                              <1> 
   843                              <1> 	.FORMAT_ERROR_MESSAGE:
   844 0000D81C 0D0A55534220464F52- <1> 	DB 0X0D, 0X0A, 'USB FORMAT ERROR', 0X0D, 0X0A,0
   844 0000D825 4D4154204552524F52- <1>
   844 0000D82E 0D0A00              <1>
   845                              <1> 	.END_FORMAT_ERROR_MESSAGE:
   846                              <1> 
   847                              <1> .FORMAT_DISK_SUCCESS:
   848 0000D831 5A                  <1> 	POP DX
   849 0000D832 59                  <1> 	POP CX
   850 0000D833 5B                  <1> 	POP BX
   851 0000D834 B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   852 0000D836 F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   853 0000D837 E99A00              <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   854                              <1> 	
   855                              <1> .FORMAT_DISK_ERROR:
   856 0000D83A 5A                  <1> 	POP DX
   857 0000D83B 59                  <1> 	POP CX
   858 0000D83C 5B                  <1> 	POP BX
   859 0000D83D E922FE              <1> 	JMP .STATUS_DISK_ERROR
   860                              <1> 
   861                              <1> 
   862                              <1> 
   863                              <1> 
   864                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   865                              <1> ;GET PARAMETERS	0X08
   866                              <1> ;RETURNS
   867                              <1> ;AH=STATUS 0X00 IS GOOD
   868                              <1> ;BL=DOES NOT APPLY 
   869                              <1> ;CH=CYLINDERS
   870                              <1> ;CL=0-5 SECTORS PER TRACK 6-7 UPPER 2 BITS CYLINDER
   871                              <1> ;DH=NUMBER OF HEADS / SIDES -1
   872                              <1> ;DL=NUMBER OF DRIVES
   873                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   874                              <1> .PARAMETERS:
   875 0000D840 50                  <1> 	PUSH AX					;STORE AX
   876 0000D841 53                  <1> 	PUSH BX					;STORE BX
   877                              <1> 	
   878 0000D842 E80F02              <1> 	CALL GET_CAPACITY
   879                              <1> 	; DX:AX now has sector count
   880                              <1> 
   881 0000D845 83F800              <1> 	CMP AX, 0
   882 0000D848 7507                <1> 	JNE .HAS_PARAMS
   883 0000D84A 83FA00              <1> 	CMP DX, 0
   884 0000D84D 7502                <1> 	JNE .HAS_PARAMS
   885 0000D84F EB42                <1> 	JMP .PARAMETERS_NOT_P
   886                              <1> 
   887                              <1> .HAS_PARAMS:
   888                              <1> 	; If we exceed (MAX_SPT * MAX_HPC * MAX_CYL)
   889                              <1> 	; just identify as the max amount
   890 0000D851 83FA0F              <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   891 0000D854 7C10                <1> 	JL .SAFE_PARAMS
   892 0000D856 83FA0F              <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   893 0000D859 7F05                <1> 	JG .USE_MAX_PARAMS
   894 0000D85B 3D00C0              <1> 	CMP AX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   895 0000D85E 7E06                <1> 	JLE .SAFE_PARAMS
   896                              <1> 
   897                              <1> .USE_MAX_PARAMS:
   898 0000D860 BA0F00              <1> 	MOV DX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   899 0000D863 B800C0              <1> 	MOV AX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   900                              <1> 
   901                              <1> .SAFE_PARAMS:
   902 0000D866 B9F003              <1> 	MOV CX, (MAX_SPT * MAX_HPC)
   903                              <1> 				     		
   904                              <1> 							; The cylinders and heads seem to be "maximum"
   905                              <1> 							; so on 1024 cylinders, 1023 is max
   906                              <1> 							; 16 heads, 15 is max
   907                              <1> 							; but 63 sectors per track the right answer is actually 63
   908 0000D869 F7F1                <1> 	DIV CX					;DIV DX:AX / CX
   909 0000D86B BA0000              <1> 	MOV DX, 0X0000			;CLEAR DX JUST IN CASE THERE SHOULD NOT BE A REMANDER 
   910 0000D86E 83E801              <1> 	SUB AX, 1				; Max cylinder is number of cylinders minus one
   911 0000D871 88C5                <1> 	MOV CH, AL				;CH=0-7 CYLINDERS
   912 0000D873 D0E4                <1>     SHL AH, 1
   913 0000D875 D0E4                <1>     SHL AH, 1
   914 0000D877 D0E4                <1>     SHL AH, 1
   915 0000D879 D0E4                <1>     SHL AH, 1
   916 0000D87B D0E4                <1>     SHL AH, 1
   917 0000D87D D0E4                <1>     SHL AH, 1
   918 0000D87F B13F                <1> 	MOV CL, MAX_SPT			;SECTORS PER TRACK
   919 0000D881 80E13F              <1> 	AND CL, 0X3F			;CLEAR BITS 7-6
   920 0000D884 00E1                <1> 	ADD CL, AH				;ADD IN 8-9 BITS CYLINDER
   921 0000D886 B60F                <1> 	MOV DH, MAX_HPC - 1		;NUMBER OF HEADS / SIDES
   922 0000D888 B201                <1> 	MOV DL, 0X01			;NUMBER OF DRIVES
   923 0000D88A EB00                <1> 	JMP .END_PARAMETERS
   924                              <1> 
   925                              <1> .END_PARAMETERS:
   926                              <1> 
   927 0000D88C 5B                  <1> 	POP BX				;RESTORE BX
   928 0000D88D 58                  <1> 	POP AX				;RESTORE AX
   929                              <1> 	
   930 0000D88E B400                <1> 	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
   931 0000D890 F8                  <1> 	CLC					;CLEAR CARRY FLAG SUCCESFUL	
   932 0000D891 EB41                <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   933                              <1> 	
   934                              <1> .PARAMETERS_NOT_P:
   935                              <1> 	
   936 0000D893 5B                  <1> 	POP BX				;RESTORE BX
   937 0000D894 58                  <1> 	POP AX				;RESTORE AX
   938                              <1> 	
   939 0000D895 B401                <1> 	MOV AH, 0X01		;STATUS 0X01 UNSUCCESSFULL
   940 0000D897 F9                  <1> 	STC 				;SET CARRY FLAG	
   941 0000D898 EB3A                <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   942                              <1> 
   943                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   944                              <1> ;GET DISK TYPE	0X15
   945                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   946                              <1> .GET_DISK_TYPE:
   947 0000D89A 53                  <1> 	PUSH BX						;STORE BX
   948 0000D89B 50                  <1> 	PUSH AX
   949                              <1> 	
   950 0000D89C E8B501              <1> 	CALL GET_CAPACITY
   951                              <1> 	; DX:AX now has sector count - move to where the output wants it.
   952 0000D89F 89D1                <1> 	MOV CX, DX
   953 0000D8A1 89C2                <1> 	MOV DX, AX
   954                              <1> 	; CX:DX now has the sector count
   955                              <1> 
   956 0000D8A3 83F900              <1> 	CMP CX, 0
   957 0000D8A6 7507                <1> 	JNE .HAS_DISK_TYPE_PARAMS
   958 0000D8A8 83FA00              <1> 	CMP DX, 0
   959 0000D8AB 7502                <1> 	JNE .HAS_DISK_TYPE_PARAMS
   960 0000D8AD EB1B                <1> 	JMP .GET_DISK_TYPE_NOT_P
   961                              <1> 
   962                              <1> .HAS_DISK_TYPE_PARAMS:
   963                              <1> 	; If we exceed 0xFAC53F sectors (MAX_SPT * MAX_HPC * MAX_CYL)
   964                              <1> 	; just identify as FAC53F
   965 0000D8AF 83F90F              <1> 	CMP CX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   966 0000D8B2 7C11                <1> 	JL .SAFE_DISK_TYPE_PARAMS
   967 0000D8B4 83F90F              <1> 	CMP CX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   968 0000D8B7 7F06                <1> 	JG .USE_MAX_DISK_TYPE_PARAMS
   969 0000D8B9 81FA00C0            <1> 	CMP DX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   970 0000D8BD 7E06                <1> 	JLE .SAFE_DISK_TYPE_PARAMS
   971                              <1> 
   972                              <1> .USE_MAX_DISK_TYPE_PARAMS:
   973 0000D8BF B90F00              <1> 	MOV CX, (MAX_SPT * MAX_HPC * MAX_CYL) / 65536
   974 0000D8C2 BA00C0              <1> 	MOV DX, (MAX_SPT * MAX_HPC * MAX_CYL) % 65536
   975                              <1> 
   976                              <1> .SAFE_DISK_TYPE_PARAMS:
   977 0000D8C5 B80003              <1> 	MOV AX, 0X0300			;AH=0X03 FIXED DISK AL=RETURN 0X00
   978 0000D8C8 EB05                <1> 	JMP .END_GET_DISK_TYPE	;END
   979                              <1> 	
   980                              <1> .GET_DISK_TYPE_NOT_P:
   981 0000D8CA B80000              <1> 	MOV AX, 0X0000			;AH=0X00 WHEN NOT PRESENT 
   982 0000D8CD EB00                <1> 	JMP .END_GET_DISK_TYPE
   983                              <1> 	
   984                              <1> .END_GET_DISK_TYPE:
   985                              <1> 
   986 0000D8CF 58                  <1> 	POP AX
   987 0000D8D0 5B                  <1> 	POP BX					;RESTORE BX
   988 0000D8D1 F8                  <1> 	CLC						;CLEAR CARRY FLAG SUCCESFUL	
   989 0000D8D2 EB00                <1> 	JMP .INT13_END_WITH_CARRY_FLAG
   990                              <1> 
   991                              <1> 
   992                              <1> 	
   993                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   994                              <1> ;END INT 0X13 WITH UPDATED CARRY FLAG		
   995                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   996                              <1>   .INT13_END_WITH_CARRY_FLAG:	;THIS IS HOW I RETURN THE CARRY FLAG
   997 0000D8D4 50                  <1> 	PUSH    AX						;STORE AX
   998 0000D8D5 9C                  <1> 	PUSHF						;STORE FLAGS
   999 0000D8D6 58                  <1> 	POP     AX						;GET AX = FLAGS
  1000 0000D8D7 55                  <1> 	PUSH    BP						;STORE BP
  1001 0000D8D8 89E5                <1> 	MOV     BP, SP              	;Copy SP to BP for use as index
  1002 0000D8DA 83C508              <1> 	ADD     BP, 0X08				;offset 8
  1003 0000D8DD 836600FE            <1> 	AND     WORD [BP], 0XFFFE		;CLEAR CF = ZER0
  1004 0000D8E1 83E001              <1> 	AND     AX, 0X0001				;ONLY CF 
  1005 0000D8E4 094600              <1> 	OR	    WORD [BP], AX			;SET CF AX
  1006 0000D8E7 5D                  <1> 	POP     BP               		;RESTORE BASE POINTER
  1007 0000D8E8 58                  <1> 	POP     AX						;RESTORE AX	
  1008 0000D8E9 FB                  <1>     STI
  1009 0000D8EA CF                  <1> 	IRET						;RETRUN
  1010                              <1> 
  1011                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1012                              <1> ; WHEN REQUEST IS NOT A VALID DRIVE NUMBER
  1013                              <1> ; INVOKE OLD BIOS VECTOR AND RETURN
  1014                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1015                              <1> .NOT_A_DRIVE:
  1016 0000D8EB BE[F4D8]            <1>     mov     si, drvInvalid
  1017 0000D8EE E82DF9              <1>     call    pstr
  1018                              <1> 
  1019 0000D8F1 9D                  <1>   	POPF        ; we want the flags we stored before the original compare
  1020                              <1> 
  1021                              <1> 	;INT     0x40
  1022                              <1> 	;PUSH    BP
  1023                              <1> 	;MOV     BP,SP
  1024                              <1> 	;PUSHF
  1025                              <1> 	;POP     WORD [SS:BP+6]
  1026                              <1> 	;POP     BP
  1027 0000D8F2 FB                  <1>     STI
  1028 0000D8F3 CF                  <1> 	IRET
  1029 0000D8F4 0D0A496E76616C6964- <1> drvInvalid  db 0x0d,0x0a,'Invalid driver...',0x0d,0x0a,0
  1029 0000D8FD 206472697665722E2E- <1>
  1029 0000D906 2E0D0A00            <1>
  1030                              <1> ;WAIT_2:
  1031                              <1> ;	PUSH CX
  1032                              <1> ;	MOV CX, 0xFFFF		; 65536 runs = ~300k cycles = 40ms
  1033                              <1> ;DELAY: LOOP DELAY
  1034                              <1> ;	MOV CX, 0xFFFF		; 65536 runs = ~300k cycles = 40ms
  1035                              <1> ;DELAY2: LOOP DELAY2
  1036                              <1> ;	POP CX
  1037                              <1> ;	RET
  1038                              <1> 
  1039                              <1> ;WAIT_8:
  1040                              <1> ;	PUSH CX
  1041                              <1> ;	MOV CX, 8
  1042                              <1> ;  .LOOP1A:
  1043                              <1> ;	PUSH CX
  1044                              <1> ;	MOV CX, 0XFFFF
  1045                              <1> ;  .LOOP2A:
  1046                              <1> ;	LOOP .LOOP2A
  1047                              <1> ;	POP CX
  1048                              <1> ;	LOOP .LOOP1A
  1049                              <1> ;	POP CX
  1050                              <1> ;	RET
  1051                              <1> 		
  1052                              <1> ;;;;;;;;;;;;;;;;;;;;;;;
  1053                              <1> ;WRITE TO SCREEN;;;;;;;
  1054                              <1> ;;;;;;;;;;;;;;;;;;;;;;;
  1055                              <1> ;WRITE_AL_INT10_E:
  1056                              <1> ;
  1057                              <1> ;	PUSH AX
  1058                              <1> ;	PUSH BX
  1059                              <1> ;	PUSH CX
  1060                              <1> ;	PUSH DX
  1061                              <1> ;
  1062                              <1> ;	MOV BL, AL
  1063                              <1> ;
  1064                              <1> ;	MOV DH, AL
  1065                              <1> ;	MOV CL, 0X04
  1066                              <1> ;	SHR DH, CL
  1067                              <1> ;
  1068                              <1> ;	MOV AL, DH
  1069                              <1> ;	AND AL, 0X0F
  1070                              <1> ;	CMP AL, 0X09
  1071                              <1> ;	JA LETTER_HIGH
  1072                              <1> ;
  1073                              <1> ;	ADD AL, 0X30
  1074                              <1> ;	JMP PRINT_VALUE_HIGH
  1075                              <1> ;
  1076                              <1> ;	LETTER_HIGH:
  1077                              <1> ;	ADD AL, 0X37
  1078                              <1> ;
  1079                              <1> ;	PRINT_VALUE_HIGH:
  1080                              <1> ;	MOV AH, 0X0E
  1081                              <1> ;	INT 0X10
  1082                              <1> ;
  1083                              <1> ;	MOV AL, BL
  1084                              <1> ;	AND AL, 0X0F
  1085                              <1> ;	CMP AL, 0X09
  1086                              <1> ;	JA LETTER_LOW
  1087                              <1> ;
  1088                              <1> ;	ADD AL, 0X30
  1089                              <1> ;	JMP PRINT_VALUE_LOW
  1090                              <1> ;
  1091                              <1> ;	LETTER_LOW:
  1092                              <1> ;	ADD AL, 0X37
  1093                              <1> ;
  1094                              <1> ;	PRINT_VALUE_LOW:
  1095                              <1> ;	MOV AH, 0X0E
  1096                              <1> ;	INT 0X10
  1097                              <1> ;
  1098                              <1> ;	POP DX
  1099                              <1> ;	POP CX
  1100                              <1> ;	POP BX
  1101                              <1> ;	POP AX
  1102                              <1> ;
  1103                              <1> ;	RET
  1104                              <1> 
  1105                              <1> 
  1106                              <1> WRITE_SECTORS_IN_MB:
  1107                              <1> 	; Assumes sectors in DX:ax
  1108                              <1> 	; Likely to get confused on devices over 64Gb as the first div below
  1109                              <1> 	; overflows.
  1110 0000D90A 50                  <1> 	PUSH AX
  1111 0000D90B 51                  <1> 	PUSH CX
  1112 0000D90C 52                  <1> 	PUSH DX
  1113 0000D90D 53                  <1> 	PUSH BX
  1114 0000D90E 31DB                <1> 	XOR BX, BX
  1115 0000D910 81FA0008            <1> 	CMP DX, 2048 ; 2048 x 10000h + sectors will overflow the DIV
  1116 0000D914 7C13                <1> 	JL CONVERT_TO_MB_GB
  1117 0000D916 B301                <1> 	MOV BL, 1 ; FLAG TO USE GB
  1118 0000D918 89D0                <1> 	MOV AX, DX
  1119 0000D91A BA0000              <1> 	MOV DX, 0
  1120                              <1> 			  ; Instead of dividing sectors (512 bytes) by 2048 to get MB
  1121                              <1> 			  ; Divide 10000h-sectors (32Mb units) by 32 to get GB
  1122 0000D91D D1E8                <1> 	SHR AX,1	  ; This remains 8088 version because it's not performance critical
  1123 0000D91F D1E8                <1> 	SHR AX,1
  1124 0000D921 D1E8                <1> 	SHR AX,1
  1125 0000D923 D1E8                <1> 	SHR AX,1
  1126 0000D925 D1E8                <1> 	SHR AX,1
  1127 0000D927 EB05                <1> 	JMP CONVERT_TO_DECIMAL
  1128                              <1> 
  1129                              <1> 
  1130                              <1> CONVERT_TO_MB_GB:
  1131 0000D929 B90008              <1> 	MOV CX, 2048
  1132 0000D92C F7F1                <1> 	DIV CX
  1133                              <1> 
  1134                              <1> CONVERT_TO_DECIMAL:
  1135 0000D92E BA0000              <1> 	MOV DX, 0 ; Divide by 10000, take the digit and convert to ASCII, and print
  1136 0000D931 B91027              <1> 	MOV CX, 10000
  1137 0000D934 F7F1                <1> 	DIV CX
  1138 0000D936 B40E                <1> 	MOV AH, 0x0E
  1139 0000D938 0C30                <1> 	OR AL, 0x30
  1140 0000D93A CD10                <1> 	INT 0x10
  1141                              <1> 
  1142                              <1> 
  1143 0000D93C 89D0                <1> 	MOV AX, DX	  ;  Take remainder, divide by 1000, repeat
  1144 0000D93E BA0000              <1> 	mov DX, 0
  1145 0000D941 B9E803              <1> 	MOV CX, 1000
  1146 0000D944 F7F1                <1> 	DIV CX
  1147 0000D946 B40E                <1> 	MOV AH, 0x0E
  1148 0000D948 0C30                <1> 	OR AL, 0x30
  1149 0000D94A CD10                <1> 	INT 0x10
  1150                              <1> 
  1151 0000D94C 89D0                <1> 	MOV AX, DX	  ;  Take remainder, divide by 100, repeat
  1152 0000D94E BA0000              <1> 	MOV DX, 0
  1153 0000D951 B96400              <1> 	MOV CX, 100
  1154 0000D954 F7F1                <1> 	DIV CX
  1155 0000D956 B40E                <1> 	MOV AH, 0x0E
  1156 0000D958 0C30                <1> 	OR AL, 0x30
  1157 0000D95A CD10                <1> 	INT 0x10
  1158                              <1> 
  1159 0000D95C 89D0                <1> 	MOV AX, DX
  1160 0000D95E BA0000              <1> 	MOV DX, 0
  1161 0000D961 B90A00              <1> 	MOV CX, 10	  ;  Take remainder, divide by 10, repeat
  1162 0000D964 F7F1                <1> 	DIV CX
  1163 0000D966 B40E                <1> 	MOV AH, 0x0E
  1164 0000D968 0C30                <1> 	OR AL, 0x30
  1165 0000D96A CD10                <1> 	INT 0x10
  1166                              <1> 
  1167 0000D96C B40E                <1> 	MOV AH, 0x0E
  1168 0000D96E 88D0                <1> 	MOV AL, DL	  ; Last remainder is a single digit.
  1169 0000D970 0C30                <1> 	OR AL, 0x30
  1170 0000D972 CD10                <1> 	INT 0x10
  1171 0000D974 80FB01              <1> 	CMP BL, 1
  1172 0000D977 7507                <1> 	JNE DISPLAY_M
  1173 0000D979 B8470E              <1> 	MOV AX, 0E47H	; Display "G"
  1174 0000D97C CD10                <1> 	INT 0x10
  1175 0000D97E EB05                <1> 	JMP LEAVE_SECTOR_DISPLAY
  1176                              <1> DISPLAY_M:
  1177 0000D980 B84D0E              <1> 	MOV AX, 0E4DH    ; Display "M"
  1178 0000D983 CD10                <1> 	INT 0x10
  1179                              <1> 	
  1180                              <1> 
  1181                              <1> LEAVE_SECTOR_DISPLAY:
  1182                              <1>  
  1183 0000D985 5B                  <1> 	POP BX
  1184 0000D986 5A                  <1> 	POP DX
  1185 0000D987 59                  <1> 	POP CX
  1186 0000D988 58                  <1> 	POP AX
  1187 0000D989 C3                  <1> 	RET
  1188                              <1> 
  1189                              <1> OVERSIZE_MESSAGE:
  1190 0000D98A 0D0A2A2A2A2A204E4F- <1> 	DB 0x0D, 0x0A, '**** NOTE: Device exceeds 504M limit and will be presented as 504M ****',0
  1190 0000D993 54453A204465766963- <1>
  1190 0000D99C 652065786365656473- <1>
  1190 0000D9A5 203530344D206C696D- <1>
  1190 0000D9AE 697420616E64207769- <1>
  1190 0000D9B7 6C6C20626520707265- <1>
  1190 0000D9C0 73656E746564206173- <1>
  1190 0000D9C9 203530344D202A2A2A- <1>
  1190 0000D9D2 2A00                <1>
  1191                              <1> END_OVERSIZE_MESSAGE:
  1192                              <1> 
  1193                              <1> BELOW_TABLE_SIZE_MESSAGE:
  1194 0000D9D4 0D0A44657669636520- <1> 	DB 0x0D, 0x0A, 'Device smaller than ROM parameter table.',0x0D, 0x0A
  1194 0000D9DD 736D616C6C65722074- <1>
  1194 0000D9E6 68616E20524F4D2070- <1>
  1194 0000D9EF 6172616D6574657220- <1>
  1194 0000D9F8 7461626C652E0D0A    <1>
  1195 0000DA00 537567676573746564- <1>     DB 'Suggested cylinder count: 0x',0
  1195 0000DA09 2063796C696E646572- <1>
  1195 0000DA12 20636F756E743A2030- <1>
  1195 0000DA1B 7800                <1>
  1196                              <1> END_BELOW_TABLE_SIZE_MESSAGE:
  1197                              <1> 
  1198                              <1> AWAIT_INTERRUPT:
  1199 0000DA1D 50                  <1> 	PUSH AX
  1200                              <1> INTERRUPT_LOOP:
  1201 0000DA1E E4E4                <1> 	IN AL, COMMAND_PORT				; Loop waiting for the interrupt
  1202 0000DA20 2480                <1> 	AND AL, 0x80
  1203 0000DA22 75FA                <1> 	JNZ INTERRUPT_LOOP
  1204 0000DA24 58                  <1> 	POP AX
  1205 0000DA25 C3                  <1> 	RET
  1206                              <1> 
  1207                              <1> ; Expects CX to have cylinder/sector and DH to have head number
  1208                              <1> ; Leaves sector count in DX:AX
  1209                              <1> 
  1210                              <1> CONVERT_CHS_TO_LBA:
  1211 0000DA26 51                  <1> 	PUSH CX					;STORE CX / SECTOR NUMBER
  1212 0000DA27 52                  <1> 	PUSH DX					;STORE DX / DH HEAD NUMBER
  1213                              <1> 
  1214 0000DA28 88E8                <1> 	MOV AL, CH				;GET LOWER CYLINDER NUMBER
  1215 0000DA2A D0E9                <1> 	SHR CL, 0X01			;SHIFT RIGHT 6 TIMES FOR UPPER 2 BITS CYLINDER
  1216 0000DA2C D0E9                <1> 	SHR CL, 0X01			;
  1217 0000DA2E D0E9                <1> 	SHR CL, 0X01			;
  1218 0000DA30 D0E9                <1> 	SHR CL, 0X01			;	
  1219 0000DA32 D0E9                <1> 	SHR CL, 0X01			;
  1220 0000DA34 D0E9                <1> 	SHR CL, 0X01			;
  1221                              <1> 
  1222 0000DA36 88CC                <1> 	MOV AH, CL				;AX HOLDS CYLINDER NUMBER			;
  1223 0000DA38 B91000              <1> 	MOV CX, MAX_HPC			;NUMBER OF HEADS / SIDES (HPC)
  1224 0000DA3B F7E1                <1> 	MUL CX					;AX = C X HPC
  1225 0000DA3D 59                  <1> 	POP CX					;GET HEAD NUMBER
  1226 0000DA3E 88E9                <1> 	MOV CL, CH				;MOV HEAD NUMBER
  1227 0000DA40 B500                <1> 	MOV CH, 0X00			;CLEAR CH
  1228 0000DA42 01C8                <1> 	ADD AX, CX				;ADD IN HEAD (C X HPC + H)
  1229 0000DA44 B93F00              <1> 	MOV CX, MAX_SPT			;SECTORS PER TRACK	
  1230 0000DA47 F7E1                <1> 	MUL CX					;DX:AX (C X HPC + H) X SPT
  1231 0000DA49 59                  <1> 	POP CX					;GET SECTOR NUMBER
  1232 0000DA4A 83E13F              <1> 	AND CX, 0X003F			;CLEAR OUT CYLINDER
  1233 0000DA4D 49                  <1> 	DEC CX					;(S - 1)
  1234 0000DA4E 01C8                <1> 	ADD AX, CX				;LBA = (C × HPC + H) × SPT + (S − 1)
  1235 0000DA50 83D200              <1> 	ADC DX, 0X00			;IF THERE IS A CARRY POSIBLE I DONT KNOW
  1236 0000DA53 C3                  <1> 	RET
  1237                              <1> 
  1238                              <1> ; Does the CH376S lookup and reads sector count into DX:AX
  1239                              <1> GET_CAPACITY:
  1240 0000DA54 53                  <1> 	PUSH BX
  1241 0000DA55 B03E                <1>  	MOV AL, CH376S_DISK_CAPACITY	; Get Disc Capacity
  1242 0000DA57 E6E4                <1>     OUT COMMAND_PORT, AL
  1243                              <1> 
  1244 0000DA59 E8C1FF              <1> 	CALL AWAIT_INTERRUPT
  1245                              <1> 
  1246 0000DA5C B027                <1> 	MOV AL, CH376S_RD_USB_DATA0 	; Read device data
  1247 0000DA5E E6E4                <1>     OUT COMMAND_PORT, AL
  1248 0000DA60 E4E0                <1> 	IN AL, DATA_PORT    			; count- should be four bytes
  1249 0000DA62 E4E0                <1>     IN AL, DATA_PORT    			; lowest byte
  1250 0000DA64 88C3                <1> 	mov BL, AL
  1251 0000DA66 E4E0                <1> 	IN AL, DATA_PORT    			; second lowest
  1252 0000DA68 88C7                <1> 	MOV BH, AL
  1253 0000DA6A 53                  <1> 	PUSH BX
  1254 0000DA6B E4E0                <1> 	IN AL, DATA_PORT				; third
  1255 0000DA6D 88C3                <1> 	MOV BL, AL
  1256 0000DA6F E4E0                <1> 	IN AL, DATA_PORT				; fourth
  1257 0000DA71 88C7                <1> 	MOV BH, AL
  1258 0000DA73 53                  <1> 	PUSH BX
  1259                              <1> 
  1260 0000DA74 5A                  <1> 	POP DX							; DX:AX now contains sector count.
  1261 0000DA75 58                  <1> 	POP AX
  1262 0000DA76 5B                  <1> 	POP BX
  1263 0000DA77 C3                  <1> 	RET
  1264                              <1> 
  1265                              <1> END_OF_LINE:
  1266 0000DA78 50                  <1> 	PUSH AX
  1267 0000DA79 B80D0E              <1> 	MOV AX, 0x0E0D		; Print a newline
  1268 0000DA7C CD10                <1>     INT 0x10
  1269 0000DA7E B00A                <1>     MOV AL, 0x0A		; and line feed
  1270 0000DA80 CD10                <1>     INT 0x10
  1271 0000DA82 58                  <1> 	POP AX
  1272 0000DA83 C3                  <1> 	RET;
  1273                              <1> 
  1274                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1275                              <1> ;THIS LOADS THE MBR TO 0XF400:0000
  1276                              <1> ;LOADS THE VBR TO 0XF400:0200
  1277                              <1> ;USED BY INT 0X13 FOR CHS->LBA CALC	
  1278                              <1> ;THE VBR HAS THE DRIVE GEOMETRY AT 
  1279                              <1> ;0XF400:0X0218 DW SPT
  1280                              <1> ;0XF400:0X021A DW HPC
  1281                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1282                              <1> 
  1283                              <1> LOAD_BOOT_RECORD:
  1284                              <1> 	
  1285 0000DA84 9C                  <1> 	PUSHF			;STORE FLAGS
  1286 0000DA85 FA                  <1> 	CLI				;
  1287 0000DA86 50                  <1> 	PUSH AX			;STORE AX
  1288 0000DA87 53                  <1> 	PUSH BX			;STORE BX
  1289 0000DA88 51                  <1> 	PUSH CX			;STORE CX
  1290 0000DA89 1E                  <1> 	PUSH DS			;STORE DS
  1291 0000DA8A B800F4              <1> 	MOV AX, 0XF400	;
  1292 0000DA8D 8ED8                <1> 	MOV DS, AX		;SET DS 0XF400 UPPER RAM
  1293 0000DA8F BB0000              <1> 	MOV BX, 0X0000	;SET BX 0 FOR INDEX
  1294                              <1> 					;READ MBR
  1295 0000DA92 B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1296 0000DA94 E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1297 0000DA96 B000                <1> 	MOV AL, 0X00	;LBA 0X00000000
  1298 0000DA98 E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1299 0000DA9A E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1300 0000DA9C E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1301 0000DA9E E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1302 0000DAA0 B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1303 0000DAA2 E6E0                <1> 	OUT 0XE0, AL	;OUT COMMAND PORT
  1304                              <1> 
  1305                              <1> .READ_MBR_SECTOR:
  1306 0000DAA4 B9FF00              <1> 	MOV CX, 0X00FF		;DELAY 
  1307 0000DAA7 E2FE                <1> 	DB 0XE2, 0XFE		;LOOP BACK
  1308                              <1> 	
  1309 0000DAA9 B022                <1> 	MOV AL, 0X22		;GET_STATUS
  1310 0000DAAB E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1311 0000DAAD E4E0                <1> 	IN AL, 0XE0			;READ IN STATUS DATA PORT
  1312 0000DAAF 3C14                <1> 	CMP AL, 0X14		;CHECK FOR USB_INT_SUCCESS COMPLETED READING
  1313 0000DAB1 7473                <1> 	JE .READ_MBR_SUCCESS;IF USB_INT_SUCCESS
  1314 0000DAB3 3C1D                <1> 	CMP AL, 0X1D		;COMPARE TO USB_INT_DISK_READ
  1315 0000DAB5 7517                <1> 	JNE .NOT_1D			;IF NOT USB_INT_DISK_READ
  1316                              <1> 	
  1317 0000DAB7 B027                <1> 	MOV AL, 0X27		;RD_USB_DATA0
  1318 0000DAB9 E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1319 0000DABB E4E0                <1> 	IN AL, 0XE0			;READ NUMBER OF BYTES FROM DATA PORT 
  1320 0000DABD B400                <1> 	MOV AH, 0X00		;CLEAR AH
  1321 0000DABF 89C1                <1> 	MOV CX, AX			;SET CX TO NUMBER OF BYTES
  1322                              <1>   .READ_MBR_LOOP:		;LOOP LABLE
  1323 0000DAC1 E4E0                <1> 	IN AL, 0XE0			;READ BYTE
  1324 0000DAC3 8807                <1> 	MOV [BX], AL		;WRITE BYTE TO DS:BX
  1325 0000DAC5 43                  <1> 	INC BX				;INC INDEX
  1326 0000DAC6 E2F9                <1> 	LOOP .READ_MBR_LOOP	;LOOP UNTIL DONE
  1327                              <1> 	
  1328 0000DAC8 B055                <1> 	MOV AL, 0X55		;DISK_RD_GO READ NEXT 64 BYTES
  1329 0000DACA E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1330 0000DACC EBD6                <1> 	JMP .READ_MBR_SECTOR;LOOP UNTIL DONE
  1331                              <1> 
  1332                              <1> .NOT_1D:
  1333 0000DACE E85A18              <1> 	CALL WRITE_AL_INT10_E			;PRINTS ERROR NUMBER TO SCREEN	
  1334 0000DAD1 8CC8                <1> 	MOV AX, CS						;GET CS 
  1335 0000DAD3 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
  1336 0000DAD5 B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
  1337 0000DAD7 B91200              <1> 	MOV CX, .END_READ_ERROR_MESSAGE - .READ_ERROR_MESSAGE
  1338 0000DADA BB[E7DA]            <1> 	MOV BX, .READ_ERROR_MESSAGE	
  1339                              <1> 	.LOOP_NOT_1D:
  1340 0000DADD 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
  1341 0000DADF CD10                <1> 	INT 0X10						;PRINT TO SCREEN
  1342 0000DAE1 43                  <1> 	INC BX							;INC BX
  1343 0000DAE2 E2F9                <1> 	LOOP .LOOP_NOT_1D				;LOOP UNTIL DONE
  1344                              <1> 	
  1345 0000DAE4 E99001              <1> 	JMP .END_LOAD_BOOT_RECORD
  1346                              <1> 
  1347                              <1> 	.READ_ERROR_MESSAGE:
  1348 0000DAE7 205553422052454144- <1> 	DB ' USB READ ERR0R', 0X0D, 0X0A,0
  1348 0000DAF0 2045525230520D0A00  <1>
  1349                              <1> 	.END_READ_ERROR_MESSAGE:
  1350                              <1> 	
  1351                              <1> .NOT_BOOTABLE_MBR:
  1352 0000DAF9 8CC8                <1> 	MOV AX, CS						;GET CS 
  1353 0000DAFB 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
  1354 0000DAFD B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
  1355 0000DAFF B91700              <1> 	MOV CX, .END_NOT_MBR_MESSAGE - .NOT_MBR_MESSAGE
  1356 0000DB02 BB[0FDB]            <1> 	MOV BX, .NOT_MBR_MESSAGE
  1357                              <1>     .LOOP_NOT_MBR:	
  1358 0000DB05 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
  1359 0000DB07 CD10                <1> 	INT 0X10						;PRINT TO SCREEN
  1360 0000DB09 43                  <1> 	INC BX							;INC BX
  1361 0000DB0A E2F9                <1> 	LOOP .LOOP_NOT_MBR				;LOOP UNTIL DONE
  1362                              <1> 	
  1363 0000DB0C E96801              <1> 	JMP .END_LOAD_BOOT_RECORD
  1364                              <1> 
  1365                              <1> 	.NOT_MBR_MESSAGE:
  1366 0000DB0F 4E4F20424F4F542053- <1> 	DB 'NO BOOT SIGNATURE MBR', 0X0D, 0X0A
  1366 0000DB18 49474E415455524520- <1>
  1366 0000DB21 4D42520D0A          <1>
  1367                              <1> 	.END_NOT_MBR_MESSAGE:
  1368                              <1> 	
  1369                              <1> .READ_MBR_SUCCESS:
  1370 0000DB26 BBFE01              <1> 	MOV BX, 0X01FE			;END OF MBR DS ST ILL IS 0XF400
  1371 0000DB29 813F55AA            <1> 	CMP WORD [BX], 0XAA55	;BOOT SIGNATURE DS:BX
  1372 0000DB2D 75CA                <1> 	JNE .NOT_BOOTABLE_MBR	;IF BOOT SIGNATURE IS NOT THERE
  1373                              <1> 	
  1374 0000DB2F E84318              <1> 	CALL WAIT_8			;DELAY NEEDED BEFORE READING THE NEXT SECTOR 
  1375                              <1> 			
  1376                              <1> 	
  1377 0000DB32 BBBE01              <1> 	MOV BX, 0X01BE			;FIRST PARTITION ENTRY 
  1378 0000DB35 803F80              <1> 	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
  1379 0000DB38 741B                <1> 	JE .BOOT_FIRST_ENTRY	;
  1380 0000DB3A BBCE01              <1> 	MOV BX, 0X01CE			;SECOND PARTITION ENTRY 
  1381 0000DB3D 803F80              <1> 	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
  1382 0000DB40 7437                <1> 	JE .BOOT_SECOND_ENTRY	;
  1383 0000DB42 BBDE01              <1> 	MOV BX, 0X01DE			;THRID PARTITION ENTRY 
  1384 0000DB45 803F80              <1> 	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
  1385 0000DB48 7453                <1> 	JE .BOOT_THIRD_ENTRY	;
  1386 0000DB4A BBEE01              <1> 	MOV BX, 0X01EE			;FORTH PARTITION ENTRY 
  1387 0000DB4D 803F80              <1> 	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
  1388 0000DB50 746F                <1> 	JE .BOOT_FORTH_ENTRY	;
  1389 0000DB52 E9F400              <1> 	JMP .NO_BOOTABLE_PARTITION
  1390                              <1> 	
  1391                              <1> .BOOT_FIRST_ENTRY:	
  1392 0000DB55 B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1393 0000DB57 E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1394 0000DB59 BBC601              <1> 	MOV BX, 0X01C6	;PARTITION LBA START LOCATION
  1395 0000DB5C 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1396 0000DB5E E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1397 0000DB60 43                  <1> 	INC BX			;NEXT BYTE
  1398 0000DB61 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1399 0000DB63 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1400 0000DB65 43                  <1> 	INC BX			;NEXT BYTE
  1401 0000DB66 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1402 0000DB68 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1403 0000DB6A 43                  <1> 	INC BX			;NEXT BYTE
  1404 0000DB6B 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1405 0000DB6D E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1406 0000DB6F 43                  <1> 	INC BX			;NEXT BYTE
  1407 0000DB70 B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1408 0000DB72 E6E0                <1> 	OUT 0XE0, AL
  1409 0000DB74 BB0002              <1> 	MOV BX, 0X0200	;SET BX 200 FOR INDEX
  1410 0000DB77 EB6C                <1> 	JMP .READ_VBR_SECTOR
  1411                              <1> .BOOT_SECOND_ENTRY:
  1412 0000DB79 B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1413 0000DB7B E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1414 0000DB7D BBD601              <1> 	MOV BX, 0X01D6	;PARTITION LBA START LOCATION
  1415 0000DB80 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1416 0000DB82 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1417 0000DB84 43                  <1> 	INC BX			;NEXT BYTE
  1418 0000DB85 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1419 0000DB87 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1420 0000DB89 43                  <1> 	INC BX			;NEXT BYTE
  1421 0000DB8A 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1422 0000DB8C E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1423 0000DB8E 43                  <1> 	INC BX			;NEXT BYTE
  1424 0000DB8F 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1425 0000DB91 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1426 0000DB93 43                  <1> 	INC BX			;NEXT BYTE
  1427 0000DB94 B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1428 0000DB96 E6E0                <1> 	OUT 0XE0, AL
  1429 0000DB98 BB0002              <1> 	MOV BX, 0X0200	;SET BX 200 FOR INDEX
  1430 0000DB9B EB48                <1> 	JMP .READ_VBR_SECTOR
  1431                              <1> .BOOT_THIRD_ENTRY:
  1432 0000DB9D B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1433 0000DB9F E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1434 0000DBA1 BBE601              <1> 	MOV BX, 0X01E6	;PARTITION LBA START LOCATION
  1435 0000DBA4 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1436 0000DBA6 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1437 0000DBA8 43                  <1> 	INC BX			;NEXT BYTE
  1438 0000DBA9 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1439 0000DBAB E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1440 0000DBAD 43                  <1> 	INC BX			;NEXT BYTE
  1441 0000DBAE 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1442 0000DBB0 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1443 0000DBB2 43                  <1> 	INC BX			;NEXT BYTE
  1444 0000DBB3 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1445 0000DBB5 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1446 0000DBB7 43                  <1> 	INC BX			;NEXT BYTE
  1447 0000DBB8 B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1448 0000DBBA E6E0                <1> 	OUT 0XE0, AL
  1449 0000DBBC BB0002              <1> 	MOV BX, 0X0200	;SET BX 200 FOR INDEX
  1450 0000DBBF EB24                <1> 	JMP .READ_VBR_SECTOR
  1451                              <1> .BOOT_FORTH_ENTRY:
  1452 0000DBC1 B054                <1> 	MOV AL, 0X54	;DISK_READ COMMAND
  1453 0000DBC3 E6E4                <1> 	OUT 0XE4, AL	;OUT COMMAND PORT
  1454 0000DBC5 BBF601              <1> 	MOV BX, 0X01F6	;PARTITION LBA START LOCATION
  1455 0000DBC8 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1456 0000DBCA E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1457 0000DBCC 43                  <1> 	INC BX			;NEXT BYTE
  1458 0000DBCD 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1459 0000DBCF E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1460 0000DBD1 43                  <1> 	INC BX			;NEXT BYTE
  1461 0000DBD2 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1462 0000DBD4 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1463 0000DBD6 43                  <1> 	INC BX			;NEXT BYTE
  1464 0000DBD7 8A07                <1> 	MOV AL, [BX]	;GET BYTE
  1465 0000DBD9 E6E0                <1> 	OUT 0XE0, AL	;OUT DATA PORT
  1466 0000DBDB 43                  <1> 	INC BX			;NEXT BYTE
  1467 0000DBDC B001                <1> 	MOV AL, 0X01	;READ ONE SECTOR
  1468 0000DBDE E6E0                <1> 	OUT 0XE0, AL
  1469 0000DBE0 BB0002              <1> 	MOV BX, 0X0200	;SET BX 200 FOR INDEX
  1470 0000DBE3 EB00                <1> 	JMP .READ_VBR_SECTOR
  1471                              <1> 	
  1472                              <1> .READ_VBR_SECTOR:
  1473 0000DBE5 B9FF00              <1> 	MOV CX, 0X00FF		;DELAY 
  1474 0000DBE8 E2FE                <1> 	DB 0XE2, 0XFE		;LOOP BACK
  1475                              <1> 	
  1476 0000DBEA B022                <1> 	MOV AL, 0X22		;GET_STATUS
  1477 0000DBEC E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1478 0000DBEE E4E0                <1> 	IN AL, 0XE0			;READ IN STATUS DATA PORT
  1479 0000DBF0 3C14                <1> 	CMP AL, 0X14		;CHECK FOR USB_INT_SUCCESS COMPLETED READING
  1480 0000DBF2 741E                <1> 	JE .READ_VBR_SUCCESS;IF USB_INT_SUCCESS
  1481 0000DBF4 3C1D                <1> 	CMP AL, 0X1D		;COMPARE TO USB_INT_DISK_READ
  1482 0000DBF6 7403E9D3FE          <1> 	JNE .NOT_1D			;IF NOT USB_INT_DISK_READ
  1483                              <1> 	
  1484 0000DBFB B027                <1> 	MOV AL, 0X27		;RD_USB_DATA0
  1485 0000DBFD E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1486 0000DBFF E4E0                <1> 	IN AL, 0XE0			;READ NUMBER OF BYTES FROM DATA PORT 
  1487 0000DC01 B400                <1> 	MOV AH, 0X00		;CLEAR AH
  1488 0000DC03 89C1                <1> 	MOV CX, AX			;SET CX TO NUMBER OF BYTES
  1489                              <1>   .READ_VBR_LOOP:		;LOOP LABLE
  1490 0000DC05 E4E0                <1> 	IN AL, 0XE0			;READ BYTE
  1491 0000DC07 8807                <1> 	MOV [BX], AL		;WRITE BYTE TO DS:BX
  1492 0000DC09 43                  <1> 	INC BX				;INC INDEX
  1493                              <1> 
  1494 0000DC0A E2F9                <1> 	LOOP .READ_VBR_LOOP	;LOOP UNTIL DONE
  1495                              <1> 	
  1496 0000DC0C B055                <1> 	MOV AL, 0X55		;DISK_RD_GO READ NEXT 64 BYTES
  1497 0000DC0E E6E4                <1> 	OUT 0XE4, AL		;OUT COMMAND PORT
  1498 0000DC10 EBD3                <1> 	JMP .READ_VBR_SECTOR	;LOOP UNTIL DONE
  1499                              <1> 
  1500                              <1> .READ_VBR_SUCCESS:
  1501 0000DC12 BBFE01              <1> 	MOV BX, 0X01FE			;END OF MBR
  1502 0000DC15 813F55AA            <1> 	CMP WORD [BX], 0XAA55	;BOOT SIGNATURE
  1503 0000DC19 7502                <1> 	JNE .NOT_BOOTABLE_VBR 	;IF BOOT SIGNATURE IS NOT THERE
  1504                              <1> 	
  1505 0000DC1B EB5A                <1> 	JMP .END_LOAD_BOOT_RECORD	
  1506                              <1> 	
  1507                              <1> .NOT_BOOTABLE_VBR:
  1508 0000DC1D 8CC8                <1> 	MOV AX, CS						;GET CS 
  1509 0000DC1F 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
  1510 0000DC21 B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
  1511 0000DC23 B91700              <1> 	MOV CX, .END_NOT_VBR_MESSAGE - .NOT_VBR_MESSAGE
  1512 0000DC26 BB[32DC]            <1> 	MOV BX, .NOT_VBR_MESSAGE	
  1513                              <1> 	.LOOP_NOT_VBR:
  1514 0000DC29 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
  1515 0000DC2B CD10                <1> 	INT 0X10						;PRINT TO SCREEN
  1516 0000DC2D 43                  <1> 	INC BX							;INC BX
  1517 0000DC2E E2F9                <1> 	LOOP .LOOP_NOT_VBR				;LOOP UNTIL DONE
  1518                              <1> 	
  1519 0000DC30 EB45                <1> 	JMP .END_LOAD_BOOT_RECORD
  1520                              <1> 
  1521                              <1> 	.NOT_VBR_MESSAGE:
  1522 0000DC32 4E4F20424F4F542053- <1> 	DB 'NO BOOT SIGNATURE VBR', 0X0D, 0X0A
  1522 0000DC3B 49474E415455524520- <1>
  1522 0000DC44 5642520D0A          <1>
  1523                              <1> 	.END_NOT_VBR_MESSAGE:
  1524                              <1> 
  1525                              <1> .NO_BOOTABLE_PARTITION:
  1526 0000DC49 8CC8                <1> 	MOV AX, CS						;GET CS 
  1527 0000DC4B 8ED8                <1> 	MOV DS, AX						;SET DS TO CS
  1528 0000DC4D B40E                <1> 	MOV AH, 0X0E					;FOR TELOTYPE
  1529 0000DC4F B91900              <1> 	MOV CX, .END_NO_BOOTABLE_PARTITION_MESSAGE - .NO_BOOTABLE_PARTITION_MESSAGE
  1530 0000DC52 BB[5EDC]            <1> 	MOV BX, .NO_BOOTABLE_PARTITION_MESSAGE	
  1531                              <1> 	.LOOP_NO_BOOT_PARTITION:
  1532 0000DC55 8A07                <1> 	MOV AL, [BX]					;GET BYTE 
  1533 0000DC57 CD10                <1> 	INT 0X10						;PRINT TO SCREEN
  1534 0000DC59 43                  <1> 	INC BX							;INC BX
  1535 0000DC5A E2F9                <1> 	LOOP .LOOP_NO_BOOT_PARTITION	;LOOP UNTIL DONE
  1536                              <1> 	
  1537 0000DC5C EB19                <1> 	JMP .END_LOAD_BOOT_RECORD
  1538                              <1> 
  1539                              <1> 	.NO_BOOTABLE_PARTITION_MESSAGE:
  1540 0000DC5E 4E4F20424F4F542050- <1> 	DB 'NO BOOT PARTITION FOUND', 0X0D, 0X0A
  1540 0000DC67 4152544954494F4E20- <1>
  1540 0000DC70 464F554E440D0A      <1>
  1541                              <1> 	.END_NO_BOOTABLE_PARTITION_MESSAGE:
  1542                              <1> 
  1543                              <1> .END_LOAD_BOOT_RECORD:
  1544 0000DC77 1F                  <1> 	POP DS	;RESTORE DS
  1545 0000DC78 59                  <1> 	POP CX	;RESTORE CX
  1546 0000DC79 5B                  <1> 	POP BX 	;RESTORE BX
  1547 0000DC7A 58                  <1> 	POP AX	;RESTORE AX
  1548 0000DC7B 9D                  <1> 	POPF	;RESTORE FLAGS
  1549 0000DC7C C3                  <1> 	RET		;RETURN NOT A INT
  1550                              <1> 
  1551                              <1> 
  1552                              <1> ; This is a cheat:  We put in the disc as the maximum specs we support, if anyone reads this vector
  1553                              <1> ; it assumes a 504Mb drive.  Given that even dirt-cheap bulk drives are multiple gigabytes and we ignore most of it
  1554                              <1> ; people using actual small drives may want to edit this to match the actual cylinder count.
  1555                              <1> ; Since this is just a passive storage in memory, unlike int 0x13, function 8, we can't just calculate it on the fly
  1556                              <1> ; unless we wanted to write it into RAM on boot.  We could locate it somewhere in the F0000 block but then we lose the
  1557                              <1> ; "doesn't need to reserve any RAM for housekeeping" factor
  1558                              <1> DISK_1_TABLE:
  1559 0000DC7D 0004                <1> 	dw MAX_CYL  ; Cylinders
  1560 0000DC7F 1000                <1> 	dw MAX_HPC  ; Heads
  1561 0000DC81 0000                <1> 	dw 0        ; Starts reduced write current cylinder
  1562 0000DC83 0000                <1> 	dw 0		; Write precomp cylinder number
  1563 0000DC85 00                  <1> 	db 0		; Max ECC Burst Length
  1564 0000DC86 40                  <1> 	db 40h		; Control byte: Disable ECC retries, leave access retries, drive step speed 3ms
  1565 0000DC87 00                  <1> 	db 0		; Standard Timeout
  1566 0000DC88 00                  <1> 	db 0		; Formatting Timeout
  1567 0000DC89 0000                <1> 	dw 0		; Landing Zone
  1568 0000DC8B 3F                  <1> 	db MAX_SPT	; Sectors per track
  1569 0000DC8C 00                  <1> 	db 0		; reserved
  1570                              <1> 
  1571                              <1> DISK_2_TABLE:
  1572 0000DC8D 0000                <1> 	dw 0		; Cylinders
  1573 0000DC8F 0000                <1> 	dw 0  		; Heads
  1574 0000DC91 0000                <1> 	dw 0        ; Starts reduced write current cylinder
  1575 0000DC93 0000                <1> 	dw 0		; Write precomp cylinder number
  1576 0000DC95 00                  <1> 	db 0		; Max ECC Burst Length
  1577 0000DC96 00                  <1> 	db 00h		; Control byte: Disable ECC retries, leave access retries, drive step speed 3ms
  1578 0000DC97 00                  <1> 	db 0		; Standard Timeout
  1579 0000DC98 00                  <1> 	db 0		; Formatting Timeout
  1580 0000DC99 0000                <1> 	dw 0		; Landing Zone
  1581 0000DC9B 00                  <1> 	db 0		; Sectors per track
  1582 0000DC9C 00                  <1> 	db 0		; reserved
  1583                              <1>     
   229                                  ;%include "DRVch376s2.asm"
   230                                  
   231                                  %include "screen.asm"
     1                              <1> 
     2 0000DC9D 1B5B324A00          <1> cls     db 0x1B,"[2J",0
     3 0000DCA2 1B5B213B214800      <1> curpos  db 0x1B,"[!;!H",0
     4                              <1> 
     5                              <1> ;=====================
     6                              <1> ; ESC [ 2 J
     7                              <1> ;
     8                              <1> scr_clear:
     9 0000DCA9 BE[9DDC]            <1>         mov	si, cls
    10 0000DCAC E86FF5              <1>         call    pstr	
    11 0000DCAF C3                  <1>         ret
    12                              <1> ;=====================
    13                              <1> ; ESC [ Pl ; Pc H
    14                              <1> ; input:
    15                              <1> ;	dh = y position
    16                              <1> ; 	dl = x position
    17                              <1> ; MARK: scr_goto
    18                              <1> scr_goto:
    19 0000DCB0 1E                  <1>         push DS
    20 0000DCB1 B80000              <1>         mov AX, 0x0
    21 0000DCB4 8ED8                <1>         mov DS, AX
    22 0000DCB6 89C3                <1>         mov bx, AX
    23 0000DCB8 3EC6071B            <1>         mov byte ds:[bx],0x1B
    24 0000DCBC 43                  <1>         inc bx
    25 0000DCBD 3EC6075B            <1>         mov byte ds:[bx],'['
    26 0000DCC1 43                  <1>         inc bx
    27 0000DCC2 3EC6070A            <1>         mov byte ds:[bx],10
    28 0000DCC6 43                  <1>         inc bx
    29 0000DCC7 3EC6073B            <1>         mov byte ds:[bx],';'
    30 0000DCCB 43                  <1>         inc bx
    31 0000DCCC 3EC6070A            <1>         mov byte ds:[bx],10
    32 0000DCD0 43                  <1>         inc bx
    33 0000DCD1 3EC60748            <1>         mov byte ds:[bx],'H'  
    34 0000DCD5 43                  <1>         inc bx
    35 0000DCD6 3EC60700            <1>         mov byte ds:[bx],0x0
    36                              <1> 
    37                              <1> 
    38 0000DCDA B80000              <1>         mov AX, 0x0
    39 0000DCDD 89C6                <1>         mov si, AX
    40 0000DCDF E83CF5              <1>         call pstr
    41 0000DCE2 1F                  <1>         POP DS
    42 0000DCE3 C3                  <1> 		ret
    43                              <1> 
    44 0000DCE4 666E30300D00        <1> s123 db "fn00",0dh,0
    45 0000DCEA 666E30310D00        <1> s124 db "fn01",0dh,0
    46 0000DCF0 666E30320D00        <1> s125 db "fn02",0dh,0
    47 0000DCF6 666E30330D00        <1> s126 db "fn03",0dh,0
    48 0000DCFC 666E30340D00        <1> s127 db "fn04",0dh,0
    49 0000DD02 666E30350D00        <1> s128 db "fn05",0dh,0
    50                              <1> 
    51                              <1> TESTE:
    52 0000DD08 E834F5              <1>         call cout
    53                              <1> 
    54 0000DD0B 3C30                <1>         cmp   al, '0'
    55 0000DD0D 7415                <1>         jz    .fn00
    56 0000DD0F 3C31                <1>         cmp   al, '1'
    57 0000DD11 7418                <1>         jz    .fn01
    58 0000DD13 3C32                <1>         cmp   al, '2'
    59 0000DD15 741B                <1>         jz    .fn02
    60 0000DD17 3C33                <1>         cmp   al, '3'
    61 0000DD19 741E                <1>         jz    .fn03
    62 0000DD1B 3C34                <1>         cmp   al, '4'
    63 0000DD1D 7421                <1>         jz    .fn04
    64 0000DD1F 3C35                <1>         cmp   al, '5'
    65 0000DD21 7424                <1>         jz    .fn05
    66 0000DD23 C3                  <1>         ret        
    67                              <1> 
    68                              <1> .fn00: 
    69 0000DD24 BE[E4DC]            <1>         mov  si, s123
    70 0000DD27 E8F4F4              <1>         call pstr
    71 0000DD2A C3                  <1>         ret
    72                              <1> .fn01: 
    73 0000DD2B BE[EADC]            <1>         mov  si, s124
    74 0000DD2E E8EDF4              <1>         call pstr
    75 0000DD31 C3                  <1>         ret        
    76                              <1> .fn02: 
    77 0000DD32 BE[F0DC]            <1>         mov  si, s125
    78 0000DD35 E8E6F4              <1>         call pstr
    79 0000DD38 C3                  <1>         ret
    80                              <1> .fn03: 
    81 0000DD39 BE[F6DC]            <1>         mov  si, s126
    82 0000DD3C E8DFF4              <1>         call pstr
    83 0000DD3F C3                  <1>         ret
    84                              <1> .fn04:   
    85 0000DD40 BE[FCDC]            <1>         mov  si, s127
    86 0000DD43 E8D8F4              <1>         call pstr
    87 0000DD46 C3                  <1>         ret
    88                              <1> .fn05: 
    89 0000DD47 BE[02DD]            <1>         mov  si, s128
    90 0000DD4A E8D1F4              <1>         call pstr
    91 0000DD4D C3                  <1>         ret
    92                              <1> 
    93                              <1>         
    94                              <1> 
    95                              <1> 
   232                                  %include "errorLed.asm"
     1                              <1> 
     2                              <1> ledblinkOk:
     3                              <1> .loop0:
     4                              <1>           
     5 0000DD4E B001                <1>                 mov     al, 0x01
     6 0000DD50 E680                <1>                 out     0x80, al
     7 0000DD52 B9FF3F              <1>                 mov     cx, 0x3fff
     8                              <1> .label01:
     9 0000DD55 49                  <1>                 dec     cx
    10 0000DD56 75FD                <1>                 jnz     .label01
    11 0000DD58 B000                <1>                 mov     al, 0x00
    12 0000DD5A E680                <1>                 out     0x80, al
    13 0000DD5C B9FF7F              <1>                 mov     cx, 0x7fff
    14                              <1> .label02:
    15 0000DD5F 49                  <1>                 dec     cx
    16 0000DD60 75FD                <1>                 jnz     .label02
    17 0000DD62 C3                  <1>                 ret      
    18                              <1> 
    19                              <1> led2blinks:
    20                              <1> .loop0:
    21 0000DD63 BB0300              <1>                 mov     bx, 3
    22                              <1> .loop:            
    23 0000DD66 B001                <1>                 mov     al, 0x01
    24 0000DD68 E680                <1>                 out     0x80, al
    25 0000DD6A B9FFFF              <1>                 mov     cx, 0xffff
    26                              <1> .label01:
    27 0000DD6D 49                  <1>                 dec     cx
    28 0000DD6E 75FD                <1>                 jnz     .label01
    29 0000DD70 B000                <1>                 mov     al, 0x00
    30 0000DD72 E680                <1>                 out     0x80, al
    31 0000DD74 B9FFFF              <1>                 mov     cx, 0xffff
    32                              <1> .label02:
    33 0000DD77 49                  <1>                 dec     cx
    34 0000DD78 75FD                <1>                 jnz     .label02
    35                              <1> 
    36 0000DD7A 4B                  <1>                 dec     bx
    37 0000DD7B 75E9                <1>                 jnz     .loop
    38                              <1> ;                mov     al, 0x01
    39                              <1> ;                out     0x80, al
    40                              <1>                 
    41 0000DD7D BB0500              <1>                 mov     bx, 5
    42                              <1> .longDelay:                
    43 0000DD80 B9FFFF              <1>                 mov     cx, 0xffff
    44                              <1> .labelLD:
    45 0000DD83 49                  <1>                 dec     cx
    46 0000DD84 75FD                <1>                 jnz     .labelLD
    47 0000DD86 4B                  <1>                 dec     bx
    48 0000DD87 75F7                <1>                 jnz     .longDelay
    49                              <1>                 ;mov     bx, 3 
    50 0000DD89 EBD8                <1>                 jmp     .loop0         
    51                              <1> 
    52                              <1> led3blinks:
    53                              <1> .loop0:
    54 0000DD8B BB0300              <1>                 mov     bx, 3
    55                              <1> .loop:            
    56 0000DD8E B001                <1>                 mov     al, 0x01
    57 0000DD90 E680                <1>                 out     0x80, al
    58 0000DD92 B9FFFF              <1>                 mov     cx, 0xffff
    59                              <1> .label01:
    60 0000DD95 49                  <1>                 dec     cx
    61 0000DD96 75FD                <1>                 jnz     .label01
    62 0000DD98 B000                <1>                 mov     al, 0x00
    63 0000DD9A E680                <1>                 out     0x80, al
    64 0000DD9C B9FFFF              <1>                 mov     cx, 0xffff
    65                              <1> .label02:
    66 0000DD9F 49                  <1>                 dec     cx
    67 0000DDA0 75FD                <1>                 jnz     .label02
    68                              <1> 
    69 0000DDA2 4B                  <1>                 dec     bx
    70 0000DDA3 75E9                <1>                 jnz     .loop
    71                              <1> ;                mov     al, 0x01
    72                              <1> ;                out     0x80, al
    73                              <1>                 
    74 0000DDA5 BB0500              <1>                 mov     bx, 5
    75                              <1> .longDelay:                
    76 0000DDA8 B9FFFF              <1>                 mov     cx, 0xffff
    77                              <1> .labelLD:
    78 0000DDAB 49                  <1>                 dec     cx
    79 0000DDAC 75FD                <1>                 jnz     .labelLD
    80 0000DDAE 4B                  <1>                 dec     bx
    81 0000DDAF 75F7                <1>                 jnz     .longDelay
    82                              <1>                 ;mov     bx, 3 
    83 0000DDB1 EBD8                <1>                 jmp     .loop0         
    84                              <1> 
    85                              <1> led4blinks:
    86                              <1> .loop0:
    87 0000DDB3 BB0400              <1>                 mov     bx, 4
    88                              <1> .loop:            
    89 0000DDB6 B001                <1>                 mov     al, 0x01
    90 0000DDB8 E680                <1>                 out     0x80, al
    91 0000DDBA B9FFFF              <1>                 mov     cx, 0xffff
    92                              <1> .label01:
    93 0000DDBD 49                  <1>                 dec     cx
    94 0000DDBE 75FD                <1>                 jnz     .label01
    95 0000DDC0 B000                <1>                 mov     al, 0x00
    96 0000DDC2 E680                <1>                 out     0x80, al
    97 0000DDC4 B9FFFF              <1>                 mov     cx, 0xffff
    98                              <1> .label02:
    99 0000DDC7 49                  <1>                 dec     cx
   100 0000DDC8 75FD                <1>                 jnz     .label02
   101                              <1> 
   102 0000DDCA 4B                  <1>                 dec     bx
   103 0000DDCB 75E9                <1>                 jnz     .loop
   104                              <1> ;                mov     al, 0x01
   105                              <1> ;                out     0x80, al
   106                              <1>                 
   107 0000DDCD BB0500              <1>                 mov     bx, 5
   108                              <1> .longDelay:                
   109 0000DDD0 B9FFFF              <1>                 mov     cx, 0xffff
   110                              <1> .labelLD:
   111 0000DDD3 49                  <1>                 dec     cx
   112 0000DDD4 75FD                <1>                 jnz     .labelLD
   113 0000DDD6 4B                  <1>                 dec     bx
   114 0000DDD7 75F7                <1>                 jnz     .longDelay
   115                              <1>                 ;mov     bx, 3 
   116 0000DDD9 EBD8                <1>                 jmp     .loop0         
   233                                  %include "testSram.asm"
     1                              <1> ;-------------------------------------------------------------------------
     2                              <1> %define MIN_RAM_SIZE    64              ; At least 32 KiB to boot the system
     3 0000DDDB 0D0A54657374696E67- <1> testMem:        db      0Dh,0Ah,"Testing memory:",0Dh , 0
     3 0000DDE4 206D656D6F72793A0D- <1>
     3 0000DDED 00                  <1>
     4 0000DDEE 0D0A31303030302074- <1> bloco01:        db      0Dh,0Ah,"10000 to 1FFFF", 0     ;128k
     4 0000DDF7 6F20314646464600    <1>
     5 0000DDFF 0D0A32303030302074- <1> bloco02:        db      0Dh,0Ah,"20000 to 2FFFF", 0     ;192k
     5 0000DE08 6F20324646464600    <1>
     6 0000DE10 0D0A33303030302074- <1> bloco03:        db      0Dh,0Ah,"30000 to 3FFFF", 0     ;256k
     6 0000DE19 6F20334646464600    <1>
     7 0000DE21 0D0A34303030302074- <1> bloco04:        db      0Dh,0Ah,"40000 to 4FFFF", 0     ;320k
     7 0000DE2A 6F20344646464600    <1>
     8 0000DE32 0D0A35303030302074- <1> bloco05:        db      0Dh,0Ah,"50000 to 5FFFF", 0     ;384k
     8 0000DE3B 6F20354646464600    <1>
     9 0000DE43 0D0A36303030302074- <1> bloco06:        db      0Dh,0Ah,"60000 to 6FFFF", 0     ;448k
     9 0000DE4C 6F20364646464600    <1>
    10 0000DE54 0D0A37303030302074- <1> bloco07:        db      0Dh,0Ah,"70000 to 7FFFF", 0     ;512k
    10 0000DE5D 6F20374646464600    <1>
    11 0000DE65 207365676D656E7420- <1> blocoOK:        db      " segment OK",0
    11 0000DE6E 4F4B00              <1>
    12 0000DE71 207365676D656E7420- <1> blocoNOK:       db      " segment NOT exists", 0Dh, 0Ah,0
    12 0000DE7A 4E4F54206578697374- <1>
    12 0000DE83 730D0A00            <1>
    13 0000DE87 0D0A546F74616C206F- <1> totalMem:       db      0Dh,0Ah,"Total of memory: ",0
    13 0000DE90 66206D656D6F72793A- <1>
    13 0000DE99 2000                <1>
    14 0000DE9B 3036342E303030204B- <1> qtdMem0:        db      "064.000 KBytes.", 0Dh, 0Ah, 0
    14 0000DEA4 42797465732E0D0A00  <1>
    15 0000DEAD 3133312E303732204B- <1> qtdMem1:        db      "131.072 KBytes.", 0Dh, 0Ah, 0
    15 0000DEB6 42797465732E0D0A00  <1>
    16 0000DEBF 3139362E363038204B- <1> qtdMem2:        db      "196.608 KBytes.", 0Dh, 0Ah, 0
    16 0000DEC8 42797465732E0D0A00  <1>
    17 0000DED1 3236322E313434204B- <1> qtdMem3:        db      "262.144 KBytes.", 0Dh, 0Ah, 0
    17 0000DEDA 42797465732E0D0A00  <1>
    18 0000DEE3 3332372E363830204B- <1> qtdMem4:        db      "327.680 KBytes.", 0Dh, 0Ah, 0
    18 0000DEEC 42797465732E0D0A00  <1>
    19 0000DEF5 3339332E323136204B- <1> qtdMem5:        db      "393.216 KBytes.", 0Dh, 0Ah, 0
    19 0000DEFE 42797465732E0D0A00  <1>
    20 0000DF07 3435382E373532204B- <1> qtdMem6:        db      "458.752 KBytes.", 0Dh, 0Ah, 0
    20 0000DF10 42797465732E0D0A00  <1>
    21 0000DF19 3532342E323838204B- <1> qtdMem7:        db      "524.288 KBytes.", 0Dh, 0Ah, 0
    21 0000DF22 42797465732E0D0A00  <1>
    22                              <1> 
    23                              <1> 
    24                              <1> ;-------------------------------------------------------------------------
    25                              <1> ; Test first 64 KiB (MIN_RAM_SIZE) of RAM
    26                              <1> testFirst64kb:
    27                              <1> 	;mov	al,e_low_ram_test
    28                              <1> 	;out	post_reg,al
    29 0000DF2B 31F6                <1> 	xor	si,si
    30 0000DF2D 31FF                <1> 	xor	di,di
    31 0000DF2F 8EDF                <1> 	mov	ds,di
    32 0000DF31 8EC7                <1> 	mov	es,di
    33                              <1> 
    34                              <1> ;Inicio da carga do valor de AX
    35 0000DF33 B8AA55              <1> 	mov	ax,55AAh		; first test pattern
    36 0000DF36 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    37 0000DF39 F3AB                <1>     rep	stosw				; store test pattern
    38                              <1> ;Fim da carga do valor de AX        
    39                              <1> ;inicio da comparação    
    40                              <1> ;lodsw CX=total repetição, SI=Endereço a ser lido AX recebe o dado
    41 0000DF3B B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    42                              <1> .1:
    43 0000DF3E AD                  <1> 	lodsw
    44 0000DF3F 3DAA55              <1> 	cmp	ax,55AAh		; compare to the test pattern
    45 0000DF42 7524                <1> 	jne	low_ram_fail
    46 0000DF44 E2F8                <1> 	loop	.1
    47                              <1> ;Fim da comparação        
    48 0000DF46 31F6                <1> 	xor	si,si
    49 0000DF48 31FF                <1> 	xor	di,di
    50 0000DF4A B855AA              <1> 	mov	ax,0AA55h		; second test pattern
    51 0000DF4D B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    52 0000DF50 F3AB                <1>     rep stosw				; store test pattern
    53 0000DF52 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    54                              <1> .2:
    55 0000DF55 AD                  <1> 	lodsw
    56 0000DF56 3D55AA              <1> 	cmp	ax,0AA55h		; compare to the test pattern
    57 0000DF59 750D                <1> 	jne	low_ram_fail
    58 0000DF5B E2F8                <1> 	loop	.2
    59 0000DF5D 31FF                <1> 	xor	di,di
    60 0000DF5F 31C0                <1> 	xor	ax,ax			; zero
    61 0000DF61 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    62 0000DF64 F3AB                <1>     rep stosw				; zero the memory
    63 0000DF66 EB03                <1> 	jmp	low_ram_ok		; test passed
    64                              <1> 
    65                              <1> low_ram_fail:
    66                              <1> 	;mov	al,e_low_ram_fail	; test failed
    67                              <1> 	;out	post_reg,al
    68 0000DF68 E9F8FD              <1>     jmp     led2blinks
    69                              <1> 
    70                              <1> ;-------------------------------------------------------------------------
    71                              <1> ;-------------------------------------------------------------------------
    72                              <1> ; Low memory test passed
    73                              <1> 
    74                              <1> low_ram_ok:
    75 0000DF6B BB0104              <1>         mov     bx, 0x401
    76 0000DF6E 3E8807              <1>         mov     byte ds:[bx], al
    77 0000DF71 E9EBF0              <1>         jmp     initBios
    78                              <1> 
    79                              <1> ;-------------------------------------------------------------------------
    80                              <1> ; Test of 64k bytes of memory
    81                              <1> ; Reg ds = segment to test
    82                              <1> ;	  es = segment to test
    83                              <1> ;
    84                              <1> test64kb:
    85                              <1> 	;mov	al,e_low_ram_test
    86                              <1> 	;out	post_reg,al
    87 0000DF74 31F6                <1> 	xor	si,si
    88 0000DF76 31FF                <1> 	xor	di,di
    89                              <1> 
    90                              <1> ;Inicio da carga do valor de AX
    91 0000DF78 B8AA55              <1> 	mov	ax,55AAh		; first test pattern
    92 0000DF7B B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    93 0000DF7E F3AB                <1>     rep	stosw				; store test pattern
    94                              <1> ;Fim da carga do valor de AX        
    95                              <1> ;inicio da comparação    
    96                              <1> ;lodsw CX=total repetição, SI=Endereço a ser lido AX recebe o dado
    97 0000DF80 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
    98                              <1> .1:
    99 0000DF83 AD                  <1> 	lodsw
   100 0000DF84 3DAA55              <1> 	cmp	ax,55AAh		; compare to the test pattern
   101 0000DF87 7524                <1> 	jne	low_ram_fail1
   102 0000DF89 E2F8                <1> 	loop	.1
   103                              <1> ;Fim da comparação        
   104 0000DF8B 31F6                <1> 	xor	si,si
   105 0000DF8D 31FF                <1> 	xor	di,di
   106 0000DF8F B855AA              <1> 	mov	ax,0AA55h		; second test pattern
   107 0000DF92 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   108 0000DF95 F3AB                <1>     rep stosw				; store test pattern
   109 0000DF97 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   110                              <1> .2:
   111 0000DF9A AD                  <1> 	lodsw
   112 0000DF9B 3D55AA              <1> 	cmp	ax,0AA55h		; compare to the test pattern
   113 0000DF9E 750D                <1> 	jne	low_ram_fail1
   114 0000DFA0 E2F8                <1> 	loop	.2
   115 0000DFA2 31FF                <1> 	xor	di,di
   116 0000DFA4 31C0                <1> 	xor	ax,ax			; zero
   117 0000DFA6 B90080              <1> 	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   118 0000DFA9 F3AB                <1>     rep stosw				; zero the memory
   119 0000DFAB EB02                <1> 	jmp	ram_ok		; test passed
   120                              <1> low_ram_fail1:
   121 0000DFAD F9                  <1> 	STC 
   122 0000DFAE C3                  <1> 	ret
   123                              <1> ;-------------------------------------------------------------------------
   124                              <1> ;-------------------------------------------------------------------------
   125                              <1> ; Low memory test passed
   126                              <1> 
   127                              <1> ram_ok:
   128                              <1> ;        mov ax, 0xF000
   129                              <1> ;        mov ds, ax
   130                              <1> ;        mov  bx, blocoOK
   131                              <1> ;        call print2
   132                              <1> 
   133 0000DFAF BB0104              <1>         mov     bx, 0x401
   134 0000DFB2 3E8807              <1>         mov     byte ds:[bx], al
   135 0000DFB5 F8                  <1> 		CLC
   136 0000DFB6 C3                  <1>         ret
   137                              <1> ;I know it could be better but I'm lazy and besides 
   138                              <1> ;I have a lot of flash memory so don't criticize me
   139                              <1> 
   140                              <1> memoryTest:
   141 0000DFB7 1E                  <1> 		push DS
   142 0000DFB8 B80000              <1> 		mov	 ax,0x0
   143 0000DFBB 8EC0                <1> 		mov  es, ax
   144 0000DFBD B000                <1> 		mov  al,0
   145 0000DFBF 26A20104            <1> 		mov  byte es:[flagMemOk], al
   146 0000DFC3 BE[DBDD]            <1> 		mov  si, testMem
   147 0000DFC6 E855F2              <1> 		call pstr
   148                              <1> 
   149                              <1> 		;Block 1 64K
   150 0000DFC9 BE[EEDD]            <1> 		mov  si, bloco01
   151 0000DFCC E84FF2              <1> 		call pstr
   152 0000DFCF B80010              <1> 		mov  ax, 0x1000
   153 0000DFD2 8ED8                <1> 		mov  ds, ax
   154 0000DFD4 8EC0                <1> 		mov  es, ax
   155 0000DFD6 E89BFF              <1> 		call test64kb
   156 0000DFD9 726A                <1> 		jc	 memoryTestEnd
   157 0000DFDB E89400              <1> 		call segmentOK
   158 0000DFDE B80000              <1> 		mov	 ax,0x0
   159 0000DFE1 8EC0                <1> 		mov  es, ax
   160 0000DFE3 26FE060104          <1> 		inc byte es:[flagMemOk]
   161                              <1> 
   162                              <1> 		;Block 2 64K
   163 0000DFE8 BE[FFDD]            <1> 		mov  si, bloco02
   164 0000DFEB E830F2              <1> 		call pstr
   165 0000DFEE B80020              <1> 		mov  ax, 0x2000
   166 0000DFF1 8ED8                <1> 		mov  ds, ax
   167 0000DFF3 8EC0                <1> 		mov  es, ax
   168 0000DFF5 E87CFF              <1> 		call    test64kb
   169 0000DFF8 724B                <1> 		jc	memoryTestEnd
   170 0000DFFA E87500              <1> 		call segmentOK
   171 0000DFFD B80000              <1> 		mov	 ax,0x0
   172 0000E000 8EC0                <1> 		mov  es, ax
   173 0000E002 26FE060104          <1> 		inc byte es:[flagMemOk]
   174                              <1> 
   175                              <1> 		;Block 3 64K
   176 0000E007 BE[10DE]            <1> 		mov  si, bloco03
   177 0000E00A E811F2              <1> 		call pstr
   178 0000E00D B80030              <1> 		mov  ax, 0x3000
   179 0000E010 8ED8                <1> 		mov  ds, ax
   180 0000E012 8EC0                <1> 		mov  es, ax
   181 0000E014 E85DFF              <1> 		call    test64kb
   182 0000E017 722C                <1> 		jc	memoryTestEnd
   183 0000E019 E85600              <1> 		call segmentOK
   184 0000E01C B80000              <1> 		mov	 ax,0x0
   185 0000E01F 8EC0                <1> 		mov  es, ax
   186 0000E021 26FE060104          <1> 		inc byte es:[flagMemOk]
   187                              <1> 
   188 0000E026 BE[10DE]            <1> 		mov  si, bloco03
   189 0000E029 E8F2F1              <1> 		call pstr
   190 0000E02C B80030              <1> 		mov  ax, 0x3000
   191 0000E02F 8ED8                <1> 		mov  ds, ax
   192 0000E031 8EC0                <1> 		mov  es, ax
   193 0000E033 E83EFF              <1> 		call    test64kb
   194 0000E036 720D                <1> 		jc	memoryTestEnd
   195 0000E038 E83700              <1> 		call segmentOK
   196 0000E03B B80000              <1> 		mov	 ax,0x0
   197 0000E03E 8EC0                <1> 		mov  es, ax
   198 0000E040 26FE060104          <1> 		inc byte es:[flagMemOk]
   199                              <1> 
   200                              <1> memoryTestEnd:
   201 0000E045 1F                  <1> 		pop  	ds
   202 0000E046 B80000              <1> 		mov 	ax, 0x0
   203 0000E049 8EC0                <1> 		mov 	es, ax
   204                              <1> 
   205 0000E04B 26A00104            <1> 		mov		al, byte es:[flagMemOk]
   206 0000E04F 3C07                <1> 		cmp		al, 7
   207 0000E051 7406                <1> 		jz      onlyTotal
   208                              <1> 
   209 0000E053 BE[71DE]            <1> 		mov		si, blocoNOK
   210 0000E056 E8C5F1              <1> 		call	pstr
   211                              <1> onlyTotal:		
   212                              <1> 
   213 0000E059 BE[87DE]            <1> 		mov		si, totalMem
   214 0000E05C E8BFF1              <1> 		call	pstr
   215 0000E05F B81200              <1> 		mov     ax, 18
   216 0000E062 268A0E0104          <1> 		mov		cl, byte es:[flagMemOk]
   217 0000E067 F6E1                <1> 		mul		cl
   218                              <1> 		;call	print_hex
   219 0000E069 BE[9BDE]            <1> 		mov		si, qtdMem0
   220 0000E06C 01C6                <1> 		add		si, ax
   221 0000E06E E8ADF1              <1> 		call 	pstr
   222                              <1> 
   223 0000E071 C3                  <1> 		ret
   224                              <1> 	
   225                              <1> 
   226                              <1> segmentOK:
   227 0000E072 B800F0              <1>         mov		ax, 0xF000
   228 0000E075 8ED8                <1>         mov		ds, ax
   229 0000E077 BE[65DE]            <1>         mov		si, blocoOK
   230 0000E07A E8A1F1              <1>         call	pstr
   231 0000E07D C3                  <1> 		ret
   232                              <1> 
   233                              <1> ;-------------------------------------------------------------------------
   234                              <1> ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
   235                              <1> beep:
   236                              <1> ;	mov	al,0B6h
   237                              <1> ;	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   238                              <1> ;	mov	ax,pic_freq/400		; 400 Hz signal
   239                              <1> ;	out	pit_ch2_reg,al
   240                              <1> ;	mov	al,ah
   241                              <1> ;	out	pit_ch2_reg,al
   242                              <1> ;	in	al,ppi_pb_reg
   243                              <1> ;.1:
   244                              <1> ;	or	al,3			; turn speaker on and enable
   245                              <1> ;	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   246                              <1> ;	mov	cx,0
   247                              <1> ;.2:
   248                              <1> ;	nop
   249                              <1> ;	loop	.2
   250                              <1> ;	and	al,0FCh			; turn of speaker
   251                              <1> ;	out	ppi_pb_reg,al
   252                              <1> ;	mov	cx,0
   253                              <1> ;.3:
   254                              <1> ;	nop
   255                              <1> ;	loop	.3
   256                              <1> ;	jmp	.1
   234                                  %include "mprintRegs.asm"
     1                              <1> 	CPU 8086
     2                              <1> ;=========================================================================
     3                              <1> ; print_hex - print 16-bit number in hexadecimal
     4                              <1> ; Input:
     5                              <1> ;	AX - number to print
     6                              <1> ; Output:
     7                              <1> ;	none
     8                              <1> ;-------------------------------------------------------------------------
     9                              <1> printw_hex:
    10                              <1> print_hex:
    11 0000E07E 50                  <1>     push    AX
    12 0000E07F 86C4                <1> 	xchg	al,ah
    13 0000E081 E82100              <1> 	call	print_byte		; print the upper byte
    14 0000E084 86C4                <1> 	xchg	al,ah
    15 0000E086 E81C00              <1> 	call	print_byte		; print the lower byte
    16 0000E089 58                  <1>     pop     AX
    17 0000E08A C3                  <1> 	ret
    18                              <1> ;=========================================================================
    19                              <1> ; printb_hex - print 8-bit number in hexadecimal
    20                              <1> ; Input:
    21                              <1> ;	AL - number to print
    22                              <1> ; Output:
    23                              <1> ;	none
    24                              <1> ;-------------------------------------------------------------------------
    25                              <1> printb_hex:
    26 0000E08B 50                  <1>     push    AX
    27 0000E08C E81600              <1> 	call	print_byte		; print the upper byte
    28 0000E08F 58                  <1> 	pop		AX
    29 0000E090 C3                  <1> 	ret
    30                              <1> ;=========================================================================
    31                              <1> ; print_digit - print hexadecimal digit
    32                              <1> ; Input:
    33                              <1> ;	AL - bits 3...0 - digit to print (0...F)
    34                              <1> ; Output:
    35                              <1> ;	none
    36                              <1> ;-------------------------------------------------------------------------
    37                              <1> print_digit:
    38 0000E091 50                  <1> 	push	ax
    39 0000E092 53                  <1> 	push	bx
    40 0000E093 52                  <1> 	push	dx
    41 0000E094 240F                <1> 	and	al,0Fh
    42 0000E096 0430                <1> 	add	al,'0'			; convert to ASCII
    43 0000E098 3C39                <1> 	cmp	al,'9'			; less or equal 9?
    44 0000E09A 7602                <1> 	jna	.1
    45 0000E09C 0407                <1> 	add	al,'A'-'9'-1		; a hex digit
    46                              <1> .1:
    47 0000E09E E89EF1              <1>     call    cout
    48 0000E0A1 5A                  <1> 	pop	dx
    49 0000E0A2 5B                  <1> 	pop	bx
    50 0000E0A3 58                  <1> 	pop	ax
    51 0000E0A4 C3                  <1> 	ret
    52                              <1> ;=========================================================================
    53                              <1> ; print_byte - print a byte in hexadecimal
    54                              <1> ; Input:
    55                              <1> ;	AL - byte to print
    56                              <1> ; Output:
    57                              <1> ;	none
    58                              <1> ;-------------------------------------------------------------------------
    59                              <1> print_byte:
    60 0000E0A5 D0C0                <1> 	rol	al,1
    61 0000E0A7 D0C0                <1> 	rol	al,1
    62 0000E0A9 D0C0                <1> 	rol	al,1
    63 0000E0AB D0C0                <1> 	rol	al,1
    64 0000E0AD E8E1FF              <1> 	call	print_digit
    65 0000E0B0 D0C0                <1> 	rol	al,1
    66 0000E0B2 D0C0                <1> 	rol	al,1
    67 0000E0B4 D0C0                <1> 	rol	al,1
    68 0000E0B6 D0C0                <1> 	rol	al,1
    69 0000E0B8 E8D6FF              <1> 	call	print_digit
    70 0000E0BB C3                  <1> 	ret
    71                              <1> ;=========================================================================
    72                              <1> ;byte_to_hex_str
    73                              <1> ;This function return in AX the ascii code for hexadecimal number from 0 to F
    74                              <1> ;Parameters:
    75                              <1> ;               AL = imput
    76                              <1> ;               AX = output
    77                              <1> ;This routines expands the data 1 byte returns 2 bytes
    78                              <1> ;Ex.: 0xA5 returns 4135 41 = 'A' 35 = '5' 
    79                              <1> ;
    80                              <1> ;Changes CL
    81                              <1> byte_to_hex_str:
    82 0000E0BC 51                  <1>         PUSH CX
    83 0000E0BD 88C4                <1>         mov ah, al
    84 0000E0BF B104                <1>         mov cl, 4
    85 0000E0C1 D2E8                <1>         shr al, cl
    86 0000E0C3 250F0F              <1>         and ax, 0x0f0f
    87 0000E0C6 3C09                <1>         cmp al, 0x09
    88 0000E0C8 7602                <1>         jbe .11
    89 0000E0CA 0407                <1>         add al, 'A' - '0' - 10
    90                              <1> .11:
    91 0000E0CC 80FC09              <1>         cmp ah, 0x09
    92 0000E0CF 7603                <1>         jbe .22
    93 0000E0D1 80C407              <1>         add ah, 'A' - '0' - 10
    94                              <1> .22:
    95 0000E0D4 053030              <1>         add ax, "00"
    96                              <1> .ret:
    97 0000E0D7 59                  <1>         POP CX
    98 0000E0D8 C3                  <1>         ret
    99                              <1> 
   100                              <1> ;==========================================================================
   101                              <1> ;hex_str_to_hex
   102                              <1> ;Parameters: DX = data to be converted
   103                              <1> ;            bh = return data
   104                              <1> ;
   105                              <1> ;This routines compress the data 2 bytes returns 1 byte
   106                              <1> ;Ex.: A5 in memory 41 35 41 = 'A' 35 = '5' returns 0xA5  A=1010 and 5 = 0101 
   107                              <1> ;
   108                              <1> ;A crude and simple implementation is to split 
   109                              <1> ;the byte into two nibbles and then use each 
   110                              <1> ;nibble as an index into a hex character "table".
   111                              <1> ; cdecl calling convention (google if you're not familiar with)
   112 0000E0D9 000102030405060708- <1> HEX_CHARSET		db 0,1,2,3,4,5,6,7,8,9,0xA,0xB,0xC,0xD,0xE,0xF
   112 0000E0E2 090A0B0C0D0E0F      <1>
   113                              <1> 
   114                              <1> ; void byteToHex(byte val, char* buffer)
   115                              <1> hex_str_to_hex:
   116                              <1>     ; nibble 1
   117 0000E0E9 31DB                <1> 	xor		BX, BX
   118 0000E0EB 89D0                <1>     mov 	ax,	dx
   119 0000E0ED E81700              <1> 	call	getNibble
   120 0000E0F0 D0E4                <1> 	shl		ah, 1
   121 0000E0F2 D0E4                <1> 	shl		ah, 1
   122 0000E0F4 D0E4                <1> 	shl		ah, 1
   123 0000E0F6 D0E4                <1> 	shl		ah, 1
   124 0000E0F8 88E7                <1> 	mov		bh, ah
   125                              <1>     ; nibble 2
   126 0000E0FA 89D0                <1>     mov 	ax,	dx
   127 0000E0FC 88C4                <1> 	mov		ah, al
   128 0000E0FE E80600              <1> 	call	getNibble
   129 0000E101 80E40F              <1> 	and		ah, 0x0F
   130 0000E104 08E7                <1> 	or		bh, ah
   131 0000E106 C3                  <1> 	ret
   132                              <1> 		
   133                              <1> getNibble:	
   134 0000E107 80FC41              <1> 	cmp ah, 0x41
   135 0000E10A 7D04                <1> 	jge getHexSuperior
   136 0000E10C 80EC30              <1> 	sub ah, 0x30
   137 0000E10F C3                  <1> 	ret
   138                              <1> getHexSuperior:
   139 0000E110 80EC37              <1> 	sub ah, 0x37
   140 0000E113 C3                  <1> 	ret
   141                              <1> 
   142                              <1> ;=======================================================	
   143                              <1> ;nibbleToHex
   144                              <1> ;Parameters AX = data to be converted
   145                              <1> ;Return data in AL
   146                              <1> nibbleToHex:
   147 0000E114 83E00F              <1> 	and AX, 0Fh ; 
   148 0000E117 3E8D36[D9E0]        <1> 	lea si, ds:[HEX_CHARSET]
   149 0000E11C 01C6                <1> 	add si, ax
   150 0000E11E AC                  <1> 	lodsb
   151 0000E11F C3                  <1> 	ret
   152                              <1> 
   153                              <1> 
   154                              <1> convertByteToHex:
   155 0000E120 52                  <1> 	push	DX
   156 0000E121 53                  <1> 	push	BX
   157 0000E122 268A360F05          <1> 	mov		dh, byte es:[buff_read]
   158 0000E127 268A161005          <1> 	mov		dl, byte es:[buff_read+1]
   159 0000E12C E8BAFF              <1> 	call	hex_str_to_hex
   160 0000E12F 26883E8F05          <1> 	mov		byte es:[buff_write], bh
   161 0000E134 5B                  <1> 	pop		BX
   162 0000E135 5A                  <1> 	pop		DX
   163 0000E136 C3                  <1> 	ret
   164                              <1> 
   165                              <1> convertWordToHex:
   166 0000E137 52                  <1> 	push	DX
   167 0000E138 53                  <1> 	push	BX
   168 0000E139 268A360F05          <1> 	mov		dh, byte es:[buff_read]
   169 0000E13E 268A161005          <1> 	mov		dl, byte es:[buff_read+1]
   170 0000E143 E8A3FF              <1> 	call	hex_str_to_hex
   171 0000E146 26883E8F05          <1> 	mov		byte es:[buff_write], bh
   172 0000E14B 268A361105          <1> 	mov		dh, byte es:[buff_read+2]
   173 0000E150 268A161205          <1> 	mov		dl, byte es:[buff_read+3]
   174 0000E155 E891FF              <1> 	call	hex_str_to_hex
   175 0000E158 26883E9005          <1> 	mov		byte es:[buff_write+1], bh
   176 0000E15D 5B                  <1> 	pop		BX
   177 0000E15E 5A                  <1> 	pop		DX
   178 0000E15F C3                  <1> 	ret
   179                              <1> 
   180                              <1> ;==============================================================================
   181                              <1> ;to_hex
   182                              <1> ; convert ASCII letter to one nibble 0-F
   183                              <1> ; 0-9 -> al-30
   184                              <1> ; A-F -> al-7
   185                              <1> ; entry: al
   186                              <1> ; exit: al
   187                              <1> 
   188                              <1> to_hex:  
   189 0000E160 2C30                <1> 		sub al,	"0"
   190 0000E162 3C0A                <1> 		cmp al,	10
   191 0000E164 7C04                <1> 		jl 	zero_nine
   192 0000E166 24DF                <1> 		and al,	11011111b
   193 0000E168 2C07                <1> 		sub al,	7
   194                              <1> zero_nine: 
   195 0000E16A C3                  <1> 		ret
   196                              <1> 
   197                              <1> ; convert ASCII to 16-bit hex number
   198                              <1> ; entry: string in inline buffer
   199                              <1> ; exit: ax
   200                              <1> 
   201                              <1> atohex:
   202 0000E16B E8C9FF              <1> 		call	convertWordToHex
   203 0000E16E 26A18F05            <1> 		mov		AX, word es:[buff_write]
   204 0000E172 C3                  <1> 		ret
   235                                  %include "mHardwareInit.asm"
     1                              <1>         CPU 8086
     2                              <1>         BITS 16
     3                              <1> 
     4                              <1> 
     5                              <1> init_system:
     6                              <1> 
     7 0000E173 E80500              <1>         call pic_init
     8                              <1>  
     9 0000E176 E83900              <1>         call pit_init
    10                              <1> 
    11 0000E179 FB                  <1>         sti
    12 0000E17A C3                  <1>         ret
    13                              <1> 
    14                              <1> 
    15                              <1> 
    16                              <1> 
   236                                  %include "mpic8259A.asm"
     1                              <1>         CPU 8086
     2                              <1>         BITS 16
     3                              <1> 
     4                              <1>         
     5                              <1> ;--------------------------------------
     6                              <1> ; PIC (8259)
     7                              <1> ;--------------------------------------
     8                              <1> PIC_REG_0           EQU     0x20
     9                              <1> PIC_REG_1           EQU     0x21
    10                              <1> PIC_ISR             EQU     0x20
    11                              <1> PIC_IRR             EQU     0x20
    12                              <1> PIC_IMR             EQU     0x21
    13                              <1> PIC_INT_VEC         EQU     0x08
    14                              <1> 
    15                              <1> ;PIC_INIT        db 0Dh,0Ah,"pc_init: init",0Dh, 0
    16                              <1> ;INIT_IRQ        db 0Dh,0Ah,"pic_enable_ir: init",0Dh, 0
    17                              <1> ;INT_VECT        db 0Dh,0Ah,"set_int_vector: init",0Dh, 0
    18                              <1> 
    19                              <1> ;--------------------------------------
    20                              <1> ; void pic_init(void)
    21                              <1> ;--------------------------------------
    22                              <1> pic_init:
    23                              <1>         ;mov     si, PIC_INIT 
    24                              <1>         ;call    pstr
    25 0000E17B 9C                  <1>         pushf
    26 0000E17C FA                  <1>         cli
    27 0000E17D B017                <1>         mov al, 0b00010111      ; ICW1
    28 0000E17F E620                <1>         out PIC_REG_0, al
    29 0000E181 B008                <1>         mov al, (PIC_INT_VEC & 0b11111000)  ; ICW2
    30 0000E183 E621                <1>         out PIC_REG_1, al
    31                              <1>         ;Precisa de codigo para informar ao 8259 o termino da interrupção
    32                              <1>         ;mov al, 0b00000001      ; ICW4
    33                              <1>         ;Não precisa de codigo para informar ao 8259 o termino da interrupção
    34 0000E185 B003                <1>         mov al, 0b00000011      ; ICW4
    35 0000E187 E621                <1>         out PIC_REG_1, al
    36                              <1> 
    37 0000E189 B0FF                <1>         mov al, 0b11111111      ; mask all interrupts
    38 0000E18B E621                <1>         out PIC_IMR, al
    39                              <1> 
    40 0000E18D B008                <1>         mov al, 0b00001000
    41 0000E18F E620                <1>         out PIC_REG_0, al
    42                              <1> 
    43 0000E191 9D                  <1>         popf
    44 0000E192 C3                  <1>         ret
    45                              <1> 
    46                              <1> ;--------------------------------------
    47                              <1> ; void pic_disable_ir(uint8_t irNo)
    48                              <1> ;--------------------------------------
    49                              <1> pic_disable_ir:
    50 0000E193 9C                  <1>         pushf
    51 0000E194 FA                  <1>         cli
    52                              <1> 
    53 0000E195 89E3                <1>         mov bx, sp
    54 0000E197 B108                <1>         mov cl, 8 ;[bx + 2]
    55 0000E199 80E107              <1>         and cl, 0b00000111
    56 0000E19C B401                <1>         mov ah, 1
    57 0000E19E D2E4                <1>         shl ah, cl
    58 0000E1A0 E421                <1>         in al, PIC_IMR
    59 0000E1A2 08E0                <1>         or al, ah
    60 0000E1A4 E621                <1>         out PIC_IMR, al
    61                              <1> 
    62 0000E1A6 9D                  <1>         popf
    63 0000E1A7 C3                  <1>         ret
    64                              <1> 
    65                              <1> ;--------------------------------------
    66                              <1> ; void pic_enable_ir(uint8_t irNo)
    67                              <1> ;--------------------------------------
    68                              <1> pic_enable_ir:
    69                              <1>         ;mov     si, INIT_IRQ 
    70                              <1>         ;call    pstr
    71                              <1> 
    72 0000E1A8 9C                  <1>         pushf
    73 0000E1A9 FA                  <1>         cli
    74 0000E1AA B0FE                <1>         mov al, 0FEh
    75 0000E1AC E621                <1>         out PIC_IMR, al
    76 0000E1AE E421                <1>         in al, PIC_IMR
    77                              <1>         ;call print_hex
    78                              <1> 
    79 0000E1B0 9D                  <1>         popf
    80 0000E1B1 C3                  <1>         ret
    81                              <1> 
    82                              <1> ;%include "intVect.asm"
    83                              <1> 
    84                              <1> 
    85                              <1> ;#1 tentar testar sem ter terminado wireup de I/0 RD WR e dados no barramento
    86                              <1> ;#2 negligenciar o pino de CS na hora de ligá-lo ao 74138 pois fiz uma gambeta
    87                              <1> ;   para que o mesmo 74138 pudesse atuar com endereços 0x20 e 0x40
    88                              <1> ;#3 negligenciar a forma de habilitar a interrupção na função pic_enable_ir
    89                              <1> ;#4 A chave conectada ao pino da interrupção com certeza dava problemas pois
    90                              <1> ;   foi tirar a chave e colocar o 8253 fazendo a interrupção que todos os
    91                              <1> ;   probremas de reset acabaram.
   237                                  %include "mpit8254.asm"
     1                              <1>         CPU 8086
     2                              <1>         BITS 16
     3                              <1> 
     4                              <1> 
     5                              <1> SYSTEM_CPU_CLK      EQU     4771000    ; this is the CPU clk (1/3 of the used crystal)
     6                              <1> SYSTEM_PCLK         EQU     (SYSTEM_CPU_CLK / 2) ; PCLK from 8284 is half the rate of the CPU clk
     7                              <1> ;--------------------------------------
     8                              <1> ; PIT (8254)
     9                              <1> ;--------------------------------------
    10                              <1> PIT_COUNTER_0       EQU     0x40
    11                              <1> PIT_COUNTER_1       EQU     0x41
    12                              <1> PIT_COUNTER_2       EQU     0x42
    13                              <1> PIT_CTRL_REG        EQU     0x43
    14                              <1> 
    15                              <1> PIT_COUNTER0_INT    EQU     (PIC_INT_VEC + 0)
    16                              <1> SYSTEM_TICKS_SEC    EQU     100         ; 100 ticks per second = 100Hz
    17                              <1> 
    18                              <1> ;--------------------------------------
    19                              <1> ; void pit_init(void)
    20                              <1> ;--------------------------------------
    21                              <1> pit_init:
    22 0000E1B2 9C                  <1>         pushf
    23 0000E1B3 FA                  <1>         cli
    24                              <1> 
    25 0000E1B4 E86100              <1>         call init8253
    26                              <1> 
    27 0000E1B7 E83A00              <1>         call set_int_vector     ; => set_int_vector(PIT_COUNTER0_INT, &counter0_int_handler);
    28                              <1> 
    29                              <1> ; enable pin IR0 in the PIC
    30 0000E1BA 31C0                <1>         xor ax, ax
    31 0000E1BC 50                  <1>         push ax
    32 0000E1BD E8E8FF              <1>         call pic_enable_ir      ; => pic_enable_ir(0);
    33 0000E1C0 83C402              <1>         add sp, 2
    34                              <1> 
    35 0000E1C3 9D                  <1>         popf
    36 0000E1C4 C3                  <1>         ret
    37                              <1> 
    38                              <1> ;--------------------------------------
    39                              <1> ; uint32_t get_sys_ticks(void)
    40                              <1> ;--------------------------------------
    41                              <1> get_sys_ticks:
    42 0000E1C5 9C                  <1>         pushf
    43 0000E1C6 FA                  <1>         cli
    44 0000E1C7 B84000              <1>         mov AX, 0x0040
    45 0000E1CA 8EC0                <1>         mov ES, AX
    46 0000E1CC BB6C00              <1>         MOV BX, 0x006C			;SET BX TO TICK COUNTER
    47 0000E1CF 268B07              <1>         mov ax, word es:[BX]
    48 0000E1D2 268B5702            <1>         mov dx, word es:[BX + 2]
    49 0000E1D6 FB                  <1>         sti
    50 0000E1D7 9D                  <1>         popf
    51 0000E1D8 C3                  <1>         ret
    52                              <1> 
    53                              <1> ;--------------------------------------
    54                              <1> counter0_int_handler:
    55 0000E1D9 06                  <1>         push ES
    56 0000E1DA 50                  <1>         push AX
    57 0000E1DB 31C0                <1>         xor AX, AX
    58 0000E1DD 8EC0                <1>         mov ES, AX
    59 0000E1DF 26FF066C00          <1>         inc word es:[sys_tick_count]
    60 0000E1E4 7505                <1>         jnz .1
    61 0000E1E6 26FF066E00          <1>         inc word es:[sys_tick_count + 2]
    62                              <1> .1:
    63                              <1>         pic_eoi_cmd
    42 0000E1EB 50                  <2>  push ax
    43                              <2> 
    44                              <2> 
    45                              <2> 
    46                              <2> 
    47 0000E1EC B020                <2>  mov al, 0b00100000
    48 0000E1EE E620                <2>  out PIC_REG_0, al
    49 0000E1F0 58                  <2>  pop ax
    64 0000E1F1 58                  <1>         pop AX
    65 0000E1F2 07                  <1>         pop ES
    66 0000E1F3 CF                  <1>         iret
    67                              <1> 
    68                              <1> ;--------------------------------------
    69                              <1> ; void set_int_vector(uint8_t intNo, void* ptr)
    70                              <1> ;--------------------------------------
    71                              <1> set_int_vector:
    72                              <1>         ;MOV si, INT_VECT 
    73                              <1>         ;call    pstr
    74                              <1> 
    75 0000E1F4 06                  <1>         push es
    76 0000E1F5 31C0                <1>         xor ax, ax
    77 0000E1F7 8EC0                <1>         mov es, ax
    78                              <1> 
    79 0000E1F9 FA                  <1>         cli
    80                              <1> 
    81 0000E1FA 26C7062000[E8E8]    <1>         mov word es:[8h*4], INT08
    82 0000E201 26C706220000F0      <1>         mov word es:[8h*4+2], 0F000h
    83                              <1> 
    84 0000E208 07                  <1>         pop es
    85 0000E209 C3                  <1>         ret
    86                              <1> myInit8253:
    87 0000E20A B036                <1>         mov al, 0b00110110      ; Counter 0, binary, mode 3, write both bytes
    88 0000E20C E643                <1>         out PIT_CTRL_REG, al
    89                              <1> 
    90 0000E20E B82F5D              <1>         mov ax, ((SYSTEM_PCLK + (SYSTEM_TICKS_SEC / 2)) / SYSTEM_TICKS_SEC) ; set system tick counter
    91 0000E211 E640                <1>         out PIT_COUNTER_0, al
    92 0000E213 86E0                <1>         xchg ah, al
    93 0000E215 E640                <1>         out PIT_COUNTER_0, al
    94 0000E217 C3                  <1>         ret
    95                              <1> 
    96                              <1> init8253:
    97                              <1> 
    98 0000E218 50                  <1> 	PUSH AX
    99 0000E219 51                  <1> 	PUSH CX
   100                              <1> 
   101 0000E21A B036                <1> 	MOV AL, 0X36 		;00110110b  
   102                              <1> 			        ;CHANNEL 0
   103                              <1> 			        ;WRITE LOW BYTE THEN HIGH BYTE
   104                              <1> 			        ;MODE 3 
   105                              <1> 			        ;16 BIT COUNTER 
   106                              <1> 			
   107 0000E21C E643                <1> 	OUT 0X43, AL		;CONTROL REG
   108                              <1> 
   109 0000E21E B9FFFF              <1> 	MOV CX, 0XFFFF		;COUNT 
   110                              <1> 
   111 0000E221 88C8                <1> 	MOV AL, CL		;WRITE LOW BYTE OF COUNT
   112 0000E223 E640                <1> 	OUT 0X40, AL		;PORT 0X40 ;INTERNAL FLIP-FLOP INC
   113                              <1> 			
   114 0000E225 88E8                <1> 	MOV AL, CH		;WRITE HIGH BYTE OF COUNT 
   115 0000E227 E640                <1> 	OUT 0X40, AL		;PORT 040
   116                              <1> 
   117                              <1> 	;;;;;;;;;;;
   118                              <1> 	;TEST TONE
   119                              <1> 	;;;;;;;;;;;
   120 0000E229 B003                <1> 	MOV AL, 0X03		;ENABLE SPK AND TIMMER 2 'GO'
   121 0000E22B E661                <1> 	OUT 0X61, AL		;PORT 0X61 CONTROL PORT
   122 0000E22D B0B6                <1> 	MOV AL, 0XB6
   123 0000E22F E643                <1> 	OUT 0X43, AL
   124 0000E231 B000                <1> 	MOV AL, 0X00
   125 0000E233 E642                <1> 	OUT 0X42, AL
   126 0000E235 B005                <1> 	MOV AL, 0X05
   127 0000E237 E642                <1> 	OUT 0X42, AL
   128                              <1> 
   129 0000E239 59                  <1> 	POP CX
   130 0000E23A 58                  <1> 	POP AX
   131                              <1> 
   132 0000E23B C3                  <1> 	RET
   238                                  %include "mmath.asm"
     1                              <1> 
     2                              <1> 
     3                              <1>  
     4                              <1> subtract:
     5 0000E23C B200                <1>         mov dl, 00h
     6 0000E23E 26A10F06            <1>         mov ax, word es:[abc]
     7 0000E242 268B1E1406          <1>         mov bx, word es:[def]
     8 0000E247 29D8                <1>         sub ax, bx
     9 0000E249 26A31806            <1>         mov word es:[ghi], ax
    10 0000E24D 26A11106            <1>         mov ax, word es:[abc+2]
    11 0000E251 268B1E1606          <1>         mov bx, word es:[def+2]
    12 0000E256 19D8                <1>         sbb ax, bx
    13 0000E258 26A31A06            <1>         mov word es:[ghi+2],ax
    14 0000E25C 7302                <1>         jnc move
    15 0000E25E FEC2                <1>         inc dl
    16                              <1> move: 
    17 0000E260 2688161C06          <1>         mov byte es:[ghi+4], dl
    18 0000E265 CD03                <1>         int 3
   239                                  %include "mmemoryDump.asm"
     1                              <1> 
     2                              <1> 
     3 0000E267 0D0A3C4553433E4669- <1> msg04   db 0Dh,0Ah,"<ESC>Fim, <Enter>Continua: ", 0
     3 0000E270 6D2C203C456E746572- <1>
     3 0000E279 3E436F6E74696E7561- <1>
     3 0000E282 3A2000              <1>
     4 0000E285 0D0A45533A2000      <1> msg05   db 0Dh,0Ah,"ES: ", 0
     5                              <1> 
     6                              <1> ;=================================
     7                              <1> ; Dump memory
     8                              <1> ; Segment address: ES
     9                              <1> ; Memory  address: bx
    10                              <1> ;         
    11                              <1> dump:
    12 0000E28C E8F803              <1>         call    readAddress
    13                              <1> NewBlock:
    14 0000E28F 53                  <1>         push    BX
    15 0000E290 BE[85E2]            <1>         mov     si, msg05
    16 0000E293 E888EF              <1>         call    pstr
    17 0000E296 8CC0                <1>         mov     AX, ES
    18 0000E298 E8E3FD              <1>         call    print_hex      
    19 0000E29B B03A                <1>         mov     al, ':'
    20 0000E29D E89FEF              <1>         call    cout
    21 0000E2A0 5B                  <1>         pop     BX
    22 0000E2A1 89D8                <1>         mov     AX, BX
    23 0000E2A3 E8D8FD              <1>         call    print_hex      
    24                              <1> 
    25 0000E2A6 B110                <1>         mov  CL, 16
    26 0000E2A8 E83DEF              <1>         call newLine
    27                              <1> dump_01:        
    28 0000E2AB 89D8                <1>         mov  AX, BX
    29 0000E2AD E8CEFD              <1>         call print_hex
    30 0000E2B0 B03A                <1>         mov  al, ':'
    31 0000E2B2 E88AEF              <1>         call cout
    32 0000E2B5 B020                <1>         MOV  AL, ' '
    33 0000E2B7 E885EF              <1>         CALL cout
    34                              <1>         
    35                              <1>         ;;Write 16 bytes em hexadecimal
    36 0000E2BA B510                <1>         MOV  CH, 16
    37                              <1> dump_02:
    38 0000E2BC 268A07              <1>         MOV  AL, ES:[BX]
    39 0000E2BF E8FAFD              <1>         CALL byte_to_hex_str
    40 0000E2C2 50                  <1>         PUSH AX
    41 0000E2C3 E879EF              <1>         CALL cout
    42 0000E2C6 58                  <1>         POP  AX
    43 0000E2C7 88E0                <1>         MOV  AL, AH
    44 0000E2C9 E873EF              <1>         CALL cout
    45 0000E2CC B020                <1>         MOV  AL, ' '
    46 0000E2CE E86EEF              <1>         CALL cout
    47 0000E2D1 43                  <1>         INC  BX
    48 0000E2D2 FECD                <1>         DEC  CH
    49 0000E2D4 75E6                <1>         JNZ  dump_02
    50                              <1>         ;;Wrote 16 bytes
    51                              <1> 
    52 0000E2D6 B020                <1>         MOV  AL, ' '
    53 0000E2D8 E864EF              <1>         CALL cout
    54                              <1> 
    55 0000E2DB 83EB10              <1>         SUB  BX, 16
    56                              <1> 
    57                              <1>         ;;Write 16 bytes em ASCII
    58 0000E2DE B510                <1>         MOV  CH, 16
    59                              <1> dump_03:
    60 0000E2E0 268A07              <1>         MOV  AL, ES:[BX]
    61 0000E2E3 3C20                <1>         CMP  AL, 0x20
    62 0000E2E5 720E                <1>         JC  printPonto ; Flag carry set to 1 AL < 0x20
    63 0000E2E7 3C80                <1>         CMP  AL, 0x80
    64 0000E2E9 730A                <1>         JnC  printPonto ; Flag carry set to 0 AL > 0x80
    65 0000E2EB E851EF              <1>         CALL cout
    66 0000E2EE 43                  <1>         INC  BX
    67 0000E2EF FECD                <1>         DEC  CH
    68 0000E2F1 75ED                <1>         JNZ  dump_03
    69 0000E2F3 EB0A                <1>         jmp  dump_Fim
    70                              <1> printPonto:        
    71 0000E2F5 B02E                <1>         MOV  AL, '.'
    72 0000E2F7 E845EF              <1>         CALL cout
    73 0000E2FA 43                  <1>         INC  BX
    74 0000E2FB FECD                <1>         DEC  CH
    75 0000E2FD 75E1                <1>         JNZ  dump_03
    76                              <1>         ;;Wrote 16 bytes
    77                              <1> 
    78                              <1> dump_Fim:
    79 0000E2FF E8E6EE              <1>         call newLine
    80 0000E302 FEC9                <1>         DEC  CL
    81 0000E304 75A5                <1>         JNZ  dump_01
    82                              <1>         ;;mov  AX, 0F000h
    83                              <1>         ;;mov  DS, AX
    84 0000E306 EB07                <1>         jmp continua
    85 0000E308 C3                  <1>         ret
    86                              <1> 
    87                              <1> printPrompt:
    88 0000E309 B03E                <1>         mov al, '>'
    89 0000E30B E831EF              <1>         call cout
    90 0000E30E C3                  <1>         ret
    91                              <1> 
    92                              <1> continua:
    93 0000E30F 53                  <1>         push BX
    94 0000E310 BE[67E2]            <1>         mov  si, msg04
    95 0000E313 E808EF              <1>         call pstr
    96 0000E316 31C0                <1>         XOR  AX, AX
    97 0000E318 5B                  <1>         pop  BX
    98 0000E319 E841EF              <1>         call cin_blct
    99 0000E31C 3C0D                <1>         cmp  al, cr
   100 0000E31E 7503E96CFF          <1>         je   NewBlock
   101 0000E323 C3                  <1>         ret
   102                              <1> 
   103                              <1> 
   240                                  %include "meditMemory.asm"
     1                              <1> ;=================================
     2                              <1> ; Edit memory
     3                              <1> ; Segment address: ES
     4                              <1> ; Memory  address: bx
     5                              <1> ;  
     6                              <1> 
     7                              <1> p1ltch      equ     0x80
     8 0000E324 0D0A636865636B7375- <1> check_sum_error db cr,lf,"checksum errors!",eos
     8 0000E32D 6D206572726F727321- <1>
     8 0000E336 00                  <1>
     9 0000E337 0D0A6F6B00          <1> check_sum_ok    db cr,lf,"ok",eos
    10                              <1> 
    11                              <1> 
    12                              <1> edit_memory: 
    13 0000E33C E84803              <1>             call    readAddress
    14 0000E33F 89DF                <1>             mov     di, bx
    15                              <1> edit:            
    16 0000E341 E8A4EE              <1>             call    newLine
    17 0000E344 8CC0                <1>             mov     AX, ES
    18 0000E346 E835FD              <1>             call    print_hex
    19 0000E349 B03A                <1>             mov     al, ':'
    20 0000E34B E8F1EE              <1>             call    cout
    21 0000E34E 89F8                <1>             mov     AX, DI
    22 0000E350 E82BFD              <1>             call    printw_hex
    23 0000E353 E814EF              <1>             call    space
    24 0000E356 B05B                <1>             mov     al, '['
    25 0000E358 E8E4EE              <1>             call    cout
    26 0000E35B 268A05              <1>             mov     al, byte es:[di]
    27 0000E35E E82AFD              <1>             call    printb_hex
    28 0000E361 B05D                <1>             mov     al, ']'
    29 0000E363 E8D9EE              <1>             call    cout
    30 0000E366 E801EF              <1>             call    space
    31 0000E369 E82203              <1>             call    readByteHexX
    32 0000E36C 7306                <1>             jnc     edit_memoryEnd
    33 0000E36E 268805              <1>             mov     byte es:[di], al 
    34 0000E371 47                  <1>             inc     di
    35 0000E372 EBCD                <1>             jmp     edit        
    36                              <1> edit_memoryEnd:
    37 0000E374 C3                  <1>             ret
    38                              <1> 
    39                              <1> 
    40                              <1> ;LOAD FILE 
    41                              <1> 
    42 0000E375 0D0A4C6F616420496E- <1> load_hex db cr, lf, "Load Intel hex file...",eos
    42 0000E37E 74656C206865782066- <1>
    42 0000E387 696C652E2E2E00      <1>
    43                              <1> 
    44 0000E38E BE[75E3]            <1> load_intel_hex:     mov si, load_hex
    45 0000E391 E88AEE              <1>           call pstr
    46                              <1> 
    47 0000E394 B000                <1>           mov al,0
    48 0000E396 A21F06              <1>           mov [bcs_error],al
    49                              <1> 
    50 0000E399 E80100              <1>           call get_record
    51 0000E39C C3                  <1>           ret
    52                              <1>             
    53                              <1> ; get record and write to SRAM
    54                              <1> ;
    55                              <1> esc     equ 1bh
    56                              <1> 
    57 0000E39D E8AEEE              <1> get_record: call cin
    58 0000E3A0 3C1B                <1>             cmp al,esc
    59 0000E3A2 7501                <1>             jne is_colon?
    60 0000E3A4 C3                  <1>             ret
    61                              <1> 
    62 0000E3A5 3C3A                <1> is_colon?:  cmp al, ":"
    63 0000E3A7 75F4                <1>             jne get_record	    ; wait until found begin of record
    64 0000E3A9 30C0                <1>             xor al, al           
    65 0000E3AB 26A21E06            <1>             mov byte es:[bcs],al        ; clear byte check sum
    66 0000E3AF B90000              <1>             mov cx, 0		    ; clear counter 
    67 0000E3B2 E8BBEE              <1>             call get_hex	    ; get number of byte
    68 0000E3B5 88C1                <1>             mov cl, al		    ; put to cl
    69 0000E3B7 2600061E06          <1>             add byte es:[bcs],al        
    70 0000E3BC E8B1EE              <1>             call get_hex	    ; get destination address, put to bx register
    71 0000E3BF 88C7                <1>             mov bh, al           ; save high byte
    72 0000E3C1 2600061E06          <1>             add byte es:[bcs],al        
    73 0000E3C6 E8A7EE              <1>             call get_hex        
    74 0000E3C9 88C3                <1>             mov bl, al           ; and low byte
    75 0000E3CB 2600061E06          <1>             add byte es:[bcs],al        
    76 0000E3D0 E89DEE              <1>             call get_hex        
    77 0000E3D3 2600061E06          <1>             add byte es:[bcs],al        
    78 0000E3D8 3C01                <1>             cmp  al,  1           ; end of record type is 01 ?
    79 0000E3DA 7523                <1>             jne  data_record    ; jump if not 01
    80                              <1> 
    81                              <1> wait_lf:    
    82 0000E3DC E86FEE              <1>             call    cin
    83 0000E3DF 3C0A                <1>             cmp     al,lf
    84 0000E3E1 75F9                <1>             jne     wait_lf         ; until end of record sending! with lf detection
    85 0000E3E3 B0FF                <1>             mov     al, 0ffh        ; finish loading turn debug led off
    86 0000E3E5 BA8000              <1>             mov     dx, p1ltch
    87 0000E3E8 EE                  <1>             out     dx, al
    88 0000E3E9 26A01F06            <1>             mov     al,byte es:[bcs_error]
    89 0000E3ED 3C01                <1>             cmp     al,1
    90 0000E3EF 7507                <1>             jne     no_error
    91 0000E3F1 BE[24E3]            <1>             mov     si, check_sum_error
    92 0000E3F4 E827EE              <1>             call    pstr
    93 0000E3F7 C3                  <1>             ret
    94                              <1> no_error:   
    95 0000E3F8 BE[37E3]            <1>             mov     si, check_sum_ok
    96 0000E3FB E820EE              <1>             call    pstr
    97 0000E3FE C3                  <1>             ret
    98                              <1> data_record: 
    99 0000E3FF E86EEE              <1>             call    get_hex                ; get data byte
   100 0000E402 268807              <1>             mov     byte es:[bx],al        ; save to SRAM at es:[bx]
   101 0000E405 2600061E06          <1>             add     byte es:[bcs],al
   102 0000E40A 43                  <1>             inc     bx                     ; next location
   103 0000E40B BA8000              <1>             mov     dx, p1ltch             ; light debug led indicates loading is running
   104 0000E40E EE                  <1>             out     dx, al
   105 0000E40F E2EE                <1>             loop    data_record            ; until cx = 0
   106 0000E411 26A01E06            <1>             mov     al, byte es:[bcs]
   107 0000E415 F6D8                <1>             neg     al
   108 0000E417 26A21E06            <1>             mov     byte es:[bcs],al
   109 0000E41B E852EE              <1>             call    get_hex                ; get check sum
   110 0000E41E 263A061E06          <1>             cmp     al, byte es:[bcs]
   111 0000E423 7406                <1>             je      record_correct
   112 0000E425 B001                <1>             mov     al,1
   113 0000E427 26A21F06            <1>             mov     byte es:[bcs_error],al ; set byte check sum error flag
   114                              <1> record_correct:
   115 0000E42B E96FFF              <1>             jmp     get_record	; back to next record
   116                              <1> 
   117 0000E42E 0D0A57726974652070- <1> write_text:    db cr,lf,"Write peripherals with 16-bit data"
   117 0000E437 65726970686572616C- <1>
   117 0000E440 732077697468203136- <1>
   117 0000E449 2D6269742064617461  <1>
   118 0000E452 0D0A6F666673657420- <1>                db cr,lf,"offset address FF:OFFSET=",eos
   118 0000E45B 616464726573732046- <1>
   118 0000E464 463A4F46465345543D- <1>
   118 0000E46D 00                  <1>
   119 0000E46E 0D0A31362D62697420- <1> word_text:     db cr,lf,"16-bit data=",eos
   119 0000E477 646174613D00        <1>
   120 0000E47D 0D0A6F757470757420- <1> outbyte_text:  db cr,lf,"output 16-bit data to output port"
   120 0000E486 31362D626974206461- <1>
   120 0000E48F 746120746F206F7574- <1>
   120 0000E498 70757420706F7274    <1>
   121 0000E4A0 0D0A706F7274206164- <1>                db cr,lf,"port address=",eos
   121 0000E4A9 64726573733D00      <1>
   122 0000E4B0 0D0A696E7075742031- <1> inbyte_text:   db cr,lf,"input 16-bit data from input port"
   122 0000E4B9 362D62697420646174- <1>
   122 0000E4C2 612066726F6D20696E- <1>
   122 0000E4CB 70757420706F7274    <1>
   123 0000E4D3 0D0A706F7274206164- <1>                db cr,lf,"port address=",eos
   123 0000E4DC 64726573733D00      <1>
   124                              <1> 
   125                              <1> ; write peripheral
   126                              <1> 
   127                              <1> write_peripherals:  
   128 0000E4E3 BE[2EE4]            <1>             mov si,write_text
   129 0000E4E6 E835ED              <1>             call pstr
   130                              <1>             ;call getstr_hex
   131                              <1>             ;call atohex
   132 0000E4E9 E84C01              <1>             call inputAddress
   133 0000E4EC 50                  <1>             push ax
   134 0000E4ED BE[6EE4]            <1>             mov  si,word_text
   135 0000E4F0 E82BED              <1>             call pstr
   136                              <1>             ;call getstr_hex
   137                              <1>             ;call atohex
   138 0000E4F3 E84201              <1>             call inputAddress
   139                              <1> 
   140 0000E4F6 89C3                <1>             mov bx,ax
   141 0000E4F8 58                  <1>             pop ax
   142 0000E4F9 0D00FF              <1>             or  ax,0ff00h   ; PCB was set to FF
   143 0000E4FC 89C2                <1>             mov dx,ax
   144 0000E4FE 89D8                <1>             mov ax,bx
   145 0000E500 EF                  <1>             out dx,ax
   146 0000E501 C3                  <1>             ret
   147                              <1> 
   148                              <1> outbyte:    
   149 0000E502 BE[7DE4]            <1>             mov si,outbyte_text
   150 0000E505 E816ED              <1>             call pstr
   151                              <1>             ;call getstr_hex
   152                              <1>             ;call atohex
   153 0000E508 E82D01              <1>             call inputAddress
   154 0000E50B E8DAEC              <1>             call newLine
   155 0000E50E E86DFB              <1>             call printw_hex
   156 0000E511 50                  <1>             push ax
   157 0000E512 BE[6EE4]            <1>             mov  si,word_text
   158 0000E515 E806ED              <1>             call pstr
   159                              <1>             ;call getstr_hex
   160                              <1>             ;call atohex
   161 0000E518 E81D01              <1>             call inputAddress
   162 0000E51B E8CAEC              <1>             call newLine
   163 0000E51E E85DFB              <1>             call printw_hex
   164                              <1> 
   165 0000E521 89C3                <1>             mov bx,ax
   166 0000E523 58                  <1>             pop ax
   167 0000E524 89C2                <1>             mov dx,ax
   168 0000E526 89D8                <1>             mov ax,bx
   169 0000E528 EE                  <1>             out dx,al
   170 0000E529 C3                  <1>             ret
   171                              <1> 
   172                              <1> inbyte:  
   173 0000E52A BE[B0E4]            <1>             mov si,inbyte_text
   174 0000E52D E8EEEC              <1>             call pstr
   175                              <1>             ;call getstr_hex
   176                              <1>             ;call atohex
   177 0000E530 E80501              <1>             call inputAddress
   178 0000E533 E8B2EC              <1>             call newLine
   179 0000E536 E845FB              <1>             call printw_hex
   180 0000E539 89C2                <1>             mov  dx, ax
   181 0000E53B ED                  <1>             in   ax, dx
   182 0000E53C E8A9EC              <1>             call newLine
   183 0000E53F E83CFB              <1>             call printw_hex
   184 0000E542 C3                  <1>             ret
   185 0000E543 0D0A696E7075742020- <1> inbyte8b_text   db cr,lf,"input  8-bit  data ",eos
   185 0000E54C 382D62697420206461- <1>
   185 0000E555 74612000            <1>
   186 0000E559 0D0A696E7075742031- <1> inbyte16b_text  db cr,lf,"input 16-bits data ",eos
   186 0000E562 362D62697473206461- <1>
   186 0000E56B 74612000            <1>
   187                              <1> 
   188 0000E56F 0D0A46696C6C696E67- <1> mem2fill1       db cr,lf,"Filling memory :",eos
   188 0000E578 206D656D6F7279203A- <1>
   188 0000E581 00                  <1>
   189 0000E582 2073697A65206F6620- <1> mem2fill2       db " size of ",eos
   189 0000E58B 00                  <1>
   190 0000E58C 20776974682000      <1> mem2fill3       db " with ",eos
   191                              <1>                 
   192                              <1> 
   193                              <1> fill_memory:
   194 0000E593 E8F100              <1>             call    readAddress
   195 0000E596 89DF                <1>             mov     DI, BX
   196 0000E598 BE[59E5]            <1>             mov     si, inbyte16b_text
   197 0000E59B E880EC              <1>             call    pstr
   198 0000E59E E89700              <1>             call    inputAddress
   199 0000E5A1 268A2E8F05          <1>     		mov		ch, byte es:[buff_write]
   200 0000E5A6 268A0E9005          <1>     		mov		cl, byte es:[buff_write+1]
   201 0000E5AB BE[43E5]            <1>             mov     si, inbyte8b_text
   202 0000E5AE E86DEC              <1>             call    pstr
   203 0000E5B1 E80301              <1>             call    inputData
   204 0000E5B4 50                  <1>             push    AX
   205                              <1>             
   206 0000E5B5 BE[6FE5]            <1>             mov     si, mem2fill1
   207 0000E5B8 E863EC              <1>             call    pstr
   208 0000E5BB 89F8                <1>             mov     AX, DI
   209 0000E5BD E8BEFA              <1>             call    printw_hex
   210                              <1> 
   211                              <1>     		
   212 0000E5C0 BE[82E5]            <1>             mov     si, mem2fill2
   213 0000E5C3 E858EC              <1>             call    pstr
   214 0000E5C6 89C8                <1>             mov     AX, CX
   215 0000E5C8 E8B3FA              <1>             call    printw_hex
   216                              <1> 
   217 0000E5CB BE[8CE5]            <1>             mov     si, mem2fill3
   218 0000E5CE E84DEC              <1>             call    pstr 		
   219 0000E5D1 58                  <1>             pop     AX
   220 0000E5D2 E8B6FA              <1>             call    printb_hex
   221 0000E5D5 E810EC              <1>     		call	newLine
   222                              <1> loopFM:            
   223 0000E5D8 268805              <1>             mov     byte es:[di], al 
   224 0000E5DB 47                  <1>             inc     di
   225 0000E5DC 49                  <1>             dec     cx
   226 0000E5DD 75F9                <1>             jnz loopFM
   227 0000E5DF C3                  <1>             ret
   228                              <1> 
   241                                  %include "minputs.asm"
     1 0000E5E0 0D0A44696769746520- <1> msg01	db 0Dh,0Ah,"Digite o endereco: ", 0
     1 0000E5E9 6F20656E6465726563- <1>
     1 0000E5F2 6F3A2000            <1>
     2 0000E5F6 0D0A3C4553433E7061- <1> msg02   db 0Dh,0Ah,"<ESC>para novo segment <Enter>continua ES: ", 0
     2 0000E5FF 7261206E6F766F2073- <1>
     2 0000E608 65676D656E74203C45- <1>
     2 0000E611 6E7465723E636F6E74- <1>
     2 0000E61A 696E75612045533A20- <1>
     2 0000E623 00                  <1>
     3 0000E624 0D0A4E6F766F207365- <1> msg03   db 0Dh,0Ah,"Novo segment ES: ", 0
     3 0000E62D 676D656E742045533A- <1>
     3 0000E636 2000                <1>
     4                              <1> 
     5                              <1> 
     6                              <1> inputAddress:
     7 0000E638 E8BEEB              <1>         call readLine
     8 0000E63B E8F9FA              <1>         call convertWordToHex
     9 0000E63E 268A268F05          <1> 	mov 	ah, byte es:[buff_write]
    10 0000E643 26A09005            <1> 	mov	al, byte es:[buff_write+1]
    11 0000E647 C3                  <1>         ret
    12                              <1> 
    13                              <1> loadBX:
    14 0000E648 06                  <1>         push    ES
    15 0000E649 B80000              <1>         mov     AX, 0x0
    16 0000E64C 8EC0                <1>         mov     ES, AX
    17 0000E64E BE[E0E5]            <1>         mov     si, msg01
    18 0000E651 E8CAEB              <1>         call    pstr
    19 0000E654 E8E1FF              <1>         call    inputAddress
    20 0000E657 89C3                <1>         mov     BX, AX
    21                              <1>         ;call    print_hex
    22 0000E659 07                  <1>         pop     ES
    23 0000E65A C3                  <1>         ret        
    24                              <1> showES:
    25 0000E65B 53                  <1>         push BX
    26 0000E65C BE[F6E5]            <1>         mov  si, msg02
    27 0000E65F E8BCEB              <1>         call pstr
    28 0000E662 8CC0                <1>         mov  AX, ES
    29 0000E664 E817FA              <1>         call print_hex
    30 0000E667 31C0                <1>         XOR  AX, AX
    31 0000E669 E8F1EB              <1>         call cin_blct
    32 0000E66C 3C0D                <1>         cmp  al, 0x0d
    33 0000E66E 7403                <1>         je   .retorna
    34 0000E670 E80200              <1>         call    changeES
    35                              <1> .retorna:
    36 0000E673 5B                  <1>         pop BX
    37 0000E674 C3                  <1>         ret
    38                              <1> 
    39                              <1> changeES:
    40 0000E675 53                  <1>         push    BX
    41 0000E676 31C0                <1>         xor     AX, AX
    42 0000E678 8EC0                <1>         mov     ES, AX
    43 0000E67A BE[24E6]            <1>         mov     si, msg03
    44 0000E67D E89EEB              <1>         call    pstr
    45 0000E680 E8B5FF              <1>         call    inputAddress
    46 0000E683 8EC0                <1>         mov     ES, AX
    47 0000E685 5B                  <1>         pop     BX
    48 0000E686 C3                  <1>         ret
    49                              <1> 
    50                              <1> ;Return the address in: ES:BX
    51                              <1> readAddress:
    52 0000E687 E8D1FF              <1>         call    showES
    53 0000E68A E8BBFF              <1>         call    loadBX
    54 0000E68D C3                  <1>         ret
    55                              <1> 
    56                              <1> readByteHexX:
    57 0000E68E F8                  <1>         clc
    58 0000E68F E8CBEB              <1>         call cin_blct
    59 0000E692 3C1B                <1>         cmp  al, 0x1b
    60 0000E694 7420                <1>         je   readByteHexEnd   
    61 0000E696 E8C7FA              <1>         call to_hex
    62 0000E699 88C4                <1>         mov  ah, al
    63 0000E69B E8F3F9              <1>         call print_digit
    64 0000E69E E8BCEB              <1>         call cin_blct
    65 0000E6A1 3C1B                <1>         cmp  al, 0x1b
    66 0000E6A3 7411                <1>         je   readByteHexEnd   
    67 0000E6A5 E8B8FA              <1>         call to_hex
    68 0000E6A8 D0E4                <1>         shl  ah, 1
    69 0000E6AA D0E4                <1>         shl  ah, 1
    70 0000E6AC D0E4                <1>         shl  ah, 1
    71 0000E6AE D0E4                <1>         shl  ah, 1
    72 0000E6B0 08E0                <1>         or   al, ah
    73 0000E6B2 E8DCF9              <1>         call  print_digit
    74 0000E6B5 F9                  <1>         stc
    75                              <1> readByteHexEnd:        
    76 0000E6B6 C3                  <1>         ret          
    77                              <1> 
    78                              <1> 
    79                              <1> ;Return byte in hexadecmal in: AL
    80                              <1> inputData:
    81 0000E6B7 E83FEB              <1>         call readLine
    82 0000E6BA E863FA              <1>         call convertByteToHex
    83 0000E6BD 26A08F05            <1>         mov  al, byte es:[buff_write]
    84 0000E6C1 C3                  <1>         ret
    85                              <1>            
   242                                  ;===========================
   243                                  %include "code/bios.asm"
     1                              <1> 
     2                              <1> 
     3                              <1> BiosLoad:
     4 0000E6C2 E80700              <1> 		CALL LOAD_INT_VECTOR_TABLE	;COPIES INTERRUPT VECTOR TABLE TO ADDRESS 0X0000:0X0000
     5 0000E6C5 E81A00              <1> 		CALL LOAD_BIOS_DATA_AREA	;COPIES BIOS DATA TO ADDRESS 0X0000:0X0400
     6 0000E6C8 E8E1EB              <1> 		call INITIALIZE_CH376S_0XE0
     7 0000E6CB C3                  <1>         ret
     8                              <1> 
     9                              <1> 
    10                              <1> LOAD_INT_VECTOR_TABLE:
    11 0000E6CC FC                  <1> 	CLD
    12 0000E6CD B80000              <1> 	MOV AX, 0X0000
    13 0000E6D0 8EC0                <1> 	MOV ES, AX
    14 0000E6D2 BF0000              <1> 	MOV DI, 0X0000
    15 0000E6D5 8CC8                <1> 	MOV AX, CS
    16 0000E6D7 8ED8                <1> 	MOV DS, AX
    17 0000E6D9 BE[F0E7]            <1> 	MOV SI, INT_VECTOR_TABLE
    18 0000E6DC B98000              <1> 	MOV CX, INT_VECTOR_TABLE.END - INT_VECTOR_TABLE
    19 0000E6DF F3A4                <1> 	REP MOVSB
    20 0000E6E1 C3                  <1> 	RET
    21                              <1> 
    22                              <1> LOAD_BIOS_DATA_AREA:
    23 0000E6E2 FC                  <1> 	CLD
    24 0000E6E3 B84000              <1> 	MOV AX, 0X0040
    25 0000E6E6 8EC0                <1> 	MOV ES, AX
    26 0000E6E8 BF0000              <1> 	MOV DI, 0X0000
    27 0000E6EB 8CC8                <1> 	MOV AX, CS
    28 0000E6ED 8ED8                <1> 	MOV DS, AX
    29 0000E6EF BE[F8E6]            <1> 	MOV SI, BIOS_DATA_AREA
    30 0000E6F2 B99800              <1> 	MOV CX, BIOS_DATA_AREA.END - BIOS_DATA_AREA
    31 0000E6F5 F3A4                <1> 	REP MOVSB
    32 0000E6F7 C3                  <1> 	RET
    33                              <1> 
    34                              <1> 
    35                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    36                              <1> ;BIOS DATA AREA
    37                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    38                              <1> %INCLUDE "code/asm/bios_data.asm"
     1                              <2> BIOS_DATA_AREA:
     2                              <2> 	;0x0400 (4 words)	IO ports for COM1-COM4 serial (each address is 1 word, zero if none)
     3 0000E6F8 0000                <2> 	DW 0X0000
     4 0000E6FA 0000                <2> 	DW 0X0000
     5 0000E6FC 0000                <2> 	DW 0X0000
     6 0000E6FE 0000                <2> 	DW 0X0000
     7                              <2> 
     8                              <2> 	;0x0408 (4 words)	IO ports for LPT1-LPT4 parallel (each address is 1 word, zero if none)
     9 0000E700 0000                <2> 	DW 0X0000
    10 0000E702 0000                <2> 	DW 0X0000
    11 0000E704 0000                <2> 	DW 0X0000
    12 0000E706 0000                <2> 	DW 0X0000	;!!
    13                              <2> 
    14                              <2> 	;0x0410 (word)		(Equip Flag) packed bit flags for detected hardware
    15                              <2> 	;look up number google, right now one floppy drive, 80x25 color, no coprocessor
    16 0000E708 2D00                <2> 	DW 0X002D
    17                              <2> 
    18                              <2> 	;0x0412	 (byte)		MFG test
    19 0000E70A 01                  <2> 	DB 0x01
    20                              <2> 
    21                              <2> 	;0x0413 (word)		Memory Size
    22 0000E70B 0002                <2> 	DW 0x0200			;200 512K, 
    23                              <2> 
    24                              <2> 	;0x0415 (word)		IO Ram Size
    25 0000E70D 0000                <2> 	DW 0x0000
    26                              <2> 
    27                              <2> 	;0x0417 (byte)		keyboard state flag 0
    28 0000E70F 00                  <2> 	DB 0X00
    29                              <2> 
    30                              <2> 	;0x0418 (byte)		keyboard state flag 1
    31 0000E710 00                  <2> 	DB 0X00	
    32                              <2> 
    33                              <2> 	;0x0419 (byte)		ALT_INPUT
    34 0000E711 00                  <2> 	DB 0X00	
    35                              <2> 
    36                              <2> 	;0x041A (word) 		keyboard head 
    37 0000E712 1E00                <2> 	DW 0x001E
    38                              <2> 
    39                              <2> 	;0x041C (word)		keyboard tail
    40 0000E714 1E00                <2> 	DW 0x001E 
    41                              <2> 
    42                              <2> 	;0x041E (32 bytes)	keyboard buffer
    43 0000E716 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    44 0000E71A 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    45 0000E71E 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    46 0000E722 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    47 0000E726 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    48 0000E72A 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    49 0000E72E 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    50 0000E732 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    51                              <2> 
    52                              <2> 	;0x043E 		DISKETTE DATA AREAS
    53 0000E736 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    54 0000E73A 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
    55 0000E73E 000000              <2> 	DB 0X00, 0X00, 0X00
    56                              <2> 
    57                              <2> 	;0x0449 (byte)		Display Mode [VIDEO DISPLAY DATA AREA]
    58 0000E741 03                  <2> 	DB 0X03				;80x25  8x8   640x200   16 Colors 0xB800 CGA
    59                              <2> 
    60                              <2> 	;0x044A (word)		number of columns in text mode
    61 0000E742 1400                <2> 	DW 0X0014
    62                              <2> 
    63                              <2> 	;0X044C (word)
    64 0000E744 0000                <2> 	DW 0X0000
    65                              <2> 
    66                              <2> 	;0X044E (word)
    67 0000E746 0000                <2> 	DW 0X0000	
    68                              <2> 
    69                              <2> 	;0X0450 (16 BYTE AS WORD)	:CURSOR_POSN 8 PAGES   col, row
    70 0000E748 00000000            <2> 	DW 0X0000, 0X0000
    71 0000E74C 00000000            <2> 	DW 0X0000, 0X0000
    72 0000E750 00000000            <2> 	DW 0X0000, 0X0000
    73 0000E754 00000000            <2> 	DW 0X0000, 0X0000
    74                              <2> 
    75                              <2> 	;0X0460 (word)		Cursor Mode
    76 0000E758 0000                <2> 	DW 0X0000
    77                              <2> 	;0x0462			Active Page
    78 0000E75A 00                  <2> 	DB 0X00
    79                              <2> 
    80                              <2> 	;0x0463 (2 bytes, taken as a word)	base IO port for video
    81 0000E75B 00                  <2> 	DB 0X00
    82 0000E75C 00                  <2> 	DB 0X00
    83                              <2> 
    84                              <2> 	;0x0465	(byte)
    85 0000E75D 00                  <2> 	DB 0x00
    86                              <2> 
    87                              <2> 	;0x0466	(byte)
    88 0000E75E 00                  <2> 	DB 0x00
    89                              <2> 
    90                              <2> 	;0x0467	(word)
    91 0000E75F 0000                <2> 	DW 0x0000
    92                              <2> 
    93                              <2> 	;0x0469	(word)
    94 0000E761 0000                <2> 	DW 0x0000
    95                              <2> 
    96                              <2> 	;0x046B	(byte)
    97 0000E763 00                  <2> 	DB 0x00
    98                              <2> 
    99                              <2> 	;0x046C (word)		# of IRQ0 timer ticks since boot
   100 0000E764 0000                <2> 	DW 0X0000
   101 0000E766 0000                <2> 	DW 0X0000
   102                              <2> 
   103                              <2> 	;LATER 0x0470
   104 0000E768 0000                <2> 	DB 0X00, 0X00
   105 0000E76A 000000              <2> 	DB 0X00, 0X00, 0X00
   106                              <2> 	;
   107                              <2> 	
   108                              <2> 	;0x0475 (byte)		# of hard disk drives detected
   109 0000E76D 00                  <2> 	DB 0X00
   110                              <2> 	
   111                              <2> 	;LATER 0x0476
   112 0000E76E 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   113 0000E772 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   114 0000E776 0000                <2> 	DB 0X00, 0X00
   115                              <2> 	;
   116                              <2> 	
   117                              <2> 	;0x0480 (word)		keyboard buffer start
   118 0000E778 1E00                <2> 	DW 0X001E
   119                              <2> 	;0x0482 (word)		keyboard buffer end
   120 0000E77A 3E00                <2> 	DW 0X003E
   121                              <2> 	
   122                              <2> 	;LATER 0x0484
   123 0000E77C 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   124 0000E780 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   125 0000E784 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   126 0000E788 00000000            <2> 	DB 0X00, 0X00, 0X00, 0X00
   127 0000E78C 000000              <2> 	DB 0X00, 0X00, 0X00
   128                              <2> 	
   129                              <2> 	;0x0497 (byte)		last keyboard LED/Shift key state
   130 0000E78F 00                  <2> 	DB 0X00	
   131                              <2> 
   132                              <2> .END:
   133                              <2> 
   134                              <2> 
   135                              <2> 
   136                              <2> 
   137                              <2> 
   138                              <2> .CHARACTER_CODES_UPPERCASE:
   139 0000E790 001B21402324255E26- <2> DB 0X00, 0X1B, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 0X08, 0X09 ;0X00-0X0F
   139 0000E799 2A28295F2B0809      <2>
   140 0000E7A0 51574552545955494F- <2> DB 'Q','W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', 0X0D, 0x00, 'A', 'S'    ;0X10-0X1F
   140 0000E7A9 507B7D0D004153      <2>
   141 0000E7B0 444647484A4B4C3A22- <2> DB 'D','F', 'G', 'H', 'J', 'K', 'L', ':', '"', '~', 0x00, '|', 'Z', 'X', 'C', 'V'     ;0X20-0X2F
   141 0000E7B9 7E007C5A584356      <2>
   142                              <2> .CHARACTER_CODES_LOWERCASE:
   143 0000E7C0 001B31323334353637- <2> DB 0X00, 0X1B, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0X08, 0X09 ;0X00-0X0F
   143 0000E7C9 3839302D3D0809      <2>
   144 0000E7D0 71776572747975696F- <2> DB 'q','w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', 0X0D, 0x00, 'a', 's'    ;0X10-0X1F
   144 0000E7D9 705B5D0D006173      <2>
   145 0000E7E0 646667686A6B6C3B27- <2> DB 'd','f', 'g', 'h', 'j', 'k', 'l', ';', 0x27, '`', 0x00, 0X5C, 'z', 'x', 'c', 'v'   ;0X20-0X2F
   145 0000E7E9 60005C7A786376      <2>
   146                              <2> .CHARACTER_CODES_CTRL:
    39                              <1> 
    40                              <1> 
    41                              <1> INT_VECTOR_TABLE:
    42 0000E7F0 [70E8]00F0          <1> 	DW INT00, 0xF000
    43 0000E7F4 [7FE8]00F0          <1> 	DW INT01, 0xF000
    44 0000E7F8 [8EE8]00F0          <1> 	DW INT02, 0xF000
    45 0000E7FC [9DE8]00F0          <1> 	DW INT03, 0xF000
    46 0000E800 [ACE8]00F0          <1> 	DW INT04, 0xF000
    47 0000E804 [BBE8]00F0          <1> 	DW INT05, 0xF000
    48 0000E808 [CAE8]00F0          <1> 	DW INT06, 0xF000
    49 0000E80C [D9E8]00F0          <1> 	DW INT07, 0xF000
    50 0000E810 [E8E8]00F0          <1> 	DW INT08, 0xF000
    51 0000E814 [07E9]00F0          <1> 	DW INT09, 0xF000
    52 0000E818 [43EA]00F0          <1> 	DW INT0A, 0xF000
    53 0000E81C [52EA]00F0          <1> 	DW INT0B, 0xF000
    54 0000E820 [61EA]00F0          <1> 	DW INT0C, 0xF000
    55 0000E824 [70EA]00F0          <1> 	DW INT0D, 0xF000
    56 0000E828 [7FEA]00F0          <1> 	DW INT0E, 0xF000
    57 0000E82C [8EEA]00F0          <1> 	DW INT0F, 0xF000
    58 0000E830 [9DEA]00F0          <1> 	DW INT10, 0xF000
    59 0000E834 [8FF1]00F0          <1> 	DW INT11, 0xF000
    60 0000E838 [9EF1]00F0          <1> 	DW INT12, 0xF000
    61 0000E83C [CBD5]00F0          <1> 	DW INT13, 0xF000
    62 0000E840 [ADF1]00F0          <1> 	DW INT14, 0xF000
    63 0000E844 [AEF1]00F0          <1> 	DW INT15, 0xF000
    64 0000E848 [C9F1]00F0          <1> 	DW INT16, 0xF000
    65 0000E84C [3AF2]00F0          <1> 	DW INT17, 0xF000
    66 0000E850 [3BF2]00F0          <1> 	DW INT18, 0xF000
    67 0000E854 [4AF2]00F0          <1> 	DW INT19, 0xF000
    68 0000E858 [4FF2]00F0          <1> 	DW INT1A, 0xF000
    69 0000E85C [69F2]00F0          <1> 	DW INT1B, 0xF000
    70 0000E860 [78F2]00F0          <1> 	DW INT1C, 0xF000
    71 0000E864 [79F2]00F0          <1> 	DW INT1D, 0xF000
    72 0000E868 [88F2]00F0          <1> 	DW INT1E, 0xF000
    73 0000E86C [97F2]00F0          <1> 	DW INT1F, 0xF000
    74                              <1> .END:
    75                              <1> INT00: ;Divide by Zero
    76 0000E870 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
    77 0000E872 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
    78 0000E874 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    79 0000E876 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
    80 0000E878 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    81 0000E87A B030                <1> 	MOV AL, '0'		;SET AL TO CHAR
    82 0000E87C CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    83                              <1> 	;HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
    84 0000E87E CF                  <1> 	IRET		;RETURN FROM INTERRUPT
    85                              <1> 
    86                              <1> INT01: ;Single Step
    87 0000E87F B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
    88 0000E881 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
    89 0000E883 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    90 0000E885 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
    91 0000E887 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    92 0000E889 B031                <1> 	MOV AL, '1'		;SET AL TO CHAR
    93 0000E88B CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
    94                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
    95 0000E88D CF                  <1> 	IRET		;RETURN FROM INTERRUPT
    96                              <1> 
    97                              <1> INT02: ;Nonmaskable 
    98 0000E88E B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
    99 0000E890 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   100 0000E892 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   101 0000E894 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   102 0000E896 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   103 0000E898 B032                <1> 	MOV AL, '2'		;SET AL TO CHAR
   104 0000E89A CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   105                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   106 0000E89C CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   107                              <1> 
   108                              <1> INT03: ;Breakpoint
   109 0000E89D B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   110 0000E89F B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   111 0000E8A1 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   112 0000E8A3 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   113 0000E8A5 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   114 0000E8A7 B033                <1> 	MOV AL, '3'		;SET AL TO CHAR
   115 0000E8A9 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   116                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   117 0000E8AB CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   118                              <1> 
   119                              <1> INT04: ;Overflow
   120 0000E8AC B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   121 0000E8AE B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   122 0000E8B0 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   123 0000E8B2 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   124 0000E8B4 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   125 0000E8B6 B034                <1> 	MOV AL, '4'		;SET AL TO CHAR
   126 0000E8B8 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   127                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   128 0000E8BA CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   129                              <1> 
   130                              <1> INT05: ;Print Screen
   131 0000E8BB B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   132 0000E8BD B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   133 0000E8BF CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   134 0000E8C1 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   135 0000E8C3 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   136 0000E8C5 B035                <1> 	MOV AL, '5'		;SET AL TO CHAR
   137 0000E8C7 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   138                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   139 0000E8C9 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   140                              <1> 
   141                              <1> INT06: ;Reserved
   142 0000E8CA B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   143 0000E8CC B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   144 0000E8CE CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   145 0000E8D0 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   146 0000E8D2 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   147 0000E8D4 B036                <1> 	MOV AL, '6'		;SET AL TO CHAR
   148 0000E8D6 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   149                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   150 0000E8D8 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   151                              <1> 
   152                              <1> INT07: ;Reserved
   153 0000E8D9 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   154 0000E8DB B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   155 0000E8DD CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   156 0000E8DF B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   157 0000E8E1 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   158 0000E8E3 B037                <1> 	MOV AL, '7'		;SET AL TO CHAR
   159 0000E8E5 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   160                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   161 0000E8E7 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   162                              <1> 
   163                              <1> INT08: ;Reserved
   164 0000E8E8 50                  <1> 	PUSH AX			;STORE AX
   165 0000E8E9 53                  <1> 	PUSH BX			;STORE BX
   166 0000E8EA 1E                  <1> 	PUSH DS			;STORE DS
   167 0000E8EB B84000              <1> 	MOV AX, 0X0040			;BIOS DATA AREA
   168 0000E8EE 8ED8                <1> 	MOV DS, AX			;SET DATA SEGMENT 
   169 0000E8F0 BB6C00              <1> 	MOV BX, 0X006C			;SET BX TO TICK COUNTER
   170 0000E8F3 FF07                <1> 	INC WORD [BX]			;INC LOWER WORD TICK BY ONE
   171 0000E8F5 833F00              <1> 	CMP WORD [BX], 0X0000			;CMP TO 0 TO SEE IF ROLLED OVER 	
   172 0000E8F8 7505                <1> 	JNZ .END_INT08			;IF NOT END
   173 0000E8FA 83C302              <1> 	ADD BX, 0X0002			;ADD 2 TO BX FOR NEXT WORD
   174 0000E8FD FF07                <1> 	INC WORD [BX]			;INC UPPER WORD
   175                              <1>   .END_INT08:				;END LABEL
   176 0000E8FF 1F                  <1> 	POP DS			;RESTORE DS
   177 0000E900 5B                  <1> 	POP BX			;RESTORE BX
   178                              <1> 
   179                              <1> 
   180 0000E901 B020                <1>     MOV AL, 0x20
   181 0000E903 E620                <1>     OUT 0x20, AL	
   182 0000E905 58                  <1> 	POP AX			;RESTORE AX
   183 0000E906 CF                  <1> 	IRET			;RETURN FROM INTERRUPT	
   184                              <1> 
   185                              <1> ;INT09:	
   186                              <1> %INCLUDE "code/asm/int09.asm"
     1                              <2> INT09:
     2 0000E907 50                  <2> 	PUSH AX			;STORE AX
     3 0000E908 53                  <2> 	PUSH BX			;STORE BX
     4 0000E909 1E                  <2> 	PUSH DS			;STORE DS
     5 0000E90A 0E                  <2> 	PUSH CS
     6 0000E90B 1F                  <2> 	POP DS
     7                              <2> 
     8 0000E90C B400                <2> 	MOV AH, 0X00	;CLEAR AH
     9 0000E90E E460                <2> 	IN AL, 0X60		;GET SCANCODE
    10 0000E910 3CE0                <2> 	CMP AL, 0XE0	;EXTENDED
    11 0000E912 742C                <2> 	JZ .END			;DO NOTHING FOR NOW
    12 0000E914 3C80                <2> 	CMP AL, 0X80	;BREAK CODES
    13 0000E916 7328                <2> 	JAE .END		;DO NOTHING FOR NOW
    14                              <2> 	
    15 0000E918 89C3                <2> 	MOV BX, AX		;SET INDEX
    16 0000E91A 88C4                <2> 	MOV AH, AL		;SCAN CODE TO UPPER
    17 0000E91C 8A87[48E9]          <2> 	MOV AL, [BX+.CHARACTER_CODE_UPPER_CASE]
    18 0000E920 50                  <2> 	PUSH AX			;STORE SCAN CODE/ CHAR CODE
    19                              <2> 		
    20 0000E921 B84000              <2> 	MOV AX, 0X0040	;BIOS DATA SEGMENT 
    21 0000E924 8ED8                <2> 	MOV DS, AX		;SET DATA SEGMENT
    22 0000E926 8B1E1C00            <2> 	MOV BX, [0X001C];KEYBOARD HEAD LOCA
    23 0000E92A 58                  <2> 	POP AX			;GET SCAN CODE/ CHAR CODE
    24                              <2> 	
    25 0000E92B 8907                <2> 	MOV [BX], AX		;STORE IN KEYBOARD BUFFER
    26 0000E92D 83C302              <2> 	ADD BX, 0X02		;INC TWICE
    27 0000E930 3B1E8200            <2> 	CMP BX, [0X0082]	;CHECK TO SEE IF ATT END OF BUFFER
    28 0000E934 7204                <2> 	JB .NOT_END_OF_BUFFER;JUMP OVER NEXT STEP IF NOT AT END
    29 0000E936 8B1E8000            <2> 	MOV BX, [0X0080]	;SET INDEX TO BEGINING  
    30                              <2>     .NOT_END_OF_BUFFER:
    31 0000E93A 891E1C00            <2> 	MOV [0X001C], BX	;STORE NEW  LOCATION
    32                              <2> 	
    33                              <2> 	
    34                              <2> 	
    35 0000E93E EB00                <2> 	JMP .END
    36                              <2> 
    37                              <2> 	
    38                              <2> .END:
    39 0000E940 1F                  <2> 	POP DS			;RESTORE DS
    40 0000E941 5B                  <2> 	POP BX			;RESTORE BX
    41 0000E942 B020                <2> 	MOV AL, 0x20		;END OF INTERRUPT
    42 0000E944 E620                <2> 	OUT 0x20, AL	
    43 0000E946 58                  <2> 	POP AX
    44 0000E947 CF                  <2> 	IRET	
    45                              <2> 
    46                              <2> .CHARACTER_CODE_UPPER_CASE:
    47 0000E948 001B31323334353637- <2> DB 0X00, 0X1B, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '_', '+', 0X08, 0X09	;0X0_
    47 0000E951 3839305F2B0809      <2>
    48 0000E958 51574552545955494F- <2> DB 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '[', ']', 0X0D, 0X00, 'A', 'S'	;0X1_
    48 0000E961 505B5D0D004153      <2>
    49 0000E968 444647484A4B4C3A27- <2> DB 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', 0X27, '~', 0X00, 0X5C, 'Z', 'X', 'C', 'V'	;0X2_
    49 0000E971 7E005C5A584356      <2>
    50 0000E978 424E4D3C3E3F002A00- <2> DB 'B', 'N', 'M', '<', '>', '?', 0X00, '*', 0X00, ' ', 0X00
    50 0000E981 2000                <2>
    51                              <2> 	
    52                              <2> .FILL:
    53 0000E983 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    54 0000E98B 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    55 0000E993 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    56 0000E99B 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    57                              <2> 
    58 0000E9A3 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    59 0000E9AB 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    60 0000E9B3 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    61 0000E9BB 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    62                              <2> 
    63 0000E9C3 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    64 0000E9CB 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    65 0000E9D3 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    66 0000E9DB 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    67                              <2> 
    68 0000E9E3 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    69 0000E9EB 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    70 0000E9F3 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    71 0000E9FB 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    72                              <2> 
    73 0000EA03 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    74 0000EA0B 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    75 0000EA13 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    76 0000EA1B 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    77                              <2> 
    78 0000EA23 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    79 0000EA2B 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    80 0000EA33 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
    81 0000EA3B 0000000000000000    <2> DB 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
   187                              <1> 
   188                              <1> INT0A: ;Reserved
   189 0000EA43 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   190 0000EA45 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   191 0000EA47 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   192 0000EA49 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   193 0000EA4B CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   194 0000EA4D B041                <1> 	MOV AL, 'A'		;SET AL TO CHAR
   195 0000EA4F CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   196 0000EA51 CF                  <1> 	IRET		;RETURN FROM INTERRUPT	
   197                              <1> 
   198                              <1> INT0B: ;Communications
   199 0000EA52 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   200 0000EA54 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   201 0000EA56 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   202 0000EA58 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   203 0000EA5A CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   204 0000EA5C B042                <1> 	MOV AL, 'B'		;SET AL TO CHAR
   205 0000EA5E CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   206 0000EA60 CF                  <1> 	IRET		;RETURN FROM INTERRUPT	
   207                              <1> 	
   208                              <1> INT0C: ;Communications
   209 0000EA61 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   210 0000EA63 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   211 0000EA65 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   212 0000EA67 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   213 0000EA69 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   214 0000EA6B B043                <1> 	MOV AL, 'C'		;SET AL TO CHAR
   215 0000EA6D CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   216 0000EA6F CF                  <1> 	IRET		;RETURN FROM INTERRUPT			
   217                              <1> 
   218                              <1> INT0D: ;Disk
   219 0000EA70 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   220 0000EA72 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   221 0000EA74 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   222 0000EA76 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   223 0000EA78 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   224 0000EA7A B044                <1> 	MOV AL, 'D'		;SET AL TO CHAR
   225 0000EA7C CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   226 0000EA7E CF                  <1> 	IRET	
   227                              <1> INT0E: ;Disk
   228 0000EA7F B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   229 0000EA81 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   230 0000EA83 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   231 0000EA85 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   232 0000EA87 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   233 0000EA89 B045                <1> 	MOV AL, 'E'		;SET AL TO CHAR
   234 0000EA8B CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   235 0000EA8D CF                  <1> 	IRET	;RETURN FROM INTERRUPT
   236                              <1> INT0F: ;Printer
   237 0000EA8E B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   238 0000EA90 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   239 0000EA92 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   240 0000EA94 B030                <1> 	MOV AL, '0'		;SET AL TO CHAR	
   241 0000EA96 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   242 0000EA98 B046                <1> 	MOV AL, 'F'		;SET AL TO CHAR
   243 0000EA9A CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   244 0000EA9C CF                  <1> 	IRET		;RETURN FROM INTERRUPTINT0F:
   245                              <1> 
   246                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <1> ;INT 0X10
   248                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <1> %INCLUDE "code/asm/int10.asm"
     1                              <2> ;40:49	byte	Current video mode
     2                              <2> ;40:4A	word	Number of screen columns
     3                              <2> ;40:4C	word	Size of current video regen buffer in bytes
     4                              <2> ;40:4E	word	Offset of current video page in video regen buffer
     5                              <2> ;40:50  8 words	Cursor position of pages 1-8, high order byte=row
     6                              <2> ;				low order byte=column; changing this data isn't
     7                              <2> ; 				reflected immediately on the display
     8                              <2> ;40:62	byte	Active display page number
     9                              <2> ;40:63	word	Base port address for active 6845 CRT controller
    10                              <2> ;				3B4h = mono, 3D4h = color
    11                              <2> ;40:65	byte	6845 CRT mode control register value (port 3x8h)
    12                              <2> ;				EGA/VGA values emulate those of the MDA/CGA
    13                              <2> ;40:66	byte	CGA current color palette mask setting (port 3d9h)
    14                              <2> ;				EGA and VGA values emulate the CGA
    15                              <2> INT10:  ;Video
    16                              <2> 	;CMP AH, 0X00		;SET VIDEO MODE		
    17                              <2> 	;JZ INT10_AH_00	
    18                              <2> 	;CMP AH, 0X02 		;SET CURSOR POSITION
    19                              <2> 	;JZ INT10_AH_02	
    20                              <2> 	;CMP AH, 0X05 		;SELECT ACTIVE DISPLAY PAGE  
    21                              <2> 	;JZ INT10_AH_05	
    22 0000EA9D 80FC09              <2> 	CMP AH, 0X09 		;WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION
    23 0000EAA0 7503E9B502          <2> 	JZ INT10_AH_09	
    24                              <2> 	;CMP AH, 0X0B 		;SET PALETTE CGA
    25                              <2> 	;JZ INT10_AH_0B		;
    26 0000EAA5 80FC0E              <2> 	CMP AH, 0x0E        ;TELETYPE
    27 0000EAA8 7421                <2> 	JZ .TELETYPE       
    28                              <2> 	;CMP AH, 0X0F 		;GET CURRENT VIDEO MODE
    29                              <2> 	;JZ INT10_AH_0F		;	
    30                              <2> 
    31 0000EAAA CF                  <2> 	IRET			;END
    32                              <2> 	;DEBUGING	
    33 0000EAAB 50                  <2> 	PUSH AX
    34 0000EAAC B40E                <2> 	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
    35 0000EAAE B00D                <2> 	MOV AL, 0X0D	;SET AL TO CHAR	
    36 0000EAB0 CD10                <2> 	INT 0X10		;CALL INTERRUPT 0X10
    37 0000EAB2 B00A                <2> 	MOV AL, 0X0A	;SET AL TO CHAR	
    38 0000EAB4 CD10                <2> 	INT 0X10		;CALL INTERRUPT 0X10
    39 0000EAB6 B049                <2> 	MOV AL, 'I'		;SET AL TO CHAR	
    40 0000EAB8 CD10                <2> 	INT 0X10		;CALL INTERRUPT 0X10
    41 0000EABA B031                <2> 	MOV AL, '1'		;SET AL TO CHAR	
    42 0000EABC CD10                <2> 	INT 0X10		;CALL INTERRUPT 0X10
    43 0000EABE B030                <2> 	MOV AL, '0'		;SET AL TO CHAR
    44 0000EAC0 CD10                <2> 	INT 0X10		;CALL INTERRUPT 0X10
    45 0000EAC2 B020                <2> 	MOV AL, ' '		;SET AL TO CHAR
    46 0000EAC4 CD10                <2> 	INT 0X10		;CALL INTERRUPT 0X10
    47 0000EAC6 58                  <2> 	POP AX
    48 0000EAC7 E8DC07              <2> 	CALL DUMP_REGISTERS	
    49                              <2> 	;HLT
    50 0000EACA CF                  <2> 	IRET			;END
    51                              <2> 	
    52                              <2> 		
    53                              <2>    .TELETYPE: 	;0X0450
    54 0000EACB 50                  <2>  	PUSH AX
    55 0000EACC 53                  <2> 	PUSH BX
    56 0000EACD 51                  <2> 	PUSH CX
    57 0000EACE 52                  <2> 	PUSH DX
    58 0000EACF 57                  <2> 	PUSH DI
    59 0000EAD0 56                  <2> 	PUSH SI
    60 0000EAD1 1E                  <2> 	PUSH DS
    61 0000EAD2 06                  <2> 	PUSH ES
    62                              <2> 
    63 0000EAD3 89DE                <2> 	mov		SI, BX
    64 0000EAD5 E867E7              <2> 	call	cout
    65                              <2> 
    66 0000EAD8 07                  <2>     POP ES
    67 0000EAD9 1F                  <2> 	POP DS
    68 0000EADA 5E                  <2> 	POP SI
    69 0000EADB 5F                  <2> 	POP DI
    70 0000EADC 5A                  <2> 	POP DX
    71 0000EADD 59                  <2> 	POP CX
    72 0000EADE 5B                  <2> 	POP BX
    73 0000EADF 58                  <2> 	POP AX
    74                              <2> 	;STI
    75 0000EAE0 CF                  <2> 	IRET
    76                              <2> 
    77 0000EAE1 50                  <2>  	PUSH AX
    78 0000EAE2 53                  <2> 	PUSH BX
    79 0000EAE3 51                  <2> 	PUSH CX
    80 0000EAE4 52                  <2> 	PUSH DX
    81 0000EAE5 57                  <2> 	PUSH DI
    82 0000EAE6 56                  <2> 	PUSH SI
    83 0000EAE7 1E                  <2> 	PUSH DS
    84 0000EAE8 06                  <2> 	PUSH ES
    85 0000EAE9 50                  <2> 	PUSH AX
    86 0000EAEA B84000              <2> 	MOV AX, 0X0040
    87 0000EAED 8ED8                <2> 	MOV DS, AX					;Set data segment
    88 0000EAEF B400                <2> 	MOV AH, 0X00				;ah=0
    89 0000EAF1 A05100              <2> 	MOV AL, BYTE [0X51]			;Current Row
    90 0000EAF4 8B0E4A00            <2> 	MOV CX, WORD [0x04A] 		;number of cols per row
    91 0000EAF8 01C9                <2> 	ADD CX, CX					;Double col for hidden char data
    92 0000EAFA F6E1                <2> 	MUL CL						;mul Current row * cols
    93 0000EAFC B700                <2> 	MOV BH, 0X00				;BH=0
    94 0000EAFE 8A1E5000            <2> 	MOV BL, BYTE [0X50]			;Set current col
    95 0000EB02 01DB                <2> 	ADD BX, BX					;Double col for hidden char data
    96 0000EB04 01C3                <2> 	ADD BX, AX					;Add in row
    97 0000EB06 B800B8              <2> 	MOV AX, 0XB800				;
    98 0000EB09 8ED8                <2> 	MOV DS, AX					;Set video segment
    99 0000EB0B 58                  <2> 	POP AX						;restore char	
   100 0000EB0C 3C0D                <2> 	CMP AL, 0X0D				;Check for enter
   101 0000EB0E 7503E99200          <2> 	JZ .ENTER					;return carrage
   102 0000EB13 3C0A                <2> 	CMP AL, 0X0A				;Check for line feed
   103 0000EB15 7503E99900          <2> 	JZ .LINE_FEED				;line feed
   104 0000EB1A 3C08                <2> 	CMP AL, 0X08				;check for back space
   105 0000EB1C 7503E9A700          <2> 	JZ .BACKSPACE
   106 0000EB21 8807                <2> 	MOV [BX], AL				;Char out
   107 0000EB23 EB00                <2> 	JMP .MOVE_CURSOR_FORWARD
   108                              <2> 
   109                              <2>  .MOVE_CURSOR_FORWARD:
   110 0000EB25 B84000              <2> 	MOV AX, 0X0040				;Check col
   111 0000EB28 8ED8                <2> 	MOV DS, AX					;Set data segment	
   112 0000EB2A BB5000              <2> 	MOV BX, 0X0050				;Col
   113 0000EB2D B400                <2> 	MOV AH, 0X00				;AH=0
   114 0000EB2F 8A07                <2> 	MOV AL, BYTE [BX]			;get current col
   115 0000EB31 FEC0                <2> 	INC AL						;inc col
   116 0000EB33 3B064A00            <2> 	CMP AX, WORD [0x04A] 		;number of cols per row
   117 0000EB37 7265                <2> 	JB .NOT_END_OF_COL
   118                              <2>   .END_OF_COL:	
   119 0000EB39 B84000              <2>   	MOV AX, 0X0040				;Check col
   120 0000EB3C 8ED8                <2> 	MOV DS, AX					;Set data segment	
   121 0000EB3E BB5000              <2>   	MOV BX, 0X0050				;
   122 0000EB41 B000                <2> 	MOV AL, 0X00				;
   123 0000EB43 8807                <2> 	MOV BYTE [BX], AL			;Set col to 0
   124 0000EB45 BB5100              <2> 	MOV BX, 0X0051				;Row
   125 0000EB48 B400                <2> 	MOV AH, 0X00				;AH=0
   126 0000EB4A 8A07                <2> 	MOV AL, BYTE [BX]			;get current ROW
   127 0000EB4C FEC0                <2> 	INC AL						;inc row
   128 0000EB4E 83F819              <2> 	CMP AX, 0X19				;cmp to 25
   129 0000EB51 7244                <2> 	JB .NOT_END_OF_ROWS
   130                              <2>   .SCROLL_UP:	
   131 0000EB53 FC                  <2> 	CLD							;SCROLL UP	
   132 0000EB54 B84000              <2> 	MOV AX, 0X0040
   133 0000EB57 8ED8                <2> 	MOV DS, AX
   134 0000EB59 803E490000          <2> 	CMP BYTE [0X49], 0X00		;IF MODE 0
   135 0000EB5E 741F                <2> 	JZ .SCROLL_40
   136 0000EB60 803E490001          <2> 	CMP BYTE [0X49], 0X01		;IF MODE 1
   137 0000EB65 7418                <2> 	JZ .SCROLL_40				
   138                              <2> .SCROLL_80:						;MODE 2 AND 3			
   139 0000EB67 B800B8              <2> 	MOV AX, 0XB800
   140 0000EB6A 8EC0                <2> 	MOV ES, AX
   141 0000EB6C BF0000              <2> 	MOV DI, 0X0000
   142 0000EB6F B800B8              <2> 	MOV AX, 0XB800
   143 0000EB72 8ED8                <2> 	MOV DS, AX
   144 0000EB74 BEA000              <2> 	MOV SI, 0X00A0			;NEXT LINE
   145 0000EB77 B9A00F              <2> 	MOV CX, 4000			;TIMES
   146 0000EB7A F3A4                <2> 	REP MOVSB
   147 0000EB7C E99900              <2> 	JMP .END_INT10
   148                              <2> .SCROLL_40:					;MODE 0 AND 1
   149 0000EB7F B800B8              <2> 	MOV AX, 0XB800
   150 0000EB82 8EC0                <2> 	MOV ES, AX
   151 0000EB84 BF0000              <2> 	MOV DI, 0X0000
   152 0000EB87 B800B8              <2> 	MOV AX, 0XB800
   153 0000EB8A 8ED8                <2> 	MOV DS, AX
   154 0000EB8C BE5000              <2> 	MOV SI, 0X0050			;NEXT LINE
   155 0000EB8F B9D007              <2> 	MOV CX, 2000			;TIMES
   156 0000EB92 F3A4                <2> 	REP MOVSB	
   157 0000EB94 E98100              <2> 	JMP .END_INT10
   158                              <2> 	
   159                              <2>  .NOT_END_OF_ROWS:
   160 0000EB97 BB5100              <2> 	MOV BX, 0X0051				;ROW
   161 0000EB9A 8807                <2> 	MOV BYTE [BX], AL			;STORE AL=ROW
   162 0000EB9C EB7A                <2> 	JMP .END_INT10				;END
   163                              <2> 
   164                              <2> .NOT_END_OF_COL:
   165 0000EB9E BB5000              <2> 	MOV BX, 0X0050				;Col
   166 0000EBA1 8807                <2> 	MOV BYTE [BX], AL			;STORE AL=COL
   167 0000EBA3 EB73                <2> 	JMP .END_INT10				;END	
   168                              <2> 
   169                              <2>   .ENTER:
   170 0000EBA5 B84000              <2>   	MOV AX, 0X0040				;Check col
   171 0000EBA8 8ED8                <2> 	MOV DS, AX					;Set data segment	
   172 0000EBAA BB5000              <2>   	MOV BX, 0X0050				;
   173 0000EBAD B000                <2> 	MOV AL, 0X00				;
   174 0000EBAF 8807                <2> 	MOV BYTE [BX], AL			;Set col to 0
   175 0000EBB1 EB65                <2> 	JMP .END_INT10	
   176                              <2> 	
   177                              <2>   .LINE_FEED:
   178 0000EBB3 B84000              <2>   	MOV AX, 0X0040				;Check col
   179 0000EBB6 8ED8                <2> 	MOV DS, AX					;Set data segment	
   180 0000EBB8 BB5100              <2> 	MOV BX, 0X0051				;Row
   181 0000EBBB B400                <2> 	MOV AH, 0X00				;AH=0
   182 0000EBBD 8A07                <2> 	MOV AL, BYTE [BX]			;get current ROW
   183 0000EBBF FEC0                <2> 	INC AL						;inc row
   184 0000EBC1 83F819              <2> 	CMP AX, 0X19				;cmp to 25
   185 0000EBC4 72D1                <2> 	JB .NOT_END_OF_ROWS			;STORE AL IN ROW AND END
   186 0000EBC6 EB8B                <2> 	JMP .SCROLL_UP				;SCROLL UP
   187                              <2> 	
   188                              <2>   .BACKSPACE:	
   189 0000EBC8 83EB02              <2>     SUB BX, 0X0002				;GO BACK A SPACE IN RAM
   190 0000EBCB C60700              <2>     MOV BYTE [BX], 0X00			;Clear char
   191 0000EBCE B84000              <2>  	MOV AX, 0X0040				;Check col
   192 0000EBD1 8ED8                <2> 	MOV DS, AX					;Set data segment	
   193 0000EBD3 BB5000              <2> 	MOV BX, 0X0050				;Col
   194 0000EBD6 B400                <2> 	MOV AH, 0X00				;AH=0
   195 0000EBD8 8A07                <2> 	MOV AL, BYTE [BX]			;get current col
   196 0000EBDA FEC8                <2> 	DEC AL						;
   197 0000EBDC 3B064A00            <2> 	CMP AX, WORD [0x04A] 		;number of cols per row
   198 0000EBE0 722F                <2> 	JB .NOT_BEGIN_OF_COL
   199                              <2>   .BEGIN_OF_COL:	
   200 0000EBE2 B84000              <2>   	MOV AX, 0X0040				;Check col
   201 0000EBE5 8ED8                <2> 	MOV DS, AX					;Set data segment	
   202 0000EBE7 BB5000              <2>   	MOV BX, 0X0050				;
   203 0000EBEA B04F                <2> 	MOV AL, 0X4F				;
   204 0000EBEC 8807                <2> 	MOV BYTE [BX], AL			;Set col to 49
   205 0000EBEE BB5100              <2> 	MOV BX, 0X0051				;Row
   206 0000EBF1 B400                <2> 	MOV AH, 0X00				;AH=0
   207 0000EBF3 8A07                <2> 	MOV AL, BYTE [BX]			;get current ROW
   208 0000EBF5 FEC8                <2> 	DEC AL						;dec row
   209 0000EBF7 83F819              <2> 	CMP AX, 0X19				;cmp to 25
   210 0000EBFA 729B                <2> 	JB .NOT_END_OF_ROWS
   211                              <2>   .BEGIN_OF_ROW:	
   212 0000EBFC BB5000              <2>   	MOV BX, 0X0050				;col
   213 0000EBFF C60700              <2> 	MOV BYTE [BX], 0X00
   214 0000EC02 BB5100              <2> 	MOV BX, 0X0051				;ROW
   215 0000EC05 C60700              <2> 	MOV BYTE [BX], 0X00
   216 0000EC08 EB0E                <2> 	JMP .END_INT10
   217                              <2> 	
   218                              <2>  .NOT_BEGIN_OF_ROW:
   219 0000EC0A BB5100              <2> 	MOV BX, 0X0051				;ROW
   220 0000EC0D 8807                <2> 	MOV BYTE [BX], AL
   221 0000EC0F EB07                <2> 	JMP .END_INT10
   222                              <2> 
   223                              <2> .NOT_BEGIN_OF_COL:
   224 0000EC11 BB5000              <2> 	MOV BX, 0X0050				;Col
   225 0000EC14 8807                <2> 	MOV BYTE [BX], AL
   226 0000EC16 EB00                <2> 	JMP .END_INT10 
   227                              <2>   
   228                              <2>    .END_INT10:
   229 0000EC18 07                  <2>     POP ES
   230 0000EC19 1F                  <2> 	POP DS
   231 0000EC1A 5E                  <2> 	POP SI
   232 0000EC1B 5F                  <2> 	POP DI
   233 0000EC1C 5A                  <2> 	POP DX
   234 0000EC1D 59                  <2> 	POP CX
   235 0000EC1E 5B                  <2> 	POP BX
   236 0000EC1F 58                  <2> 	POP AX
   237                              <2> 	;STI
   238 0000EC20 CF                  <2> 	IRET
   239                              <2> 	
   240                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   241                              <2> ;SET VIDEO MODE
   242                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   243                              <2> INT10_AH_00:				
   244 0000EC21 1E                  <2> 	PUSH DS					;STORE DS
   245 0000EC22 53                  <2> 	PUSH BX					;STORE BX
   246 0000EC23 51                  <2> 	PUSH CX					;STORE CX
   247 0000EC24 50                  <2> 	PUSH AX					;STORE AX
   248 0000EC25 50                  <2> 	PUSH AX					;STORE AX
   249                              <2> 	
   250 0000EC26 B84000              <2> 	MOV AX, 0x0040			;BIOS DATA AREA 0X400
   251 0000EC29 8ED8                <2> 	MOV DS, AX				;SET DS TO BIOS DATA AREA
   252 0000EC2B 58                  <2> 	POP AX					;RESTORE AX
   253                              <2> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;
   254 0000EC2C 2407                <2> 	AND AL, 0X07			;JUST FOR NOW LIMITED MODES AVAILABLE 
   255                              <2> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   256 0000EC2E A24900              <2> 	MOV [0X49], AL			;40:49 SET VIDEO MODE
   257 0000EC31 3C00                <2> 	CMP AL, 0X00			;IF MODE 0
   258 0000EC33 7410                <2> 	JZ .CLEAR_SCREEN_MODE0	;CLEARS SCREEN
   259 0000EC35 3C01                <2> 	CMP AL, 0X01			;IF MODE 1
   260 0000EC37 740C                <2> 	JZ .CLEAR_SCREEN_MODE0	;CLEARS SCREEN
   261 0000EC39 3C02                <2> 	CMP AL, 0X02			;IF MODE 2
   262 0000EC3B 7418                <2> 	JZ .SET_MODE2
   263                              <2> 
   264 0000EC3D 3C03                <2> 	CMP AL, 0X03			;IF MODE 3
   265 0000EC3F 740C                <2> 	JZ .CLEAR_SCREEN_MODE2	;CLEARS SCREEN
   266 0000EC41 3C04                <2> 	CMP AL, 0X04			;IF MODE 4
   267 0000EC43 7457                <2> 	JZ .SET_MODE4
   268                              <2> 
   269                              <2> 	
   270                              <2>  .CLEAR_SCREEN_MODE0:	
   271 0000EC45 C7064A002800        <2> 	MOV WORD [0X004A], 0X0028	;SET COL COUNT 40
   272 0000EC4B EB38                <2> 	JMP .CLEAR_SCREEN_TEXT_MODE
   273                              <2>  .CLEAR_SCREEN_MODE2:
   274 0000EC4D C7064A005000        <2> 	MOV WORD [0X004A], 0X0050	;SET COL COUNT 80
   275 0000EC53 EB30                <2> 	JMP .CLEAR_SCREEN_TEXT_MODE
   276                              <2> 	
   277                              <2>  .SET_MODE2:
   278 0000EC55 C7064A005000        <2> 	MOV WORD [0X004A], 0X0050	;SET COL COUNT 80
   279                              <2> 	
   280 0000EC5B 8CC8                <2> 	MOV AX, CS
   281 0000EC5D 8ED8                <2> 	MOV DS, AX
   282                              <2> 
   283 0000EC5F B400                <2> 	MOV AH, 0X00
   284 0000EC61 B91000              <2> 	MOV CX, 0X0010
   285 0000EC64 BB[F8EC]            <2> 	MOV BX, .CGA_TEXT_80X25
   286                              <2> 
   287 0000EC67 B000                <2> 	MOV AL, 0X00
   288 0000EC69 BAD803              <2> 	MOV DX, 0X03D8
   289 0000EC6C EE                  <2> 	OUT DX, AL
   290                              <2> 
   291                              <2>   .CRT_LOOP_MODE2:
   292 0000EC6D 8A07                <2> 	MOV AL, [BX]
   293 0000EC6F E8B600              <2> 	CALL .WRITE_CGA_REG
   294 0000EC72 FEC4                <2> 	INC AH
   295 0000EC74 43                  <2> 	INC BX
   296 0000EC75 E2F6                <2> 	LOOP .CRT_LOOP_MODE2
   297                              <2> 
   298 0000EC77 B02D                <2> 	MOV AL, 0X2D
   299 0000EC79 BAD803              <2> 	MOV DX, 0X03D8			;MODE CONTROL REG
   300 0000EC7C EE                  <2> 	OUT DX, AL
   301                              <2> 	
   302 0000EC7D B030                <2> 	MOV AL, 0X30
   303 0000EC7F BAD903              <2> 	MOV DX, 0X03D9			;COLOR SELECT REG
   304 0000EC82 EE                  <2> 	OUT DX, AL	
   305                              <2> 	
   306 0000EC83 EB00                <2> 	JMP .CLEAR_SCREEN_TEXT_MODE
   307                              <2> 
   308                              <2>  .CLEAR_SCREEN_TEXT_MODE:
   309 0000EC85 B800B8              <2> 	MOV AX, 0XB800				;VIDEO MEM
   310 0000EC88 8ED8                <2> 	MOV DS, AX					;SET DS
   311 0000EC8A BB0000              <2> 	MOV BX, 0X0000				;BX = 0
   312 0000EC8D B92008              <2> 	MOV CX, 2080 				;TIMES TO LOOP, YES NOT HEX
   313 0000EC90 B80007              <2> 	MOV AX, 0X0700				;0 B/W
   314                              <2>   .LOOP_CLS_MODE0:				;LOOP TO CLEAR SCREEN
   315 0000EC93 8907                <2> 	MOV WORD [BX], AX			;WORD [BX] = AX
   316 0000EC95 83C302              <2> 	ADD BX, 0X0002				;INC BX X2
   317 0000EC98 E2F9                <2> 	LOOP .LOOP_CLS_MODE0		;LOOP TIL DONE	
   318 0000EC9A EB47                <2> 	JMP .END					;END
   319                              <2> 
   320                              <2> .SET_MODE4:
   321 0000EC9C C7064A002800        <2> 	MOV WORD [0X004A], 0X0028	;SET COL COUNT 40
   322                              <2> 	
   323 0000ECA2 8CC8                <2> 	MOV AX, CS
   324 0000ECA4 8ED8                <2> 	MOV DS, AX
   325                              <2> 
   326 0000ECA6 B400                <2> 	MOV AH, 0X00
   327 0000ECA8 B91000              <2> 	MOV CX, 0X0010
   328 0000ECAB BB[08ED]            <2> 	MOV BX, .CGA_GRAPHICS
   329                              <2> 
   330 0000ECAE B000                <2> 	MOV AL, 0X00
   331 0000ECB0 BAD803              <2> 	MOV DX, 0X03D8
   332 0000ECB3 EE                  <2> 	OUT DX, AL
   333                              <2> 
   334                              <2>   .CRT_LOOP_MODE4:
   335 0000ECB4 8A07                <2> 	MOV AL, [BX]
   336 0000ECB6 E86F00              <2> 	CALL .WRITE_CGA_REG
   337 0000ECB9 FEC4                <2> 	INC AH
   338 0000ECBB 43                  <2> 	INC BX
   339 0000ECBC E2F6                <2> 	LOOP .CRT_LOOP_MODE4
   340                              <2> 
   341 0000ECBE B02E                <2> 	MOV AL, 0X2E
   342 0000ECC0 BAD803              <2> 	MOV DX, 0X03D8
   343 0000ECC3 EE                  <2> 	OUT DX, AL
   344                              <2> 	
   345 0000ECC4 B030                <2> 	MOV AL, 0X30
   346 0000ECC6 BAD903              <2> 	MOV DX, 0X03D9			;COLOR SELECT REG
   347 0000ECC9 EE                  <2> 	OUT DX, AL	
   348                              <2> 	
   349                              <2> 	
   350 0000ECCA EB00                <2> 	JMP .CLEAR_SCREEN_MODE4
   351                              <2> 	
   352                              <2>   .CLEAR_SCREEN_MODE4:
   353 0000ECCC B800B8              <2> 	MOV AX, 0XB800				;VIDEO MEM
   354 0000ECCF 8ED8                <2> 	MOV DS, AX					;SET DS
   355 0000ECD1 BB0000              <2> 	MOV BX, 0X0000				;BX = 0
   356 0000ECD4 B90020              <2> 	MOV CX, 0X2000				;TIMES TO LOOP
   357 0000ECD7 B80000              <2> 	MOV AX, 0X0000				;CLEAR SCREEN TO NOTHING 
   358                              <2>   .LOOP_CLS_MODE4:				;LOOP TO CLEAR SCREEN
   359 0000ECDA 8907                <2> 	MOV WORD [BX], AX			;WORD [BX] = AX
   360 0000ECDC 83C302              <2> 	ADD BX, 0X0002				;INC BX X2
   361 0000ECDF E2F9                <2> 	LOOP .LOOP_CLS_MODE4		;LOOP TIL DONE	
   362 0000ECE1 EB00                <2> 	JMP .END					;END
   363                              <2> 
   364                              <2>   .END:
   365 0000ECE3 58                  <2>  	POP AX			;RESTORE AX
   366 0000ECE4 59                  <2>  	POP CX			;RESTORE CX
   367 0000ECE5 5B                  <2> 	POP BX			;RESTORE BX
   368 0000ECE6 1F                  <2> 	POP DS			;RESTORE DS
   369 0000ECE7 CF                  <2> 	IRET
   370                              <2> 
   371                              <2> 
   372                              <2> ; CGA TEXT 40x25 MODE
   373 0000ECE8 38282D0A1F06191C    <2> DB 0X38, 0X28, 0X2D, 0X0A, 0X1F, 0X06, 0X19, 0X1C
   374 0000ECF0 0207060700000000    <2> DB 0X02, 0X07, 0X06, 0X07, 0X00, 0X00, 0X00, 0X00
   375                              <2> 
   376                              <2> ; CGA TEXT 80x25 MODE
   377                              <2> .CGA_TEXT_80X25:
   378 0000ECF8 71505A0A1F06191C    <2> DB 0X71, 0X50, 0X5A, 0X0A, 0X1F, 0X06, 0X19, 0X1C
   379 0000ED00 0207060700000000    <2> DB 0X02, 0X07, 0X06, 0X07, 0X00, 0X00, 0X00, 0X00
   380                              <2> 
   381                              <2> ; CGA GRAPHICS MODE
   382                              <2> .CGA_GRAPHICS:
   383 0000ED08 38282D0A7F066470    <2> DB 0X38, 0X28, 0X2D, 0X0A, 0X7F, 0X06, 0X64, 0X70
   384 0000ED10 0201060700000000    <2> DB 0X02, 0X01, 0X06, 0X07, 0X00, 0X00, 0X00, 0X00
   385                              <2> 
   386                              <2> ; MDA TEXT 80x25 MODE
   387 0000ED18 6150520F19061919    <2> DB 0X61, 0X50, 0X52, 0X0F, 0X19, 0X06, 0X19, 0X19
   388 0000ED20 020D0B0C00000000    <2> DB 0X02, 0X0D, 0X0B, 0X0C, 0X00, 0X00, 0X00, 0X00
   389                              <2> 
   390                              <2> 
   391                              <2> 
   392                              <2> .WRITE_CGA_REG:
   393 0000ED28 52                  <2> 	PUSH DX	
   394 0000ED29 BAD403              <2> 	MOV DX, 0X03D4	; DX = CRTC INDEX PORT
   395 0000ED2C 50                  <2> 	PUSH AX
   396 0000ED2D 88E0                <2> 	MOV AL, AH 		; AH = BYTE, AL = REGISTER NUMBER
   397 0000ED2F EE                  <2> 	OUT DX, AL		; write register number
   398 0000ED30 42                  <2> 	INC DX			; DX = CRTC data port
   399 0000ED31 58                  <2> 	POP AX
   400 0000ED32 EE                  <2> 	OUT DX, AL		; WRITE BYTE
   401 0000ED33 5A                  <2> 	POP DX
   402 0000ED34 C3                  <2> 	RET
   403                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   404                              <2> ;SET CURSOR POSITION
   405                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   406                              <2> INT10_AH_02:
   407 0000ED35 1E                  <2> 	PUSH DS			;STORE DS
   408 0000ED36 53                  <2> 	PUSH BX			;STORE BX
   409 0000ED37 50                  <2> 	PUSH AX			;STORE AX
   410                              <2> 	
   411 0000ED38 B84500              <2> 	MOV AX, 0X0045	;BIOS DATA 0X450 CURSOR POSITION BASE PAGE 0
   412 0000ED3B 8ED8                <2> 	MOV DS, AX		;SET DS TO 0X450
   413 0000ED3D B80200              <2> 	MOV AX, 0X02	;TIMES (BH * 2) TO GET THE PAGE OFFSET FROM 0X450
   414 0000ED40 F6E7                <2> 	MUL BH			;AL = PAGE OFFSET
   415 0000ED42 89C3                <2> 	MOV BX, AX		;BX = AX
   416 0000ED44 8817                <2> 	MOV [BX], DL	;STORE COLUMN
   417 0000ED46 43                  <2> 	INC BX			;INC BX
   418 0000ED47 8837                <2> 	MOV [BX], DH	;STORE ROW	
   419                              <2> 
   420 0000ED49 58                  <2> 	POP AX			;RESTORE AX
   421 0000ED4A 5B                  <2> 	POP BX			;RESTORE BX
   422 0000ED4B 1F                  <2> 	POP DS			;RESTORE DS
   423 0000ED4C CF                  <2> 	IRET
   424                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   425                              <2> ;SELECT ACTIVE DISPLAY PAGE      
   426                              <2> ;"MAYBE WORKS" DONT KNOW IF IT WANTS A NUMBER 0-7 OR MEM ADDRESS OFFSET
   427                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   428                              <2> INT10_AH_05:
   429 0000ED4D 1E                  <2> 	PUSH DS			;STORE DS
   430 0000ED4E 50                  <2> 	PUSH AX			;STORE AX
   431 0000ED4F B84000              <2> 	MOV AX, 0X0040	;BIOS DATA 0X44E ACTIVE DISPLAY PAGE 
   432 0000ED52 8ED8                <2> 	MOV DS, AX		;SET DS
   433 0000ED54 58                  <2> 	POP AX			;RESTORE AX
   434 0000ED55 A24E00              <2> 	MOV [0X4E], AL	;SET PAGE NUMBER [0X0040:0X004E] = AL
   435 0000ED58 1F                  <2> 	POP DS			;RESTORE DS
   436 0000ED59 CF                  <2> 	IRET
   437                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   438                              <2> ;WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION
   439                              <2> ;AL = ASCII character to write
   440                              <2> ;BH = display page  (or mode 13h, background pixel value)		IGNORED
   441                              <2> ;BL = character attribute (text) foreground color (graphics) 
   442                              <2> ;CX = count of characters to write (CX >= 1)					IGNORED
   443                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   444                              <2> INT10_AH_09:	
   445 0000ED5A 1E                  <2> 	PUSH DS			;STORE DS
   446 0000ED5B 52                  <2> 	PUSH DX			;STORE DX
   447 0000ED5C 51                  <2> 	PUSH CX			;STORE CX
   448 0000ED5D 53                  <2> 	PUSH BX			;STORE BX
   449 0000ED5E 50                  <2> 	PUSH AX			;STORE AX
   450                              <2> 	;PUSH BX			;STORE BX
   451                              <2> 	;PUSH AX			;STORE AX
   452                              <2> 
   453 0000ED5F E8DDE4              <2> 	CALL	cout
   454                              <2> 
   455                              <2> 	;MOV AX, 0X0040
   456                              <2> 	;MOV DS, AX					;Set data segment
   457                              <2> 	;MOV AH, 0X00				;ah=0
   458                              <2> 	;MOV AL, BYTE [0X51]			;Current Row
   459                              <2> 	;MOV CX, WORD [0x04A] 		;number of cols per row
   460                              <2> 	;ADD CX, CX					;Double col for hidden char data
   461                              <2> 	;MUL CL						;mul Current row * cols
   462                              <2> 	;MOV BH, 0X00				;BH=0
   463                              <2> 	;MOV BL, BYTE [0X50]			;Set current col
   464                              <2> 	;ADD BX, BX					;Double col for hidden char data
   465                              <2> 	;ADD BX, AX					;Add in row
   466                              <2> 	;MOV AX, 0XB800				;
   467                              <2> 	;MOV DS, AX					;Set video segment
   468                              <2> 	;POP AX						;RESTORE AX
   469                              <2> 	;POP DX						;RESTORE BX
   470                              <2> 	;MOV AH, DL					;GET ATTRIBUTES	
   471                              <2> 	;MOV [BX], AX				
   472                              <2> 	
   473 0000ED62 58                  <2> 	POP AX			;RESTORE AX
   474 0000ED63 5B                  <2> 	POP BX			;RESTORE BX
   475 0000ED64 59                  <2> 	POP CX			;RESTORE CX
   476 0000ED65 5A                  <2> 	POP DX			;RESTORE DX
   477 0000ED66 1F                  <2> 	POP DS			;RESTORE DS
   478 0000ED67 CF                  <2> 	IRET
   479                              <2> 	
   480                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   481                              <2> ;WRITE CHARACTER AT CURSOR POSITION 
   482                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   483                              <2> INT10_AH_0A:
   484 0000ED68 CF                  <2> 	IRET
   485                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   486                              <2> ;SET PALETTE 
   487                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   488                              <2> INT10_AH_0B:		;
   489 0000ED69 1E                  <2> 	PUSH DS			;STORE DS
   490 0000ED6A 50                  <2> 	PUSH AX			;STORE AX
   491 0000ED6B 80FF00              <2> 	CMP BH, 0X00 	;= 0	to set background and border color
   492                              <2> 					;= 1	to select 4 color palette
   493 0000ED6E 7409                <2> 	JZ .END			;ONLY HANDLE BH = 1 FOR NOW
   494 0000ED70 B84000              <2> 	MOV AX, 0x0040	;BIOS DATA AREA 0X400
   495 0000ED73 8ED8                <2> 	MOV DS, AX		;SET DS TO BIOS DATA AREA
   496 0000ED75 881E6600            <2> 	MOV [0X66], BL	;40:66 color palette
   497                              <2> 	
   498                              <2>   .END:				;END OF INT10_AH_0B
   499 0000ED79 58                  <2> 	POP AX			;RESTORE AX
   500 0000ED7A 1F                  <2> 	POP DS			;RESTORE DS
   501 0000ED7B CF                  <2> 	IRET
   502                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
   503                              <2> ;GET VIDEO MODE
   504                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   505                              <2> INT10_AH_0F:
   506 0000ED7C 1E                  <2> 	PUSH DS			;STORE DS
   507 0000ED7D B84000              <2> 	MOV AX, 0x0040	;BIOS DATA AREA 0X400
   508 0000ED80 8ED8                <2> 	MOV DS, AX		;SET DS TO BIOS DATA AREA
   509 0000ED82 8A264A00            <2> 	MOV AH, [0X4A]  ;NUMBER OF SCREEN COLUMNS
   510 0000ED86 A04900              <2> 	MOV AL, [0X49]	;CURRENT MODE
   511 0000ED89 8A3E4E00            <2> 	MOV BH, [0X4E]	;CURRENT PAGE
   512 0000ED8D 1F                  <2> 	POP DS			;RESTORE DS
   513 0000ED8E CF                  <2> 	IRET
   514                              <2> 
   515                              <2> ;----------------------------------------
   516                              <2> ; CHARACTER GENERATOR GRAPHICS FOR 320X200 AND 640X200 GRAPHICS
   517                              <2> ;----------------------------------------
   518                              <2> 
   519 0000ED8F 0000000000000000    <2> 	DB	000H,000H,000H,000H,000H,000H,000H,000H ; D_00
   520 0000ED97 7E81A581BD99817E    <2> 	DB	07EH,081H,0A5H,081H,0BDH,099H,081H,07EH ; D_01
   521 0000ED9F 7EFFDBFFC3E7FF7E    <2> 	DB	07EH,0FFH,0DBH,0FFH,0C3H,0E7H,0FFH,07EH ; D_02
   522 0000EDA7 6CFEFEFE7C381000    <2> 	DB	06CH,0FEH,0FEH,0FEH,07CH,038H,010H,000H ; D_03
   523 0000EDAF 10387CFE7C381008    <2> 	DB	010H,038H,07CH,0FEH,07CH,038H,010H,008H ; D_04
   524 0000EDB7 387C38FEFE7C387C    <2> 	DB	038H,07CH,038H,0FEH,0FEH,07CH,038H,07CH ; D_05
   525 0000EDBF 1010387CFE7C387C    <2> 	DB	010H,010H,038H,07CH,0FEH,07CH,038H,07CH ; D_06
   526 0000EDC7 0000183C3C180000    <2> 	DB	000H,000H,018H,03CH,03CH,018H,000H,000H ; D_07
   527 0000EDCF FFFFE7C3C3E7FFFF    <2> 	DB	0FFH,0FFH,0E7H,0C3H,0C3H,0E7H,0FFH,0FFH ; D_08
   528 0000EDD7 003C664242663C00    <2> 	DB	000H,03CH,066H,042H,042H,066H,03CH,000H ; D_09
   529 0000EDDF FFC399BDBD99C3FF    <2> 	DB	0FFH,0C3H,099H,0BDH,0BDH,099H,0C3H,0FFH ; D_0A
   530 0000EDE7 0F070F7DCCCCCC78    <2> 	DB	00FH,007H,00FH,07DH,0CCH,0CCH,0CCH,078H ; D_08
   531 0000EDEF 3C6666663C187E18    <2> 	DB	03CH,066H,066H,066H,03CH,018H,07EH,018H ; D_0C
   532 0000EDF7 3F333F303070F0E0    <2> 	DB	03FH,033H,03FH,030H,030H,070H,0F0H,0E0H ; D_0D
   533 0000EDFF 7F637F636367E6C0    <2> 	DB	07FH,063H,07FH,063H,063H,067H,0E6H,0C0H ; D_0E
   534 0000EE07 995A3CE7E73C5A99    <2> 	DB	099H,05AH,03CH,0E7H,0E7H,03CH,05AH,099H ; D_0F
   535                              <2> 
   536 0000EE0F 80E0F8FEF8E08000    <2> 	DB	080H,0E0H,0F8H,0FEH,0F8H,0E0H,080H,000H ; D_10
   537 0000EE17 020E3EFE3E0E0200    <2> 	DB	002H,00EH,03EH,0FEH,03EH,00EH,002H,000H ; D_11
   538 0000EE1F 183C7E18187E3C18    <2> 	DB	018H,03CH,07EH,018H,018H,07EH,03CH,018H ; D_12
   539 0000EE27 6666666666006600    <2> 	DB	066H,066H,066H,066H,066H,000H,066H,000H ; D_13
   540 0000EE2F 7FDBDB7B1B1B1B00    <2> 	DB	07FH,0DBH,0DBH,07BH,01BH,01BH,01BH,000H ; D_14
   541 0000EE37 3E63386C6C38CC78    <2> 	DB	03EH,063H,038H,06CH,06CH,038H,0CCH,078H ; D_15
   542 0000EE3F 000000007E7E7E00    <2> 	DB	000H,000H,000H,000H,07EH,07EH,07EH,000H ; D_16
   543 0000EE47 183C7E187E3C18FF    <2> 	DB	018H,03CH,07EH,018H,07EH,03CH,018H,0FFH ; D_17
   544 0000EE4F 183C7E1818181800    <2> 	DB	018H,03CH,07EH,018H,018H,018H,018H,000H ; D_18
   545 0000EE57 181818187E3C1800    <2> 	DB	018H,018H,018H,018H,07EH,03CH,018H,000H ; D_19
   546 0000EE5F 00180CFE0C180000    <2> 	DB	000H,018H,00CH,0FEH,00CH,018H,000H,000H ; D_1A
   547 0000EE67 003060FE60300000    <2> 	DB	000H,030H,060H,0FEH,060H,030H,000H,000H ; D_1B
   548 0000EE6F 0000C0C0C0FE0000    <2> 	DB	000H,000H,0C0H,0C0H,0C0H,0FEH,000H,000H ; D_1C
   549 0000EE77 002466FF66240000    <2> 	DB	000H,024H,066H,0FFH,066H,024H,000H,000H ; D_1D
   550 0000EE7F 00183C7EFFFF0000    <2> 	DB	000H,018H,03CH,07EH,0FFH,0FFH,000H,000H ; D_1E
   551 0000EE87 00FFFF7E3C180000    <2> 	DB	000H,0FFH,0FFH,07EH,03CH,018H,000H,000H ; D_1F
   552                              <2> 
   553 0000EE8F 0000000000000000    <2> 	DB	000H,000H,000H,000H,000H,000H,000H,000H ; SP D_20
   554 0000EE97 3078783030003000    <2> 	DB	030H,078H,078H,030H,030H,000H,030H,000H ; ! D_21
   555 0000EE9F 6C6C6C0000000000    <2> 	DB	06CH,06CH,06CH,000H,000H,000H,000H,000H ; " D_22
   556 0000EEA7 6C6CFE6CFE6C6C00    <2> 	DB	06CH,06CH,0FEH,06CH,0FEH,06CH,06CH,000H ; # D_23
   557 0000EEAF 307CC0780CF83000    <2> 	DB	030H,07CH,0C0H,078H,00CH,0F8H,030H,000H ; $ D_24
   558 0000EEB7 00C6CC183066C600    <2> 	DB	000H,0C6H,0CCH,018H,030H,066H,0C6H,000H ; PER CENT D_25
   559 0000EEBF 386C3876DCCC7600    <2> 	DB	038H,06CH,038H,076H,0DCH,0CCH,076H,000H ; & D_26
   560 0000EEC7 6060C00000000000    <2> 	DB	060H,060H,0C0H,000H,000H,000H,000H,000H ; ' D_27
   561 0000EECF 1830606060301800    <2> 	DB	018H,030H,060H,060H,060H,030H,018H,000H ; ( D_28
   562 0000EED7 6030181818306000    <2> 	DB	060H,030H,018H,018H,018H,030H,060H,000H ; ) D_29
   563 0000EEDF 00663CFF3C660000    <2> 	DB	000H,066H,03CH,0FFH,03CH,066H,000H,000H ; * D_2A
   564 0000EEE7 003030FC30300000    <2> 	DB	000H,030H,030H,0FCH,030H,030H,000H,000H ; + D_2B
   565 0000EEEF 0000000000303060    <2> 	DB	000H,000H,000H,000H,000H,030H,030H,060H ; , D_2C
   566 0000EEF7 000000FC00000000    <2> 	DB	000H,000H,000H,0FCH,000H,000H,000H,000H ; - D_2D
   567 0000EEFF 0000000000303000    <2> 	DB	000H,000H,000H,000H,000H,030H,030H,000H ; . D_2E
   568 0000EF07 060C183060C08000    <2> 	DB	006H,00CH,018H,030H,060H,0C0H,080H,000H ; / D_2F
   569                              <2> 
   570 0000EF0F 7CC6CEDEF6E67C00    <2> 	DB	07CH,0C6H,0CEH,0DEH,0F6H,0E6H,07CH,000H ; 0 D_30
   571 0000EF17 307030303030FC00    <2> 	DB	030H,070H,030H,030H,030H,030H,0FCH,000H ; 1 D_31
   572 0000EF1F 78CC0C3860CCFC00    <2> 	DB	078H,0CCH,00CH,038H,060H,0CCH,0FCH,000H ; 2 D_32
   573 0000EF27 78CC0C380CCC7800    <2> 	DB	078H,0CCH,00CH,038H,00CH,0CCH,078H,000H ; 3 D_33
   574 0000EF2F 1C3C6CCCFE0C1E00    <2> 	DB	01CH,03CH,06CH,0CCH,0FEH,00CH,01EH,000H ; 4 D_34
   575 0000EF37 FCC0F80C0CCC7800    <2> 	DB	0FCH,0C0H,0F8H,00CH,00CH,0CCH,078H,000H ; 5 D_35
   576 0000EF3F 3860C0F8CCCC7800    <2> 	DB	038H,060H,0C0H,0F8H,0CCH,0CCH,078H,000H ; 6 D_36
   577 0000EF47 FCCC0C1830303000    <2> 	DB	0FCH,0CCH,00CH,018H,030H,030H,030H,000H ; 7 D_37
   578 0000EF4F 78CCCC78CCCC7800    <2> 	DB	078H,0CCH,0CCH,078H,0CCH,0CCH,078H,000H ; 8 D_38
   579 0000EF57 78CCCC7C0C187000    <2> 	DB	078H,0CCH,0CCH,07CH,00CH,018H,070H,000H ; 9 D_39
   580 0000EF5F 0030300000303000    <2> 	DB	000H,030H,030H,000H,000H,030H,030H,000H ; : D_3A
   581 0000EF67 0030300000303060    <2> 	DB	000H,030H,030H,000H,000H,030H,030H,060H ; ; D_3B
   582 0000EF6F 183060C060301800    <2> 	DB	018H,030H,060H,0C0H,060H,030H,018H,000H ; < D_3C
   583 0000EF77 0000FC0000FC0000    <2> 	DB	000H,000H,0FCH,000H,000H,0FCH,000H,000H ; = D_3D
   584 0000EF7F 6030180C18306000    <2> 	DB	060H,030H,018H,00CH,018H,030H,060H,000H ; > D_3E
   585 0000EF87 78CC0C1830003000    <2> 	DB	078H,0CCH,00CH,018H,030H,000H,030H,000H ; ? D_3F
   586                              <2> 
   587 0000EF8F 7CC6DEDEDEC07800    <2> 	DB	07CH,0C6H,0DEH,0DEH,0DEH,0C0H,078H,000H ; @ D_40
   588 0000EF97 3078CCCCFCCCCC00    <2> 	DB	030H,078H,0CCH,0CCH,0FCH,0CCH,0CCH,000H ; A D_41
   589 0000EF9F FC66667C6666FC00    <2> 	DB	0FCH,066H,066H,07CH,066H,066H,0FCH,000H ; B D_42
   590 0000EFA7 3C66C0C0C0663C00    <2> 	DB	03CH,066H,0C0H,0C0H,0C0H,066H,03CH,000H ; C D_43
   591 0000EFAF F86C6666666CF800    <2> 	DB	0F8H,06CH,066H,066H,066H,06CH,0F8H,000H ; D D_44
   592 0000EFB7 FE6268786862FE00    <2> 	DB	0FEH,062H,068H,078H,068H,062H,0FEH,000H ; E D_45
   593 0000EFBF FE6268786860F000    <2> 	DB	0FEH,062H,068H,078H,068H,060H,0F0H,000H ; F D_46
   594 0000EFC7 3C66C0C0CE663E00    <2> 	DB	03CH,066H,0C0H,0C0H,0CEH,066H,03EH,000H ; G D_47
   595 0000EFCF CCCCCCFCCCCCCC00    <2> 	DB	0CCH,0CCH,0CCH,0FCH,0CCH,0CCH,0CCH,000H ; H D_48
   596 0000EFD7 7830303030307800    <2> 	DB	078H,030H,030H,030H,030H,030H,078H,000H ; I D_49
   597 0000EFDF 1E0C0C0CCCCC7800    <2> 	DB	01EH,00CH,00CH,00CH,0CCH,0CCH,078H,000H ; J D_4A
   598 0000EFE7 E6666C786C66E600    <2> 	DB	0E6H,066H,06CH,078H,06CH,066H,0E6H,000H ; K D_4B
   599 0000EFEF F06060606266FE00    <2> 	DB	0F0H,060H,060H,060H,062H,066H,0FEH,000H ; L D_4C
   600 0000EFF7 C6EEFEFED6C6C600    <2> 	DB	0C6H,0EEH,0FEH,0FEH,0D6H,0C6H,0C6H,000H ; M D_4C
   601 0000EFFF C6E6F6DECEC6C600    <2> 	DB	0C6H,0E6H,0F6H,0DEH,0CEH,0C6H,0C6H,000H ; N D_4E
   602 0000F007 386CC6C6C66C3800    <2> 	DB	038H,06CH,0C6H,0C6H,0C6H,06CH,038H,000H ; O D_4F
   603                              <2> 
   604 0000F00F FC66667C6060F000    <2> 	DB	0FCH,066H,066H,07CH,060H,060H,0F0H,000H ; P D_50
   605 0000F017 78CCCCCCDC781C00    <2> 	DB	078H,0CCH,0CCH,0CCH,0DCH,078H,01CH,000H ; Q D_51
   606 0000F01F FC66667C6C66E600    <2> 	DB	0FCH,066H,066H,07CH,06CH,066H,0E6H,000H ; R D_52
   607 0000F027 78CCE0701CCC7800    <2> 	DB	078H,0CCH,0E0H,070H,01CH,0CCH,078H,000H ; S D_53
   608 0000F02F FCB4303030307800    <2> 	DB	0FCH,0B4H,030H,030H,030H,030H,078H,000H ; T D_54
   609 0000F037 CCCCCCCCCCCCFC00    <2> 	DB	0CCH,0CCH,0CCH,0CCH,0CCH,0CCH,0FCH,000H ; U D_55
   610 0000F03F CCCCCCCCCC783000    <2> 	DB	0CCH,0CCH,0CCH,0CCH,0CCH,078H,030H,000H ; V D_56
   611 0000F047 C6C6C6D6FEEEC600    <2> 	DB	0C6H,0C6H,0C6H,0D6H,0FEH,0EEH,0C6H,000H ; W D_57
   612 0000F04F C6C66C38386CC600    <2> 	DB	0C6H,0C6H,06CH,038H,038H,06CH,0C6H,000H ; X D_58
   613 0000F057 CCCCCC7830307800    <2> 	DB	0CCH,0CCH,0CCH,078H,030H,030H,078H,000H ; Y D_59
   614 0000F05F FEC68C183266FE00    <2> 	DB	0FEH,0C6H,08CH,018H,032H,066H,0FEH,000H ; Z D_5A
   615 0000F067 7860606060607800    <2> 	DB	078H,060H,060H,060H,060H,060H,078H,000H ; [ D_5B
   616 0000F06F C06030180C060200    <2> 	DB	0C0H,060H,030H,018H,00CH,006H,002H,000H ; BACKSLASH D_5C
   617 0000F077 7818181818187800    <2> 	DB	078H,018H,018H,018H,018H,018H,078H,000H ; ] D_5D
   618 0000F07F 10386CC600000000    <2> 	DB	010H,038H,06CH,0C6H,000H,000H,000H,000H ; CIRCUMFLEX D_5E
   619 0000F087 00000000000000FF    <2> 	DB	000H,000H,000H,000H,000H,000H,000H,0FFH ; _ D_5F
   620                              <2> 
   621 0000F08F 3030180000000000    <2> 	DB	030H,030H,018H,000H,000H,000H,000H,000H ;   D_60
   622 0000F097 0000780C7CCC7600    <2> 	DB	000H,000H,078H,00CH,07CH,0CCH,076H,000H ; LOWER CASE A D_61
   623 0000F09F E060607C6666DC00    <2> 	DB	0E0H,060H,060H,07CH,066H,066H,0DCH,000H ; L.C. B D_62
   624 0000F0A7 000078CCC0CC7800    <2> 	DB	000H,000H,078H,0CCH,0C0H,0CCH,078H,000H ; L.C. C D_63
   625 0000F0AF 1C0C0C7CCCCC7600    <2> 	DB	01CH,00CH,00CH,07CH,0CCH,0CCH,076H,000H ; L.C. D D_64
   626 0000F0B7 000078CCFCC07800    <2> 	DB	000H,000H,078H,0CCH,0FCH,0C0H,078H,000H ; L.C. E D_65
   627 0000F0BF 386C60F06060F000    <2> 	DB	038H,06CH,060H,0F0H,060H,060H,0F0H,000H ; L.C. F D_66
   628 0000F0C7 000076CCCC7C0CF8    <2> 	DB	000H,000H,076H,0CCH,0CCH,07CH,00CH,0F8H ; L.C. G D_67
   629 0000F0CF E0606C766666E600    <2> 	DB	0E0H,060H,06CH,076H,066H,066H,0E6H,000H ; L.C. H D_68
   630 0000F0D7 3000703030307800    <2> 	DB	030H,000H,070H,030H,030H,030H,078H,000H ; L.C. I D_69
   631 0000F0DF 0C000C0C0CCCCC78    <2> 	DB	00CH,000H,00CH,00CH,00CH,0CCH,0CCH,078H ; L.C. J D_6A
   632 0000F0E7 E060666C786CE600    <2> 	DB	0E0H,060H,066H,06CH,078H,06CH,0E6H,000H ; L.C. K D_6B
   633 0000F0EF 7030303030307800    <2> 	DB	070H,030H,030H,030H,030H,030H,078H,000H ; L.C. L D_6C
   634 0000F0F7 0000CCFEFED6C600    <2> 	DB	000H,000H,0CCH,0FEH,0FEH,0D6H,0C6H,000H ; L.C. M D_6D
   635 0000F0FF 0000F8CCCCCCCC00    <2> 	DB	000H,000H,0F8H,0CCH,0CCH,0CCH,0CCH,000H ; L.C. N D_6E
   636 0000F107 000078CCCCCC7800    <2> 	DB	000H,000H,078H,0CCH,0CCH,0CCH,078H,000H ; L.C. O D_6F
   637                              <2> 
   638 0000F10F 0000DC66667C60F0    <2> 	DB	000H,000H,0DCH,066H,066H,07CH,060H,0F0H ; L.C. P D_70
   639 0000F117 000076CCCC7C0C1E    <2> 	DB	000H,000H,076H,0CCH,0CCH,07CH,00CH,01EH ; L.C. Q D_71
   640 0000F11F 0000DC766660F000    <2> 	DB	000H,000H,0DCH,076H,066H,060H,0F0H,000H ; L.C. R D_72
   641 0000F127 00007CC0780CF800    <2> 	DB	000H,000H,07CH,0C0H,078H,00CH,0F8H,000H ; L.C. S D_73
   642 0000F12F 10307C3030341800    <2> 	DB	010H,030H,07CH,030H,030H,034H,018H,000H ; L.C. T D_74
   643 0000F137 0000CCCCCCCC7600    <2> 	DB	000H,000H,0CCH,0CCH,0CCH,0CCH,076H,000H ; L.C. U D_75
   644 0000F13F 0000CCCCCC783000    <2> 	DB	000H,000H,0CCH,0CCH,0CCH,078H,030H,000H ; L.C. V D_76
   645 0000F147 0000C6D6FEFE6C00    <2> 	DB	000H,000H,0C6H,0D6H,0FEH,0FEH,06CH,000H ; L.C. W D_77
   646 0000F14F 0000C66C386CC600    <2> 	DB	000H,000H,0C6H,06CH,038H,06CH,0C6H,000H ; L.C. X D_78
   647 0000F157 0000CCCCCC7C0CF8    <2> 	DB	000H,000H,0CCH,0CCH,0CCH,07CH,00CH,0F8H ; L.C. Y D_79
   648 0000F15F 0000FC983064FC00    <2> 	DB	000H,000H,0FCH,098H,030H,064H,0FCH,000H ; L.C. Z D_7A
   649 0000F167 1C3030E030301C00    <2> 	DB	01CH,030H,030H,0E0H,030H,030H,01CH,000H ;   D_7B
   650 0000F16F 1818180018181800    <2> 	DB	018H,018H,018H,000H,018H,018H,018H,000H ;   D_7C
   651 0000F177 E030301C3030E000    <2> 	DB	0E0H,030H,030H,01CH,030H,030H,0E0H,000H ;   D_7D
   652 0000F17F 76DC000000000000    <2> 	DB	076H,0DCH,000H,000H,000H,000H,000H,000H ;   D_7E
   653 0000F187 0010386CC6C6FE00    <2> 	DB	000H,010H,038H,06CH,0C6H,0C6H,0FEH,000H ; DELTA D_7F
   654                              <2> 
   250                              <1> 
   251                              <1> INT11: ;Equipment Check	
   252 0000F18F 1E                  <1> 	PUSH DS			;STORE DS
   253 0000F190 53                  <1> 	PUSH BX			;STORE BX
   254 0000F191 B84000              <1> 	MOV AX, 0X0040			;BIOS DATA AREA
   255 0000F194 8ED8                <1> 	MOV DS, AX			;SET DATA SEGMENT
   256 0000F196 BB1000              <1> 	MOV BX, 0X0010			;OFFSET 0X10 EQUIPMENT LIST
   257 0000F199 8B07                <1> 	MOV AX, WORD [BX]			;STORE EQUPMENT LIST AX
   258 0000F19B 5B                  <1> 	POP BX			;RESTORE BX
   259 0000F19C 1F                  <1> 	POP DS			;RESTORE DS
   260 0000F19D CF                  <1> 	IRET			;RETRUN
   261                              <1> INT12: ;Memory	
   262 0000F19E 1E                  <1> 	PUSH DS			;STORE DS
   263 0000F19F 53                  <1> 	PUSH BX			;STORE BX
   264 0000F1A0 B84000              <1> 	MOV AX, 0X0040			;BIOS DATA AREA
   265 0000F1A3 8ED8                <1> 	MOV DS, AX			;SET DATA SEGMENT
   266 0000F1A5 BB1300              <1> 	MOV BX, 0X0013			;OFFSET 0X13 FOR MEMORY SIZE
   267 0000F1A8 8B07                <1> 	MOV AX, WORD [BX]			;STORE MEMORY SIZE AX
   268 0000F1AA 5B                  <1> 	POP BX			;RESTORE BX
   269 0000F1AB 1F                  <1> 	POP DS			;RESTORE DS
   270 0000F1AC CF                  <1> 	IRET			;RETRUN
   271                              <1> 
   272                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   273                              <1> ;INT 0X13
   274                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   275                              <1> ;;%INCLUDE "code/asm/int13.asm"
   276                              <1> 
   277                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   278                              <1> ;INT14: ;Communications
   279                              <1> ;	IRET
   280                              <1> ;%INCLUDE "code/serial2.inc"
   281                              <1> INT14:
   282 0000F1AD CF                  <1> 	iret
   283                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   284                              <1> 
   285                              <1> INT15: ;Cassette
   286 0000F1AE B000                <1> 	MOV AL, 0X00			;AL = 0X00
   287 0000F1B0 B486                <1> 	MOV AH, 0X86			;NO CASSETTE PRESENT
   288 0000F1B2 F9                  <1> 	STC			;NOT BIOS SUPPORTED
   289                              <1> 				;THIS IS HOW I RETURN THE CARRY FLAG
   290 0000F1B3 50                  <1> 	PUSH AX			;STORE AX
   291 0000F1B4 9C                  <1> 	PUSHF			;STORE FLAGS
   292 0000F1B5 58                  <1> 	POP AX			;GET AX = FLAGS
   293 0000F1B6 55                  <1> 	PUSH BP			;STORE BP
   294 0000F1B7 89E5                <1> 	MOV BP, SP              ;Copy SP to BP for use as index
   295 0000F1B9 83C508              <1> 	ADD BP, 0X08			;offset 8
   296 0000F1BC 836600FE            <1> 	AND WORD [BP], 0XFFFE			;CLEAR CF = ZER0
   297 0000F1C0 83E001              <1> 	AND AX, 0X0001			;ONLY CF 
   298 0000F1C3 094600              <1> 	OR	WORD [BP], AX		;SET CF AX
   299 0000F1C6 5D                  <1> 	POP BP               			;RESTORE BASE POINTER
   300 0000F1C7 58                  <1> 	POP AX			;RESTORE AX	
   301 0000F1C8 CF                  <1> 	IRET			;RETRUN	
   302                              <1> 	
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ;INT 0X16
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> %INCLUDE "code/asm/int16.asm"
     1                              <2> INT16: ;Keyboard
     2                              <2> 
     3 0000F1C9 80FC00              <2> 	CMP AH, 0X00			;Check ah 
     4 0000F1CC 740C                <2> 	JZ .WAIT_FOR_KEY			;ah=0
     5 0000F1CE 80FC01              <2> 	CMP AH, 0X01					
     6 0000F1D1 7438                <2> 	JZ .CHECK_ZERO_FLAG			;ah=1
     7 0000F1D3 80FC02              <2> 	CMP AH, 0X02					
     8 0000F1D6 745D                <2> 	JZ .GET_SHIFT_FLAGS			;ah=2
     9 0000F1D8 FB                  <2> 	STI
    10 0000F1D9 CF                  <2> 	IRET
    11                              <2> 
    12                              <2>   .WAIT_FOR_KEY:
    13 0000F1DA 53                  <2> 	PUSH BX
    14 0000F1DB 1E                  <2> 	PUSH DS
    15                              <2>   .WAIT_FOR_KEY_LOOP:
    16 0000F1DC FB                  <2> 	STI
    17 0000F1DD B84000              <2> 	MOV AX, 0X0040
    18 0000F1E0 8ED8                <2> 	MOV DS, AX
    19 0000F1E2 FA                  <2> 	CLI
    20 0000F1E3 8B1E1A00            <2> 	MOV BX, [0X001A]			;Tail
    21 0000F1E7 3B1E1C00            <2> 	CMP BX, [0X001C]			;Head
    22 0000F1EB 74EF                <2> 	JZ .WAIT_FOR_KEY_LOOP
    23 0000F1ED 8B07                <2> 	MOV AX, [BX]				;GET SCAN CODE / CHAR CODE 
    24 0000F1EF 83C302              <2> 	ADD BX, 0X0002			   	;Mov bx forward through buffer
    25 0000F1F2 3B1E8200            <2> 	CMP BX, [0X0082]			;Check to see if at the end
    26 0000F1F6 7204                <2> 	JB .NOT_END_OF_BUFFER		;Jump over next step if not at the end
    27 0000F1F8 8B1E8000            <2> 	MOV BX, [0X0080]			;Set bx back to begining 
    28                              <2> 	.NOT_END_OF_BUFFER:
    29 0000F1FC 891E1A00            <2> 	MOV [0X001A], BX	
    30 0000F200 1F                  <2> 	POP DS
    31 0000F201 5B                  <2> 	POP BX
    32 0000F202 3CE0                <2> 	CMP AL, 0XE0
    33 0000F204 7402                <2> 	JZ .AL_0
    34 0000F206 FB                  <2> 	STI
    35 0000F207 CF                  <2> 	IRET
    36                              <2> 	
    37                              <2>   .AL_0:
    38 0000F208 B000                <2> 	MOV AL, 0x00
    39 0000F20A CF                  <2> 	IRET
    40                              <2> 
    41                              <2>   .CHECK_ZERO_FLAG:	
    42 0000F20B 53                  <2>   	PUSH BX				
    43 0000F20C 1E                  <2> 	PUSH DS
    44 0000F20D B84000              <2> 	MOV AX, 0X0040
    45 0000F210 8ED8                <2> 	MOV DS, AX
    46                              <2> 
    47 0000F212 8B1E1A00            <2> 	MOV BX, [0X001A]			;Tail
    48 0000F216 3B1E1C00            <2> 	CMP BX, [0X001C]			;Head
    49 0000F21A 8B07                <2> 	MOV AX, [BX]
    50 0000F21C 1F                  <2> 	POP DS
    51 0000F21D 5B                  <2> 	POP BX
    52                              <2> 	
    53 0000F21E 50                  <2> 	PUSH AX					;STORE AX
    54 0000F21F 9C                  <2> 	PUSHF					;STORE FLAGES
    55 0000F220 58                  <2> 	POP AX					;AX = FLAGS
    56 0000F221 55                  <2>     PUSH BP					;STORE BP
    57 0000F222 89E5                <2> 	MOV BP, SP             	;Copy SP to BP for use as index
    58 0000F224 83C508              <2> 	ADD BP, 0X08			;offset 8
    59 0000F227 836600BF            <2> 	AND WORD [BP], 0XFFBF	;CLEAR ZF
    60 0000F22B 83E040              <2> 	AND AX, 0X0040			;ONLY ZF
    61 0000F22E 094600              <2> 	OR	WORD [BP], AX		;SET ZF
    62 0000F231 5D                  <2> 	POP BP               	;RESTORE BASE POINTER
    63 0000F232 58                  <2> 	POP AX					;RESTORE AX
    64 0000F233 FB                  <2> 	STI
    65 0000F234 CF                  <2> 	IRET
    66                              <2> 	
    67                              <2>   .GET_SHIFT_FLAGS:	  
    68 0000F235 B80000              <2> 	MOV AX, 0X0000			;FOR NOW RETURNS NOTHING. 
    69 0000F238 FB                  <2> 	STI
    70 0000F239 CF                  <2> 	IRET
   307                              <1> 	
   308                              <1> INT17: ;Printer	
   309 0000F23A CF                  <1> 	IRET
   310                              <1> 
   311                              <1> INT18: ;Resident Basic
   312 0000F23B B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   313 0000F23D B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   314 0000F23F CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   315 0000F241 B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   316 0000F243 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   317 0000F245 B038                <1> 	MOV AL, '8'		;SET AL TO CHAR
   318 0000F247 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   319                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   320 0000F249 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   321                              <1> 
   322                              <1> INT19: ;Bootstrap
   323 0000F24A EA0000FFFF          <1> 	JMP 0XFFFF:0X0000			;JUMPS TO BOOT CODE
   324                              <1> 
   325                              <1> INT1A: ;Time of Day
   326 0000F24F 1E                  <1> 	PUSH DS
   327 0000F250 53                  <1>   	PUSH BX
   328 0000F251 B84000              <1> 	MOV AX, 0X0040			;BIOS DATA AREA
   329 0000F254 8ED8                <1> 	MOV DS, AX			;SET DS
   330 0000F256 BB6C00              <1> 	MOV BX, 0X006C			;NUMBER OF CLICKS
   331 0000F259 8B17                <1> 	MOV DX, WORD [BX]			;SET DX CLICKS
   332 0000F25B 83C302              <1> 	ADD BX, 0X0002
   333 0000F25E 8B0F                <1> 	MOV CX, WORD [BX]			;0X006E
   334 0000F260 83E10F              <1> 	AND CX, 0x000F
   335 0000F263 B80000              <1> 	MOV AX, 0X0000			;
   336 0000F266 5B                  <1> 	POP BX
   337 0000F267 1F                  <1> 	POP DS
   338 0000F268 CF                  <1> 	IRET
   339                              <1> 
   340                              <1> INT1B: ;Keyboard Break
   341 0000F269 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   342 0000F26B B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   343 0000F26D CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   344 0000F26F B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   345 0000F271 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   346 0000F273 B042                <1> 	MOV AL, 'B'		;SET AL TO CHAR
   347 0000F275 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   348                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   349 0000F277 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   350                              <1> 
   351                              <1> INT1C: ;Timer Tick
   352 0000F278 CF                  <1> 	IRET			;RETURN FROM INTERRUPT
   353                              <1> 
   354                              <1> INT1D: ;Video Initialization 
   355 0000F279 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   356 0000F27B B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   357 0000F27D CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   358 0000F27F B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   359 0000F281 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   360 0000F283 B044                <1> 	MOV AL, 'D'		;SET AL TO CHAR
   361 0000F285 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   362                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   363 0000F287 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   364                              <1> 
   365                              <1> INT1E: ;Diskette Parameters
   366 0000F288 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   367 0000F28A B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   368 0000F28C CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   369 0000F28E B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   370 0000F290 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   371 0000F292 B045                <1> 	MOV AL, 'E'		;SET AL TO CHAR
   372 0000F294 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   373                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   374 0000F296 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   375                              <1> 
   376                              <1> INT1F: ;Video Graphics Characters
   377 0000F297 B40E                <1> 	MOV AH, 0X0E		;SET AH 0X0E FOR TELOTYPE
   378 0000F299 B049                <1> 	MOV AL, 'I'		;SET AL TO CHAR	
   379 0000F29B CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   380 0000F29D B031                <1> 	MOV AL, '1'		;SET AL TO CHAR	
   381 0000F29F CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   382 0000F2A1 B046                <1> 	MOV AL, 'F'		;SET AL TO CHAR
   383 0000F2A3 CD10                <1> 	INT 0X10		;CALL INTERRUPT 0X10
   384                              <1> ;	HLT		;HLT PROCESSOR NOT SUPPORTED INTERRUPT
   385 0000F2A5 CF                  <1> 	IRET		;RETURN FROM INTERRUPT
   386                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   387                              <1> ;EXTRA FUNCTIONS
   388                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   389                              <1> %INCLUDE "code/asm/functions.asm"
     1                              <2> ;EXTRA FUNCTIONS
     2                              <2> DUMP_REGISTERS:	
     3 0000F2A6 50                  <2> 	PUSH AX
     4 0000F2A7 52                  <2> 	PUSH DX
     5 0000F2A8 51                  <2> 	PUSH CX
     6 0000F2A9 53                  <2> 	PUSH BX
     7 0000F2AA 50                  <2> 	PUSH AX	
     8                              <2> 	
     9 0000F2AB B40E                <2> 	MOV AH, 0X0E
    10 0000F2AD B020                <2> 	MOV AL, ' '
    11 0000F2AF CD10                <2> 	INT 0X10
    12 0000F2B1 B041                <2> 	MOV AL, 'A'
    13 0000F2B3 CD10                <2> 	INT 0X10
    14 0000F2B5 B058                <2> 	MOV AL, 'X'	
    15 0000F2B7 CD10                <2> 	INT 0X10
    16 0000F2B9 B03D                <2> 	MOV AL, '='
    17 0000F2BB CD10                <2> 	INT 0X10	
    18 0000F2BD 58                  <2> 	POP AX
    19 0000F2BE 50                  <2> 	PUSH AX
    20 0000F2BF 88E0                <2> 	MOV AL, AH
    21 0000F2C1 E86700              <2> 	CALL WRITE_AL_INT10_E
    22 0000F2C4 58                  <2> 	POP AX
    23 0000F2C5 E86300              <2> 	CALL WRITE_AL_INT10_E
    24                              <2> 	
    25 0000F2C8 B40E                <2> 	MOV AH, 0X0E
    26 0000F2CA B020                <2> 	MOV AL, ' '
    27 0000F2CC CD10                <2> 	INT 0X10
    28 0000F2CE B042                <2> 	MOV AL, 'B'
    29 0000F2D0 CD10                <2> 	INT 0X10
    30 0000F2D2 B058                <2> 	MOV AL, 'X'	
    31 0000F2D4 CD10                <2> 	INT 0X10
    32 0000F2D6 B03D                <2> 	MOV AL, '='
    33 0000F2D8 CD10                <2> 	INT 0X10	
    34 0000F2DA 58                  <2> 	POP AX
    35 0000F2DB 50                  <2> 	PUSH AX
    36 0000F2DC 88E0                <2> 	MOV AL, AH
    37 0000F2DE E84A00              <2> 	CALL WRITE_AL_INT10_E
    38 0000F2E1 58                  <2> 	POP AX
    39 0000F2E2 E84600              <2> 	CALL WRITE_AL_INT10_E
    40                              <2> 	
    41 0000F2E5 B40E                <2> 	MOV AH, 0X0E
    42 0000F2E7 B020                <2> 	MOV AL, ' '
    43 0000F2E9 CD10                <2> 	INT 0X10
    44 0000F2EB B043                <2> 	MOV AL, 'C'
    45 0000F2ED CD10                <2> 	INT 0X10
    46 0000F2EF B058                <2> 	MOV AL, 'X'	
    47 0000F2F1 CD10                <2> 	INT 0X10
    48 0000F2F3 B03D                <2> 	MOV AL, '='
    49 0000F2F5 CD10                <2> 	INT 0X10	
    50 0000F2F7 58                  <2> 	POP AX
    51 0000F2F8 50                  <2> 	PUSH AX
    52 0000F2F9 88E0                <2> 	MOV AL, AH
    53 0000F2FB E82D00              <2> 	CALL WRITE_AL_INT10_E
    54 0000F2FE 58                  <2> 	POP AX
    55 0000F2FF E82900              <2> 	CALL WRITE_AL_INT10_E
    56                              <2> 	
    57 0000F302 B40E                <2> 	MOV AH, 0X0E
    58 0000F304 B020                <2> 	MOV AL, ' '
    59 0000F306 CD10                <2> 	INT 0X10
    60 0000F308 B044                <2> 	MOV AL, 'D'
    61 0000F30A CD10                <2> 	INT 0X10
    62 0000F30C B058                <2> 	MOV AL, 'X'	
    63 0000F30E CD10                <2> 	INT 0X10
    64 0000F310 B03D                <2> 	MOV AL, '='
    65 0000F312 CD10                <2> 	INT 0X10	
    66 0000F314 58                  <2> 	POP AX
    67 0000F315 50                  <2> 	PUSH AX
    68 0000F316 88E0                <2> 	MOV AL, AH
    69 0000F318 E81000              <2> 	CALL WRITE_AL_INT10_E
    70 0000F31B 58                  <2> 	POP AX
    71 0000F31C E80C00              <2> 	CALL WRITE_AL_INT10_E
    72                              <2> 	
    73 0000F31F B40E                <2> 	MOV AH, 0X0E
    74 0000F321 B00D                <2> 	MOV AL, 0X0D
    75 0000F323 CD10                <2> 	INT 0X10
    76 0000F325 B00A                <2> 	MOV AL, 0X0A
    77 0000F327 CD10                <2> 	INT 0X10	
    78 0000F329 58                  <2> 	POP AX
    79 0000F32A C3                  <2> 	RET
    80                              <2> ;;;;;;;;;;;;;;;;;;;;;;;
    81                              <2> ;WRITE TO SCREEN;;;;;;;
    82                              <2> ;;;;;;;;;;;;;;;;;;;;;;;
    83                              <2> WRITE_AL_INT10_E:
    84                              <2> 
    85 0000F32B 50                  <2> 	PUSH AX
    86 0000F32C 53                  <2> 	PUSH BX
    87 0000F32D 51                  <2> 	PUSH CX
    88 0000F32E 52                  <2> 	PUSH DX
    89                              <2> 
    90 0000F32F 88C3                <2> 	MOV BL, AL
    91                              <2> 
    92 0000F331 88C6                <2> 	MOV DH, AL
    93 0000F333 B104                <2> 	MOV CL, 0X04
    94 0000F335 D2EE                <2> 	SHR DH, CL
    95                              <2> 
    96 0000F337 88F0                <2> 	MOV AL, DH
    97 0000F339 240F                <2> 	AND AL, 0X0F
    98 0000F33B 3C09                <2> 	CMP AL, 0X09
    99 0000F33D 7704                <2> 	JA LETTER_HIGH
   100                              <2> 
   101 0000F33F 0430                <2> 	ADD AL, 0X30
   102 0000F341 EB02                <2> 	JMP PRINT_VALUE_HIGH
   103                              <2> 
   104                              <2> 	LETTER_HIGH:
   105 0000F343 0437                <2> 	ADD AL, 0X37
   106                              <2> 
   107                              <2> 	PRINT_VALUE_HIGH:
   108 0000F345 B40E                <2> 	MOV AH, 0X0E
   109 0000F347 CD10                <2> 	INT 0X10
   110                              <2> 
   111 0000F349 88D8                <2> 	MOV AL, BL
   112 0000F34B 240F                <2> 	AND AL, 0X0F
   113 0000F34D 3C09                <2> 	CMP AL, 0X09
   114 0000F34F 7704                <2> 	JA LETTER_LOW
   115                              <2> 
   116 0000F351 0430                <2> 	ADD AL, 0X30
   117 0000F353 EB02                <2> 	JMP PRINT_VALUE_LOW
   118                              <2> 
   119                              <2> 	LETTER_LOW:
   120 0000F355 0437                <2> 	ADD AL, 0X37
   121                              <2> 
   122                              <2> 	PRINT_VALUE_LOW:
   123 0000F357 B40E                <2> 	MOV AH, 0X0E
   124 0000F359 CD10                <2> 	INT 0X10
   125                              <2> 
   126 0000F35B 5A                  <2> 	POP DX
   127 0000F35C 59                  <2> 	POP CX
   128 0000F35D 5B                  <2> 	POP BX
   129 0000F35E 58                  <2> 	POP AX
   130                              <2> 
   131 0000F35F C3                  <2> 	RET
   132                              <2> 
   133                              <2> WAIT_1:
   134 0000F360 51                  <2> 	PUSH CX
   135 0000F361 B9FFFF              <2> 	MOV CX, 0XFFFF
   136                              <2>   .LOOP1:
   137 0000F364 E2FE                <2> 	LOOP .LOOP1
   138 0000F366 59                  <2> 	POP CX
   139 0000F367 C3                  <2> 	RET
   140                              <2> 
   141                              <2> WAIT_2:
   142 0000F368 51                  <2> 	PUSH CX
   143 0000F369 B9FFFF              <2> 	MOV CX, 0xFFFF		; 65536 runs = ~300k cycles = 40ms
   144 0000F36C E2FE                <2> DELAY: LOOP DELAY
   145 0000F36E B9FFFF              <2> 	MOV CX, 0xFFFF		; 65536 runs = ~300k cycles = 40ms
   146 0000F371 E2FE                <2> DELAY2: LOOP DELAY2
   147 0000F373 59                  <2> 	POP CX
   148 0000F374 C3                  <2> 	RET
   149                              <2> 
   150                              <2> WAIT_8:
   151 0000F375 51                  <2> 	PUSH CX
   152 0000F376 B90800              <2> 	MOV CX, 8
   153                              <2>   .LOOP1:
   154 0000F379 51                  <2> 	PUSH CX
   155 0000F37A B9FFFF              <2> 	MOV CX, 0XFFFF
   156                              <2>   .LOOP2:
   157 0000F37D E2FE                <2> 	LOOP .LOOP2
   158 0000F37F 59                  <2> 	POP CX
   159 0000F380 E2F7                <2> 	LOOP .LOOP1
   160 0000F382 59                  <2> 	POP CX
   161 0000F383 C3                  <2> 	RET
   162                              <2> 	
   163                              <2> WAIT_16:
   164 0000F384 51                  <2> 	PUSH CX
   165 0000F385 B91000              <2> 	MOV CX, 16
   166                              <2>   .LOOP1:
   167 0000F388 51                  <2> 	PUSH CX
   168 0000F389 B9FFFF              <2> 	MOV CX, 0XFFFF
   169                              <2>   .LOOP2:
   170 0000F38C E2FE                <2> 	LOOP .LOOP2
   171 0000F38E 59                  <2> 	POP CX
   172 0000F38F E2F7                <2> 	LOOP .LOOP1
   173 0000F391 59                  <2> 	POP CX
   174 0000F392 C3                  <2> 	RET
   175                              <2> 	
   176                              <2> WAIT_32:
   177 0000F393 51                  <2> 	PUSH CX
   178 0000F394 B92000              <2> 	MOV CX, 32
   179                              <2>   .LOOP1:
   180 0000F397 51                  <2> 	PUSH CX
   181 0000F398 B9FFFF              <2> 	MOV CX, 0XFFFF
   182                              <2>   .LOOP2:
   183 0000F39B E2FE                <2> 	LOOP .LOOP2
   184 0000F39D 59                  <2> 	POP CX
   185 0000F39E E2F7                <2> 	LOOP .LOOP1
   186 0000F3A0 59                  <2> 	POP CX
   187 0000F3A1 C3                  <2> 	RET
   188                              <2> 
   189                              <2> WAIT_64:
   190 0000F3A2 51                  <2> 	PUSH CX
   191 0000F3A3 B94000              <2> 	MOV CX, 64
   192                              <2>   .LOOP1:
   193 0000F3A6 51                  <2> 	PUSH CX
   194 0000F3A7 B9FFFF              <2> 	MOV CX, 0XFFFF
   195                              <2>   .LOOP2:
   196 0000F3AA E2FE                <2> 	LOOP .LOOP2
   197 0000F3AC 59                  <2> 	POP CX
   198 0000F3AD E2F7                <2> 	LOOP .LOOP1
   199 0000F3AF 59                  <2> 	POP CX
   200 0000F3B0 C3                  <2> 	RET
   201                              <2> 
   202                              <2> WAIT_128:
   203 0000F3B1 51                  <2> 	PUSH CX
   204 0000F3B2 B98000              <2> 	MOV CX, 128
   205                              <2>   .LOOP1:
   206 0000F3B5 51                  <2> 	PUSH CX
   207 0000F3B6 B9FFFF              <2> 	MOV CX, 0XFFFF
   208                              <2>   .LOOP2:
   209 0000F3B9 E2FE                <2> 	LOOP .LOOP2
   210 0000F3BB 59                  <2> 	POP CX
   211 0000F3BC E2F7                <2> 	LOOP .LOOP1
   212 0000F3BE 59                  <2> 	POP CX
   213 0000F3BF C3                  <2> 	RET
   214                              <2> 	
   215                              <2> 	
   216                              <2> WAIT_512:
   217 0000F3C0 51                  <2> 	PUSH CX
   218 0000F3C1 B90002              <2> 	MOV CX, 512
   219                              <2>   .LOOP1:
   220 0000F3C4 51                  <2> 	PUSH CX
   221 0000F3C5 B9FFFF              <2> 	MOV CX, 0XFFFF
   222                              <2>   .LOOP2:
   223 0000F3C8 E2FE                <2> 	LOOP .LOOP2
   224 0000F3CA 59                  <2> 	POP CX
   225 0000F3CB E2F7                <2> 	LOOP .LOOP1
   226 0000F3CD 59                  <2> 	POP CX
   227 0000F3CE C3                  <2> 	RET
   228                              <2> 
   229 0000F3CF 0D0A43707520203830- <2> str_8088        db      0Dh, 0Ah,"Cpu  8088 detected sem  FPU",0Dh, 0Ah,0
   229 0000F3D8 383820646574656374- <2>
   229 0000F3E1 65642073656D202046- <2>
   229 0000F3EA 50550D0A00          <2>
   230 0000F3EF 0D0A437075204E6563- <2> str_v20         db      0Dh, 0Ah,"Cpu Nec V20 detected sem FPU",0Dh, 0Ah,0
   230 0000F3F8 205632302064657465- <2>
   230 0000F401 637465642073656D20- <2>
   230 0000F40A 4650550D0A00        <2>
   231                              <2> cpu_check:
   232 0000F410 30C0                <2> 	xor	al, al				; Clean out al to set ZF
   233 0000F412 B040                <2> 	mov	al, 40h				; mul on V20 does not affect the zero flag
   234 0000F414 F6E0                <2> 	mul	al				;   but on an 8088 the zero flag is used
   235 0000F416 7407                <2> 	jz	.have_v20			; Was zero flag set?
   236 0000F418 BE[CFF3]            <2> 	mov	si,  str_8088		;   No, so we have an 8088 CPU
   237 0000F41B E800DE              <2>         call    pstr
   238 0000F41E C3                  <2> 	ret
   239                              <2> .have_v20:
   240 0000F41F BE[EFF3]            <2> 	mov	si,  str_v20		;   Otherwise we have a V20 CPU
   241 0000F422 E8F9DD              <2>         call    pstr
   242 0000F425 C3                  <2> 	ret
   243                              <2> 
   390                              <1> 
   244                                  
   245 0000F426 FF<rep BCAh>                    setloc	0FFF0h			; Power-On Entry Point, macro fills space from last line with FF
   245          ******************       warning: Inserting 3018 bytes [-w+user]
   246                                  start:
   247 0000FFF0 EA[00D0]00F0                    jmp     0F000h:reset
   248 0000FFF5 FF<rep Ah>                      setloc	0FFFFh			; Pad remainder of ROM
   248          ******************       warning: Inserting 10 bytes [-w+user]
   249 0000FFFF FF                      	      db	0ffh            
